(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{318:function(o,e,b){o.exports=b.p+"assets/img/Dubbo01.c5d6e358.png"},319:function(o,e,b){o.exports=b.p+"assets/img/Dubbo02.74ecc866.png"},320:function(o,e,b){o.exports=b.p+"assets/img/Dubbo03.77379119.png"},652:function(o,e,b){"use strict";b.r(e);var t=b(25),r=Object(t.a)({},(function(){var o=this,e=o.$createElement,t=o._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("h1",{attrs:{id:"dubbo面试问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo面试问题"}},[o._v("#")]),o._v(" dubbo面试问题")]),o._v(" "),t("h2",{attrs:{id:"dubbo是如何动态感知服务下线的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo是如何动态感知服务下线的"}},[o._v("#")]),o._v(" Dubbo是如何动态感知服务下线的？")]),o._v(" "),t("p",[o._v("首先，Dubbo默认采用Zookeeper实现服务的注册与服务发现，简单来说啊，就是多个Dubbo服务之间的通信地址，是使用Zookeeper来维护的。\n在Zookeeper上，会采用树形结构的方式来维护Dubbo服务提供端的协议地址。")]),o._v(" "),t("p",[t("img",{attrs:{src:b(318),alt:"img.png"}})]),o._v(" "),t("p",[o._v("Dubbo服务消费端会从Zookeeper Server上去查找目标服务的地址列表，从而完成服务的注册和消费的功能。\nZookeeper会通过心跳检测机制，来判断Dubbo服务提供端的运行状态，来决定是否应该把这个服务从地址列表剔除。")]),o._v(" "),t("p",[t("img",{attrs:{src:b(319),alt:"img.png"}})]),o._v(" "),t("p",[o._v("当Dubbo服务提供方出现故障导致Zookeeper剔除了这个服务的地址，\n那么Dubbo服务消费端需要感知到地址的变化，从而避免后续的请求发送到故障节点，导致请求失败。\n也就是说Dubbo要提供服务下线的动态感知能力。这个能力是通过Zookeeper里面提供的Watch机制来实现的")]),o._v(" "),t("p",[t("img",{attrs:{src:b(320),alt:"img.png"}})]),o._v(" "),t("p",[o._v("简单来说呢，Dubbo服务消费端会使用Zookeeper里面的Watch来针对Zookeeper Server端的/providers节点注册监听，\n一旦这个节点下的子节点发生变化，Zookeeper Server就会发送一个事件通知Dubbo Client端.\nDubbo Client端收到事件以后，就会把本地缓存的这个服务地址删除，这样后续就不会把请求发送到失败的节点上，完成服务下线感知。")]),o._v(" "),t("h2",{attrs:{id:"dubbo的服务请求失败怎么处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo的服务请求失败怎么处理"}},[o._v("#")]),o._v(" Dubbo的服务请求失败怎么处理？")]),o._v(" "),t("p",[o._v("Dubbo是一个RPC框架，它为我们的应用提供了远程通信能力的封装，同时，Dubbo在RPC通信的基础上，逐步在向一个生态在演进，它涵盖了服务注册、动态路由、容错、服务降级、负载均衡等能力，\n基本上在微服务架构下面临的问题，Dubbo都可以解决。")]),o._v(" "),t("p",[o._v("而对于"),t("strong",[o._v("Dubbo服务请求失败的场景，默认提供了重试的容错机制")]),o._v("，也就是说，如果基于Dubbo进行服务间通信出现异常，服务消费者会对服务提供者集群中其他的节点发起重试，确保这次请求成功，默认的额外重试次数是2次。")]),o._v(" "),t("p",[o._v("除此之外，Dubbo还提供了更多的容错策略，我们可以根据不同的业务场景来进行选择。")]),o._v(" "),t("ol",[t("li",[o._v("快速失败策略，服务消费者只发起一次请求，如果请求失败，就直接把错误抛出去。这种比较适合在非幂等性场景中使用。")]),o._v(" "),t("li",[o._v("失败安全策略，如果出现服务通信异常，直接把这个异常吞掉不做任何处理。")]),o._v(" "),t("li",[o._v("失败自动恢复策略，后台记录失败请求，然后通过定时任务来对这个失败的请求进行重发。")]),o._v(" "),t("li",[o._v("并行调用多个服务策略，就是把这个消息广播给服务提供者集群，只要有任何一个节点返回，就表示请求执行成功。")]),o._v(" "),t("li",[o._v("广播调用策略，逐个调用服务提供者集群，只要集群中任何一个节点出现异常，就表示本次请求失败。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);