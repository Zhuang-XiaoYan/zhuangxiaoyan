(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{493:function(t,a,e){t.exports=e.p+"assets/img/Reactor01.27fec94c.png"},494:function(t,a,e){t.exports=e.p+"assets/img/Reactor02.fa152004.png"},495:function(t,a,e){t.exports=e.p+"assets/img/Reactor03.0364119d.png"},496:function(t,a,e){t.exports=e.p+"assets/img/timewheel.62691ad3.png"},497:function(t,a,e){t.exports=e.p+"assets/img/IO01.9154c97e.png"},498:function(t,a,e){t.exports=e.p+"assets/img/IO02.4e9c2de2.png"},671:function(t,a,e){"use strict";e.r(a);var r=e(25),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"netty面试问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty面试问题"}},[t._v("#")]),t._v(" Netty面试问题")]),t._v(" "),r("h2",{attrs:{id:"netty中reactor模式的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty中reactor模式的理解"}},[t._v("#")]),t._v(" Netty中Reactor模式的理解")]),t._v(" "),r("p",[t._v("Reactor其实是在NIO多路复用的基础上提出的一个高性能IO设计模式。它的核心思想是把响应IO事件和业务处理进行分离，通过一个或者多个线程来处理IO事件。\n然后把就绪的事件分发给业务线程进行异步处理。")]),t._v(" "),r("p",[t._v("Reactor模型有三个重要的组件：")]),t._v(" "),r("ul",[r("li",[t._v("Reactor ：把I/O事件分发给对应的Handler")]),t._v(" "),r("li",[t._v("Acceptor ：处理客户端连接请求")]),t._v(" "),r("li",[t._v("Handlers ：执行非阻塞读/写，也就是针对收到的消息进行业务处理。")])]),t._v(" "),r("p",[t._v("在Reactor的这种设计中，有三种模型分别是")]),t._v(" "),r("ul",[r("li",[t._v("单线程Reactor模型。")]),t._v(" "),r("li",[t._v("多线程Reactor模型。")]),t._v(" "),r("li",[t._v("主从多Reactor多线程模型。")])]),t._v(" "),r("p",[t._v("单线程Reactor模型，就是由同一个线程来负责处理IO事件以及业务逻辑。")]),t._v(" "),r("p",[t._v("这种方式的缺点在于handler的执行过程是串行，如果有任何一个handler处理线程阻塞，就会影响整个服务的吞吐量。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(493),alt:"img.png"}})]),t._v(" "),r("p",[t._v("所以，就有了多线程Reactor模型。也就是把处理IO就绪事件的线程和处理Handler业务逻辑的线程进行分离，每个Handler由一个独立线程来处理，\n在这种设计下，即便是存在Handler线程阻塞问题，也不会对IO线程造成影响。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(494),alt:"img.png"}})]),t._v(" "),r("p",[t._v("在多线程Reactor模型下，所有的IO操作都是由一个Reactor来完成的，而且Reactor运行在单个线程里面。对于并发较高的场景下，Reactor就成为了性能瓶颈，所以在这个基础上做了更进一步优化。\n提出了多Reactor多线程模型，这种模式也叫Master-Workers模式。它把原本单个Reactor拆分成了Main Reactor和多个SubReactor，Main Reactor负责接收客户端的链接，然后把接收到的连接请求随机分配到多个subReactor里面。\nSubReactor负责IO事件的处理。这种方式另外一个好处就是可以对subReactor做灵活扩展，从而适应不同的并发量，解决了单个Reactor模式的性能瓶颈问题。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(495),alt:"img.png"}})]),t._v(" "),r("h2",{attrs:{id:"netty中时间轮的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty中时间轮的理解"}},[t._v("#")]),t._v(" netty中时间轮的理解？")]),t._v(" "),r("p",[t._v("时间轮，简单理解就是一种用来存储一系列定时任务的环状数组，它的整个工作原理和我们的钟表的表盘类似。它由两个部分组成， 一个是环状数组，另一个是遍历环状数组的指针。\n首先，定义一个固定长度的环状数组，然后数组的每一个元素代表一个时间刻度，假设是1s，那么如果是长度为8的数组，就代表8秒钟。\n然后，有一个指针，这个指针按照顺时针无线循环这个数组，每隔最小时间单位前进一个数组索引。\n这个指针转一圈代表8秒钟，转两圈表示16秒，假设从0点0分0秒开始，转一圈以后就到了0点0分9秒钟。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(496),alt:"img.png"}})]),t._v(" "),r("p",[t._v("当指针指向某个数组的时候，就会把这个数组中存储的任务取出来，然后遍历这个链表逐个运行里面的任务。如果某个定时任务的执行时间大于环形数组所表示的长度，一般可以使用一个圈数来表示该任务的延迟执行时间。\n也就是说，如果是第16秒要执行的任务，那意味着这个任务应该是在第二圈的数组下标0位置执行。")]),t._v(" "),r("p",[t._v("使用时间轮的方式来管理多个定时任务的好处有很多，我认为有两个核心原因：")]),t._v(" "),r("ol",[r("li",[t._v("减少定时任务添加和删除的时间复杂度，提升性能。")]),t._v(" "),r("li",[t._v("可保证每次执行定时器任务都是O（1）复杂度，在定时器任务密集的情况下，性能优势非常明显。")])]),t._v(" "),r("p",[t._v("当然，它也有缺点，对于执行时间非常严格的任务，时间轮不是很适合，因为时间轮算法的精度取决于最小时间单元的粒度。假设以1s为一个时间刻度，那小于1s的任务就无法被时间轮调度。时间轮算法在很多地方都有用到，比如Dubbo、Netty、Kafka等。")]),t._v(" "),r("h2",{attrs:{id:"io和nio有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#io和nio有什么区别"}},[t._v("#")]),t._v(" IO和NIO有什么区别？")]),t._v(" "),r("p",[t._v("首先，I/O ，指的是IO流， 它可以实现数据从磁盘中的读取以及写入。实际上，除了磁盘以外，内存、网络都可以作为I/O流的数据来源和目的地。\n在Java里面，提供了字符流和字节流两种方式来实现数据流的操作。其次，当程序是面向网络进行数据的IO操作的时候，Java里面提供了Socket的方式来实现。通过这种方式可以实现数据的网络传输。")]),t._v(" "),r("ul",[r("li",[t._v("基于Socket的IO通信，它是属于阻塞式IO，也就是说，在连接以及IO事件未就绪的情况下，当前的连接会处于阻塞等待的状态。")])]),t._v(" "),r("p",[r("img",{attrs:{src:e(497),alt:"img.png"}})]),t._v(" "),r("p",[t._v("如果一旦某个连接处于阻塞状态，那么后续的连接都得等待。所以服务端能够处理的连接数量非常有限。")]),t._v(" "),r("p",[t._v("NIO，是JDK1.4里面新增的一种NEW IO机制，相比于传统的IO，NIO在效率上做了很大的优化，并且新增了几个核心组件。Channel、Buffer、Selectors。\n另外，还提供了非阻塞的特性，所以，对于网络IO来说，NIO通常也称为No-Block IO，非阻塞IO。")]),t._v(" "),r("p",[t._v("也就是说，通过NIO进行网络数据传输的时候，如果连接未就绪或者IO事件未就绪的情况下，服务端不会阻塞当前连接，而是继续去轮询后续的连接来处理。\n所以在NIO里面，服务端能够并行处理的链接数量更多。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(498),alt:"img.png"}})]),t._v(" "),r("p",[t._v("因此，总的来说，IO和NIO的区别，站在网络IO的视角来说，前者是阻塞IO，后者是非阻塞IO。")])])}),[],!1,null,null,null);a.default=s.exports}}]);