(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{490:function(a,s,t){a.exports=t.p+"assets/img/Nacos01.b6fb0296.png"},491:function(a,s,t){a.exports=t.p+"assets/img/Nacos02.9aabdfdc.png"},492:function(a,s,t){a.exports=t.p+"assets/img/Nacos03.f2adc855.png"},670:function(a,s,t){"use strict";t.r(s);var v=t(25),_=Object(v.a)({},(function(){var a=this,s=a.$createElement,v=a._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"nacos面试问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nacos面试问题"}},[a._v("#")]),a._v(" Nacos面试问题")]),a._v(" "),v("h2",{attrs:{id:"nacos配置更新的工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nacos配置更新的工作流程"}},[a._v("#")]),a._v(" Nacos配置更新的工作流程")]),a._v(" "),v("ul",[v("li",[a._v("首先，Nacos是采用长轮训的方式向Nacos Server端发起配置更新查询的功能。所谓长轮训就是客户端发起一次轮训请求到服务端，当服务端配置没有任何变更的时候，\n这个连接一直打开。直到服务端有配置或者连接超时后返回。")])]),a._v(" "),v("p",[v("img",{attrs:{src:t(490),alt:"img.png"}})]),a._v(" "),v("p",[a._v("Nacos Client端需要获取服务端变更的配置，前提是要有一个比较，也就是拿客户端本地的配置信息和服务端的配置信息进行比较。\n一旦发现和服务端的配置有差异，就表示服务端配置有更新，于是把更新的配置拉到本地。在这个过程中，有可能因为客户端配置比较多，导致比较的时间较长，使得配置同步较慢的问题。")]),a._v(" "),v("p",[a._v("于是Nacos针对这个场景，做了两个方面的优化。")]),a._v(" "),v("ol",[v("li",[a._v("减少网络通信的数据量，客户端把需要进行比较的配置进行分片，每一个分片大小是3000，也就是说，每次最多拿3000个配置去Nacos Server端进行比较。")]),a._v(" "),v("li",[a._v("分阶段进行比较和更新，第一阶段，客户端把这3000个配置的key以及对应的value值的md5拼接成一个字符串，然后发送到Nacos Server端进行判断，服务端会逐个比较这些配置中md5不同的key，把存在更新的key返回给客户端。\n第二阶段，客户端拿到这些变更的key，循环逐个去调用服务单获取这些key 的value值。")])]),a._v(" "),v("p",[a._v("这两个优化，核心目的是减少网络通信数据包的大小，把一次大的数据包通信拆分成了多次小的数据包通信。虽然会增加网络通信次数，但是对整体的性能有较大的提升。\n最后，再采用长连接这种方式，既减少了pull轮询次数，又利用了长连接的优势，很好的实现了配置的动态更新同步功能。")]),a._v(" "),v("h2",{attrs:{id:"nacos配置中心集群原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nacos配置中心集群原理"}},[a._v("#")]),a._v(" Nacos配置中心集群原理")]),a._v(" "),v("p",[a._v("Nacos作为配置中心，必然需要保证服务节点的高可用性，那么Nacos是如何实现集群的呢？")]),a._v(" "),v("p",[v("img",{attrs:{src:t(491),alt:"img.png"}})]),a._v(" "),v("p",[a._v("Nacos集群工作原理: Nacos作为配置中心的集群结构中，是一种无中心化节点的设计，由于没有主从节点，也没有选举机制，所以为了能够实现热备，就需要增加虚拟IP（VIP）。")]),a._v(" "),v("p",[a._v("Nacos的数据存储分为两部分")]),a._v(" "),v("ol",[v("li",[a._v("Mysql数据库存储，所有Nacos节点共享同一份数据，数据的副本机制由Mysql本身的主从方案来解决，从而保证数据的可靠性。")]),a._v(" "),v("li",[a._v("每个节点的本地磁盘，会保存一份全量数据，具体路径：/data/program/nacos-1/data/config-data/${GROUP}.")])]),a._v(" "),v("p",[a._v("在Nacos的设计中，Mysql是一个中心数据仓库，且认为在Mysql中的数据是绝对正确的。 除此之外，Nacos在启动时会把Mysql中的数据写一份到本地磁盘。\n这么设计的好处是可以提高性能，当客户端需要请求某个配置项时，服务端会想Ian从磁盘中读取对应文件返回，而磁盘的读取效率要比数据库效率高。")]),a._v(" "),v("p",[a._v("当配置发生变更时：")]),a._v(" "),v("ol",[v("li",[a._v("Nacos会把变更的配置保存到数据库，然后再写入本地文件。")]),a._v(" "),v("li",[a._v("接着发送一个HTTP请求，给到集群中的其他节点，其他节点收到事件后，从Mysql中dump刚刚写入的数据到本地文件中。")])]),a._v(" "),v("p",[a._v("另外，NacosServer启动后，会同步启动一个定时任务，每隔6小时，会dump一次全量数据到本地文件.")]),a._v(" "),v("h2",{attrs:{id:"客户端配置缓存更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#客户端配置缓存更新"}},[a._v("#")]),a._v(" 客户端配置缓存更新")]),a._v(" "),v("p",[a._v("当客户端拿到配置后，需要动态刷新，从而保证数据和服务器端是一致的，这个过程是如何实现的呢？在这一小节中我们来做一个详细分析。")]),a._v(" "),v("p",[a._v("Nacos采用长轮训机制来实现数据变更的同步，原理如下！")]),a._v(" "),v("p",[v("img",{attrs:{src:t(492),alt:"img.png"}})]),a._v(" "),v("p",[a._v("整体工作流程如下：")]),a._v(" "),v("ol",[v("li",[a._v("客户端发起长轮训请求")]),a._v(" "),v("li",[a._v("服务端收到请求以后，先比较服务端缓存中的数据是否相同，如果不通，则直接返回")]),a._v(" "),v("li",[a._v("如果相同，则通过schedule延迟29.5s之后再执行比较")]),a._v(" "),v("li",[a._v("为了保证当服务端在29.5s之内发生数据变化能够及时通知给客户端，服务端采用事件订阅的方式来监听服务端本地数据变化的事件，一旦收到事件，则触发DataChangeTask的通知，并且遍历allStubs队列中的ClientLongPolling,把结果写回到客户端，就完成了一次数据的推送")]),a._v(" "),v("li",[a._v("如果 DataChangeTask 任务完成了数据的 “推送” 之后，ClientLongPolling 中的调度任务又开始执行了怎么办呢？")]),a._v(" "),v("li",[a._v("很简单，只要在进行 “推送” 操作之前，先将原来等待执行的调度任务取消掉就可以了，这样就防止了推送操作写完响应数据之后，调度任务又去写响应数据，这时肯定会报错的。所以，在ClientLongPolling方法中，最开始的一个步骤就是删除订阅事件")])])])}),[],!1,null,null,null);s.default=_.exports}}]);