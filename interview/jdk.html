<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JDK面试问题 | 庄小焱</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="我是庄小焱，PMP项目管理专家、系统架构设计师(高级)、CSDN博文专家、后端开发工程师。 博主在微服务、虚拟化、系统架构、大数据、机器学习领域不断学习，同时在博客中分享自己学习知识和相关技术， 欢迎大家和我交流学习，欢迎大家关注我的博客。">
    
    <link rel="preload" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css" as="style"><link rel="preload" href="/zhuangxiaoyan/assets/js/app.868ae4fe.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/9.7d7583a8.js" as="script"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/10.f03f824c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/11.8bbceb5f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/12.14f9a7e9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/13.875c4422.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/14.b913d772.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/15.04d0022c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/16.2f5474ed.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/17.314561f8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/18.4f00aff9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/19.3198a9c6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/20.6ca58bc3.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/21.2b13b489.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/22.1ab1c76c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/23.71e25b05.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/24.ad6ea50e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/25.76e0a373.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/26.b9862941.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/27.aa410472.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/28.03808d20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/29.00bd7baa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/3.08485426.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/30.005c22a8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/31.93f0d38f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/32.340f8c91.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/33.4fd282b8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/34.3a5d80ea.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/35.46a3fd70.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/36.a4d7d4a0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/37.f4563f51.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/38.a4755c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/39.38a44f79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/4.4d57c8c0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/40.7ace36ef.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/41.16f6b68f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/42.6d72579b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/43.c87acddc.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/44.29fd9c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/45.1e066d5b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/46.38a90e06.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/47.d01627f0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/48.a24f2064.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/49.b385ae96.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/5.113b6e17.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/50.36614d52.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/51.0a4de0f4.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/52.f34a7e67.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/53.628cf4ca.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/54.cc220f8a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/55.44be834a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/56.a10f9160.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/57.889877cb.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/58.35998118.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/59.a96ac910.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/6.1a9b2f20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/60.69ed00aa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/61.cd318979.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/62.c1d36d16.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/63.d5921184.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/64.e337ae65.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/65.4754688d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/66.f1e18825.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/67.90234ef8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/68.17c41d12.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/69.d424f938.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/7.713b03d2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/70.dcbc2969.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/71.7dce671a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/72.ca24dbed.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/73.3746d1d5.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/74.b57bc73f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/75.9bcbf8d9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/76.ad9819f6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/77.1939880d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/78.d4fe71a2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/79.95e3a69e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/8.4562fbf2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/80.0c9cbcee.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/81.9f9d8638.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/82.4aeef92d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/83.d69f52f7.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/84.a5ef042c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/85.c37ffab6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/86.6d5b65db.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/87.afa8b536.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/88.1c19772d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/89.5f70dc04.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/90.2a690c79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/91.4d0be90d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/92.d82b3978.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/93.50ab1b48.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/94.b8bd6e2a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/95.1fc4557e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/96.7063edd6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/97.a7fd9d56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/98.c7605566.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/99.6fe2324c.js">
    <link rel="stylesheet" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zhuangxiaoyan/" class="home-link router-link-active"><!----> <span class="site-name">庄小焱</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>分布式设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/" aria-current="page" class="sidebar-link">场景面试问题总结</a></li><li><a href="/zhuangxiaoyan/interview/distributed-arithmetic.html" class="sidebar-link">分布式原理算法</a></li><li><a href="/zhuangxiaoyan/interview/distributed-id.html" class="sidebar-link">分布式ID原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-lock.html" class="sidebar-link">分布式锁原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-transaction.html" class="sidebar-link">分布式事务原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-throttling.html" class="sidebar-link">分布式限流原理与设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java语言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/java-base.html" class="sidebar-link">java面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mysql.html" class="sidebar-link">Mysql面试问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-backup.html" class="sidebar-link">数据库与缓存一致性</a></li><li><a href="/zhuangxiaoyan/interview/mysql-cluster.html" class="sidebar-link">Mysql主从问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-slow-query.html" class="sidebar-link">数据查询优化设计</a></li><li><a href="/zhuangxiaoyan/interview/mysql-split-table.html" class="sidebar-link">数据分库分表设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>并发编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/juc.html" class="sidebar-link">JUC面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>源码分析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jdk.html" aria-current="page" class="active sidebar-link">JDK面试问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#arraylist和linkedlist的区别" class="sidebar-link">Arraylist和Linkedlist的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#hahmap底层数据结构" class="sidebar-link">Hahmap底层数据结构</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#hashmap的扩容机制" class="sidebar-link">Hashmap的扩容机制</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#hashmap多线程的安全问题" class="sidebar-link">Hashmap多线程的安全问题</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#concurrenthashmap原理" class="sidebar-link">ConcurrentHashMap原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#list主要实现类" class="sidebar-link">List主要实现类</a></li></ul></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#set和list区别" class="sidebar-link">Set和List区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#string的字符串不可变性" class="sidebar-link">String的字符串不可变性</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#substring的原理及区别" class="sidebar-link">substring的原理及区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#string对-的重载" class="sidebar-link">String对+的重载</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#string拼接方式" class="sidebar-link">String拼接方式</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#valueof和tostring的区别" class="sidebar-link">valueOf和toString的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#switch对string的支持" class="sidebar-link">switch对String的支持</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#字符串池" class="sidebar-link">字符串池</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#class常量池" class="sidebar-link">Class常量池</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#intern方法" class="sidebar-link">intern方法</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#为什么concurrenthashmap中key不允许为null" class="sidebar-link">为什么ConcurrentHashMap中key不允许为null？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#simpledateformat是线程安全的吗" class="sidebar-link">SimpleDateFormat是线程安全的吗?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jdk.html#hashmap是怎么解决哈希冲突的" class="sidebar-link">HashMap是怎么解决哈希冲突的？</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>虚拟机</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jvm.html" class="sidebar-link">JVM面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/network.html" class="sidebar-link">网络面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/os.html" class="sidebar-link">OS面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring.html" class="sidebar-link">spring面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring-Cloud框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring-cloud.html" class="sidebar-link">SpringCloud面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>设计模式</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/pattern.html" class="sidebar-link">设计模式面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Redis中间件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/redis.html" class="sidebar-link">Redis面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Mybatis框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mybatis.html" class="sidebar-link">Mybatis面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>MQ框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mq.html" class="sidebar-link">MQ面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Nginx框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/nginx.html" class="sidebar-link">nginx面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>微服务设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/micro-idempotent.html" class="sidebar-link">幂等性原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-auth.html" class="sidebar-link">认证授权设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-encryption.html" class="sidebar-link">加密算法总结</a></li><li><a href="/zhuangxiaoyan/interview/micro-other.html" class="sidebar-link">综合场景面试问题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="jdk面试问题"><a href="#jdk面试问题" class="header-anchor">#</a> JDK面试问题</h1> <p>Collection 是一个集合接口。 它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。是list，set等的父接口。
Collections 是一个包装类。 它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。
日常开发中，不仅要了解Java中的Collection及其子类的用法，还要了解Collections用法。</p> <h2 id="arraylist和linkedlist的区别"><a href="#arraylist和linkedlist的区别" class="header-anchor">#</a> Arraylist和Linkedlist的区别</h2> <ul><li>Arraylist: 底层是基于动态数组，根据下表随机访问数组元素的效率高，向数组尾部添加元素的效率高；但是，删除数组中的数据以及向数组中间添加数据效率低，因为需要移动数组。</li> <li>Arraylist:它的默认初始化长度为 10；同时它也是支持动态扩容的，通过这个方法进行动态扩容新增加的容量大小为原容量大小的50%。 底层调用的就是Arrays.copyOf(elementData,newCapacity)，</li> <li>Linklist: 基于链表的动态数组，数据添加删除效率高，只需要改变指针指向即可，但是访问数据的平均效率低，需要对链表进行遍历.</li> <li>LinkedList：可知该链表是双向链表，即可以从头遍历到尾，也可以从尾遍历到头。同样它也是线程不安全的，在这里最可能的造成的并发原因就是链表成环。</li></ul> <h2 id="hahmap底层数据结构"><a href="#hahmap底层数据结构" class="header-anchor">#</a> Hahmap底层数据结构</h2> <p>HashMap 基于 hashing 原理，我们通过 put()和 get()方法储存和获取对象。当我们将键值对传递给 put()方法时，
它调用键对象的 hashCode()方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，
通过键对象的 equals()方法找到正确的键值对，然后返回值对象。HashMap 使用链表来解决碰撞问题，当发生碰撞了，
对象将会储存在链表的下一个节点中。 HashMap 在每个链表节点中储存键值对对象。当两个不同的键对象的 hashcode 相同时会发生什么？
它们会储存在同一个 bucket 位置的链表中。键对象的 equals()方法用来找到键值对。</p> <p><img src="/zhuangxiaoyan/assets/img/hashmap.cbed41e5.png" alt="img.png"></p> <p>Hashmap 中解决 hash 冲突的方式的是采用还数组+链表的结构。在链表的插入操作的时候是在头部进行插入的时候更快的。
而不是在链表的尾部，因为链表是需要遍历才能找到尾部的。在JDK1.7 中的时候 hashmap 中的采用的结构是数组+链表，但是还是存在效率的问题。
就是在遍历的链表的时候需要很长的时间。如果是需要采用的二叉树或者是排序树的时候可能有存在当二叉树退化为为链表的时候和严重的性能时间。
所以 JDK1.8 中采用的是数组+链表+红黑树一种数据结构。</p> <p>HashMap 中初始化大小为什么是 16？ 为什么链表的长度为 8 是变成红黑树？为什么为 6 时又变成链表?</p> <p>链表长度大于八的条件，实际上是需要两个条件的：链表长度大于 8，官方源码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当满足条件 1 以后 调用 treeifyBin 方法转化红黑树 。该方 法中，数组如 果长度 小于MIN_TREEIFY_CAPACITY（64）就选择扩容，而不是转化为红黑树。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab， <span class="token keyword">int</span> hash<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> n，index<span class="token punctuation">;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>tab<span class="token operator">==</span><span class="token keyword">null</span> <span class="token function">ll</span><span class="token punctuation">(</span>n<span class="token operator">=</span>tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token class-name">MIN_</span> TREEIFY_CAPACITY<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="hashmap的扩容机制"><a href="#hashmap的扩容机制" class="header-anchor">#</a> Hashmap的扩容机制</h2> <p>装载因子，是一个 0-1 之间的系数，根据它来确定需要扩容的阈值，默认值是 0.75，当数据的大于真个数组的 0.75 倍的时候真个时候扩大为原来的 2 倍在将原来的数据复制到性的数据中。</p> <p><strong>负载因子为什么是 0.75？</strong></p> <p>当负载因子是 1.0 的时候，也就意味着，只有当数组的 8 个值（这个图表示了 8 个）全部填充了，才会发生扩容。这就带来了很大的问题，因为 Hash 冲突时避免不了的。
当负载因子是 1.0的时候，意味着会出现大量的 Hash 的冲突，底层的红黑树变得异常复杂。对于查询效率极其不利。这种情况就是牺牲了时间来保证空间的利用率。</p> <p><strong>为什么不采用 AVL 树二采用的是的是红黑树？</strong></p> <p>红黑树和 AVL 树都是最常用的平衡二叉搜索树，它们的查找、删除、修改都是 Olong(n)；</p> <ol><li>AVL 树是更加严格的平衡，因此可以提供更快的查找速度，一般读取查找密集型任务，适用AVL 树。</li> <li>红黑树更适合于插入修改密集型任务。</li> <li>AVL 树的旋转比红黑树的旋转更加难以平衡和调试。AVL 以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。</li></ol> <p><strong>AVL 树和红黑树有几点比较和区别</strong></p> <ol><li>AVL 以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。</li> <li>两种实现都缩放为 O(lg(N))，其中 N 是叶子的数量，但实际上 AVL 树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。
另一方面，插入和删除方面，AVL 树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。</li> <li>在 AVL 树中，从根到任何叶子的最短路径和最长路径之间的差异最多为 1。在红黑树中，差异可以是 2 倍。</li> <li>两个都给 O（log n）查找，但平衡 AVL 树可能需要 O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查 O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。</li></ol> <h2 id="hashmap多线程的安全问题"><a href="#hashmap多线程的安全问题" class="header-anchor">#</a> Hashmap多线程的安全问题</h2> <p><strong>可能产生元素丢失的现象</strong>
考虑在多线程下 put 操作时，执行 addEntry(hash, key, value, i)，如果有产生哈希碰撞，导致两个线程得到同样的bucketIndex 去存储，就可能会出现覆盖丢失的情况。</p> <p><strong>put 非 null 元素后 get 出来的却是 null</strong></p> <p>在原理的链表的数据的时候，可能会存放在新节点的因为 hash 值是 hash(key)%(n-1)来表示:在当一个线程遍历的是时候其他的线程获取到了这个值 这将这里 null 值放置新的为链表下。所以可能会造成是的 null 的值</p> <p><strong>单链表闭环</strong></p> <p>多线程put后可能导致get死循环。CPU 利用率过高一般是因为出现了出现了死循环，导致部分线程一直运行，占用cpu 时间。
那么 JDk1.7 中使用头插法新的 hash 桶会倒置原 hash 桶中的单链表，插入在多个线程同时扩容的情况下就可能导致产生一个存在闭环的单链表，从而导致死循环在。
改进的方法：JDK1.8 中的采用的是在尾部进行增加的元素。而不是在链头部。</p> <p><strong>为什么使用分段锁可以来用解决的这个hashmap中的数据丢失的问题？</strong></p> <p>分段锁是确保每一段的数据都是数据的安全。这样全局都是安全按的。这样在数据做扩容的或者是移动的时候是不予许有其他线程的使用。从而能够保证数据安全</p> <h2 id="concurrenthashmap原理"><a href="#concurrenthashmap原理" class="header-anchor">#</a> ConcurrentHashMap原理</h2> <p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，
Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。
ConcurrentHashMap 是一个 Segment 数组 Segment 通过继承 ReentrantLock来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，
这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p> <p><img src="/zhuangxiaoyan/assets/img/ConcurrentHashMap.a8a82cb3.png" alt="img.png"></p> <p>ConcurrentHashMap在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node+CAS+Synchronized 来保证并发安全进行实现，
synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p> <h3 id="list主要实现类"><a href="#list主要实现类" class="header-anchor">#</a> List主要实现类</h3> <p>List主要有ArrayList、LinkedList与Vector几种实现。这三者都实现了List 接口，使用方式也很相似,主要区别在于因为实现方式的不同,所以对不同的操作具有不同的效率。</p> <ul><li>ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组.</li> <li>LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.</li> <li>Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。</li> <li>Vector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%.</li> <li>而 LinkedList 还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.</li> <li>注意: 默认情况下ArrayList的初始容量非常小,所以如果可以预估数据量的话,分配一个较大的初始值属于最佳实践,这样可以减少调整大小的开销。</li></ul> <h2 id="set和list区别"><a href="#set和list区别" class="header-anchor">#</a> Set和List区别</h2> <p>List,Set都是继承自Collection接口。都是用来存储一组相同类型的元素的。</p> <ul><li>List特点：元素有放入顺序，元素可重复 。有顺序，即先放入的元素排在前面。</li> <li>Set特点：元素无放入顺序，元素不可重复。无顺序，即先放入的元素不一定排在前面。 不可重复，即相同元素在set中只会保留一份。
所以，有些场景下，set可以用来去重。 不过需要注意的是，set在元素插入时是要有一定的方法来判断元素是否重复的。</li></ul> <h2 id="string的字符串不可变性"><a href="#string的字符串不可变性" class="header-anchor">#</a> String的字符串不可变性</h2> <p>String在Java中特别常用，而且我们经常要在代码中对字符串进行赋值和改变他的值，但是，为什么我们说字符串是不可变的呢？
首先，我们需要知道什么是不可变对象？不可变对象是在完全创建后其内部状态保持不变的对象。这意味着，一旦对象被赋值给变量，
我们既不能更新引用，也不能通过任何方式改变内部状态。可是有人会有疑惑，String为什么不可变，我的代码中经常改变String的值啊，如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">&quot;ef&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样，操作，不就将原本的&quot;abcd&quot;的字符串改变成&quot;abcdef&quot;了么？
但是，虽然字符串内容看上去从&quot;abcd&quot;变成了&quot;abcdef&quot;，但是实际上，我们得到的已经是一个新的字符串了。</p> <p><img src="/zhuangxiaoyan/assets/img/String01.6caf88cd.png" alt="img.png"></p> <p>如上图，在堆中重新创建了一个&quot;abcdef&quot;字符串，和&quot;abcd&quot;并不是同一个对象。
所以，一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。而且，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。
如果我们想要一个可修改的字符串，可以选择StringBuffer 或者 StringBuilder这两个代替String。</p> <p><strong>为什么String要设计成不可变</strong></p> <p>在知道了&quot;String是不可变&quot;的之后，大家是不是一定都很疑惑：为什么要把String设计成不可变的呢？有什么好处呢？
这个问题，困扰过很多人，甚至有人直接问过Java的创始人James Gosling。在一次采访中James Gosling被问到什么时候应该使用不可变变量，他给出的回答是:
其实，主要是从缓存、安全性、线程安全和性能等角度触发的。</p> <ol><li>缓存</li></ol> <p>字符串是使用最广泛的数据结构。大量的字符串的创建是非常耗费资源的，所以，Java提供了对字符串的缓存功能，可以大大的节省堆空间。
JVM中专门开辟了一部分空间来存储Java字符串，那就是字符串池。通过字符串池，两个内容相同的字符串变量，可以从池中指向同一个字符串对象，从而节省了关键的内存资源。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> s<span class="token punctuation">;</span>
</code></pre></div><p>对于这个例子，s和s2都表示&quot;abcd&quot;，所以他们会指向字符串池中的同一个字符串对象：</p> <p><img src="/zhuangxiaoyan/assets/img/String02.e7c87421.png" alt="img_1.png"></p> <p>但是，之所以可以这么做，主要是因为字符串的不变性。试想一下，如果字符串是可变的，我们一旦修改了s的内容，那必然导致s2的内容也被动的改变了，这显然不是我们想看到的。</p> <ol start="2"><li>安全性</li></ol> <p>字符串在Java应用程序中广泛用于存储敏感信息，如用户名、密码、连接url、网络连接等。JVM类加载器在加载类的时也广泛地使用它。
因此，保护String类对于提升整个应用程序的安全性至关重要。当我们在程序中传递一个字符串的时候，如果这个字符串的内容是不可变的，那么我们就可以相信这个字符串中的内容。
但是，如果是可变的，那么这个字符串内容就可能随时都被修改。那么这个字符串内容就完全不可信了。这样整个系统就没有安全性可言了.</p> <ol start="3"><li>线程安全</li></ol> <p>不可变会自动使字符串成为线程安全的，因为当从多个线程访问它们时，它们不会被更改。
因此，一般来说，不可变对象可以在同时运行的多个线程之间共享。它们也是线程安全的，因为如果线程更改了值，
那么将在字符串池中创建一个新的字符串，而不是修改相同的值。因此，字符串对于多线程来说是安全的。</p> <ol start="4"><li>hashcode缓存</li></ol> <p>由于字符串对象被广泛地用作数据结构，它们也被广泛地用于哈希实现，如HashMap、HashTable、HashSet等。在对这些散列实现进行操作时，经常调用hashCode()方法。
不可变性保证了字符串的值不会改变。因此，hashCode()方法在String类中被重写，以方便缓存，这样在第一次hashCode()调用期间计算和缓存散列，并从那时起返回相同的值。</p> <ol start="5"><li>性能</li></ol> <p>前面提到了的字符串池、hashcode缓存等，都是提升性能的提现。
因为字符串不可变，所以可以用字符串池缓存，可以大大节省堆内存。而且还可以提前对hashcode进行缓存，更加高效
由于字符串是应用最广泛的数据结构，提高字符串的性能对提高整个应用程序的总体性能有相当大的影响。</p> <h2 id="substring的原理及区别"><a href="#substring的原理及区别" class="header-anchor">#</a> substring的原理及区别</h2> <p>String是Java中一个比较基础的类，每一个开发人员都会经常接触到。而且，String也是面试中经常会考的知识点。
String有很多方法，有些方法比较常用，有些方法不太常用。今天要介绍的substring就是一个比较常用的方法，而且围绕substring也有很多面试题。</p> <p>substring(int beginIndex, int endIndex)方法在不同版本的JDK中的实现是不同的。了解他们的区别可以帮助你更好的使用他。
为简单起见，后文中用substring()代表substring(int beginIndex, int endIndex)方法。</p> <p>substring() 的作用 substring(int beginIndex, int endIndex)方法截取字符串并返回其[beginIndex,endIndex-1]范围内的内容。</p> <p><img src="/zhuangxiaoyan/assets/img/String03.ba9b6d41.png" alt="img_2.png"></p> <p>然而，这个图不是完全正确的表示堆中发生的事情。因为在jdk6 和 jdk7中调用substring时发生的事情并不一样。</p> <p><strong>JDK 6中的substring</strong></p> <p>String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：char value[]， int offset，int count。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。
当调用substring方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的。</p> <p><img src="/zhuangxiaoyan/assets/img/String04.4ae0a57f.png" alt="img_3.png"></p> <p>下面是证明上说观点的Java源码中的关键代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//JDK 6</span>
<span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//check boundary</span>
    <span class="token keyword">return</span>  <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> beginIndex<span class="token punctuation">,</span> endIndex <span class="token operator">-</span> beginIndex<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>JDK 6中的substring导致的问题</strong></p> <p>如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，
但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。
在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。<code>x = x.substring(x, y) + &quot;&quot;</code></p> <p><strong>JDK 7 中的substring</strong></p> <p>上面提到的问题，在jdk 7中得到解决。在jdk 7 中，substring方法会在堆内存中创建一个新的数组。</p> <p><img src="/zhuangxiaoyan/assets/img/String05.b0a88a12.png" alt="img_4.png"></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//JDK 7</span>
<span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//check boundary</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> offset <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//check boundary</span>
    <span class="token keyword">int</span> subLen <span class="token operator">=</span> endIndex <span class="token operator">-</span> beginIndex<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> beginIndex<span class="token punctuation">,</span> subLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上是JDK 7中的subString方法，其使用new String创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。
所以，如果你的生产环境中使用的JDK版本小于1.7，当你使用String的subString方法时一定要注意，避免内存泄露。</p> <h2 id="string对-的重载"><a href="#string对-的重载" class="header-anchor">#</a> String对+的重载</h2> <p>Java中，想要拼接字符串，最简单的方式就是通过&quot;+&quot;连接两个字符串。有人把Java中使用+拼接字符串的功能理解为运算符重载。
其实并不是，Java是不支持运算符重载的。这其实只是Java提供的一个语法糖。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> wechat <span class="token operator">=</span> <span class="token string">&quot;zhuangxiaoyan&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> introduce <span class="token operator">=</span> <span class="token string">&quot;每日更新Java相关技术文章&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> hollis <span class="token operator">=</span> wechat <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> introduce<span class="token punctuation">;</span>
</code></pre></div><p>反编译后的内容如下，反编译工具为jad。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> wechat <span class="token operator">=</span> <span class="token string">&quot;Hollis&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> introduce <span class="token operator">=</span> <span class="token string">&quot;\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6587\u7AE0&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> hollis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>wechat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>introduce<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。
那么也就是说，Java中的+对字符串的拼接，其实现原理是使用StringBuilder.append。
但是，String的使用+字符串拼接也不全都是基于StringBuilder.append，还有种特殊情况，那就是如果是两个固定的字面量拼接，如：<code>String s = &quot;a&quot; + &quot;b&quot;</code>
编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，直接变成 String s = &quot;ab&quot;。</p> <h2 id="string拼接方式"><a href="#string拼接方式" class="header-anchor">#</a> String拼接方式</h2> <p>常用的字符串拼接方式有五种，分别是使用<code>+、使用concat、使用StringBuilder、使用StringBuffer以及使用StringUtils.join</code>。
由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。
因此，经过对比，我们发现，直接使用StringBuilder的方式是效率最高的。因为StringBuilder天生就是设计来定义可变字符串和字符串的变化操作的。但是，还要强调的是：</p> <ol><li>如果不是在循环体中进行字符串拼接的话，直接使用+就好了。</li> <li>如果在并发场景中进行字符串拼接的话，要使用StringBuffer来代替StringBuilder。</li></ol> <p>还有一个重要的拼接方式我没有介绍，那就是Java 8中提供的StringJoiner ，本文就来介绍一下这个字符串拼接的新兵。
StringJoiner是java.util包中的一个类，用于构造一个由分隔符分隔的字符序列（可选），并且可以从提供的前缀开始并以提供的后缀结尾。
虽然这也可以在StringBuilder类的帮助下在每个字符串之后附加分隔符，但StringJoiner提供了简单的方法来实现，而无需编写大量代码。</p> <p>StringJoiner类共有2个构造函数，5个公有方法。其中最常用的方法就是add方法和toString方法，类似于StringBuilder中的append方法和toString方法。</p> <p>StringJoiner的用法比较简单，下面的代码中，我们使用StringJoiner进行了字符串拼接。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringJoinerTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">StringJoiner</span> sj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token string">&quot;Hollis&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;zhuangxiaoyan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Java干货&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">StringJoiner</span> sj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringJoiner</span><span class="token punctuation">(</span><span class="token string">&quot;:&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;[&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        sj1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;zhuangxiaoyan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;zhuangxiaoyan&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Java干货&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sj1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>以上代码输出结果：<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
        zhuangxiaoyanchuangzhuangxiaoyanJava干货
        <span class="token punctuation">[</span>zhuangxiaoyan<span class="token operator">:</span>zhuangxiaoyan<span class="token operator">:</span><span class="token class-name">Java</span>干货<span class="token punctuation">]</span>
</code></pre></div><p>值得注意的是，当我们<code>StringJoiner(CharSequence delimiter)</code>初始化一个StringJoiner的时候，这个<code>delimiter</code>其实是分隔符，并不是可变字符串的初始值。
<code>StringJoiner(CharSequence delimiter,CharSequence prefix,CharSequence suffix)</code>的第二个和第三个参数分别是拼接后的字符串的前缀和后缀。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">StringJoiner</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> newElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">prepareBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>newElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> <span class="token function">prepareBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>delimiter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看到了一个熟悉的身影——StringBuilder ，没错，StringJoiner其实就是依赖StringBuilder实现的。
当我们发现StringJoiner其实是通过StringBuilder实现之后，我们大概就可以猜到，他的性能损耗应该和直接使用StringBuilder差不多！</p> <p><strong>为什么需要StringJoiner</strong></p> <p>在了解了StringJoiner的用法和原理后，可能很多读者就会产生一个疑问，明明已经有一个StringBuilder了，
为什么Java 8中还要定义一个StringJoiner呢？到底有什么好处呢？如果读者足够了解Java8的话，或许可以猜出个大概，这肯定和Stream有关。</p> <p>当然，或许在Collector中直接使用StringBuilder似乎也可以实现类似的功能，只不过稍微麻烦一些。所以，Java 8中提供了StringJoiner来丰富Stream的用法。
而且StringJoiner也可以方便的增加前缀和后缀，比如我们希望得到的字符串是[zhuangxiaoyan,zhuangxiaoyanchuang,Java干货]
而不是zhuangxiaoyan,zhuangxiaoyanchuang,Java干货的话，StringJoiner的优势就更加明显了。</p> <p>如果日常开发中中，需要进行字符串拼接，如何选择？</p> <ol><li>如果只是简单的字符串拼接，考虑直接使用&quot;+&quot;即可。</li> <li>如果是在for循环中进行字符串拼接，考虑使用StringBuilder和StringBuffer。</li> <li>如果是通过一个List进行字符串拼接，则考虑使用StringJoiner。</li></ol> <h2 id="valueof和tostring的区别"><a href="#valueof和tostring的区别" class="header-anchor">#</a> valueOf和toString的区别</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> i1 <span class="token operator">=</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
<span class="token class-name">String</span> i2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> i3 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>第三行和第四行没有任何区别，因为String.valueOf(i)也是调用Integer.toString(i)来实现的。
第二行代码其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。</p> <h2 id="switch对string的支持"><a href="#switch对string的支持" class="header-anchor">#</a> switch对String的支持</h2> <p>Java 7中，switch的参数可以是String类型了，这对我们来说是一个很方便的改进。到目前为止switch支持这样几种数据类型：byte short int char String 。
但是，作为一个程序员我们不仅要知道他有多么好用，还要知道它是如何实现的，switch对整型的支持是怎么实现的呢？对字符型是怎么实现的呢？
String类型呢？有一点Java开发经验的人这个时候都会猜测switch对String的支持是使用equals()方法和hashcode()方法。
那么到底是不是这两个方法呢？接下来我们就看一下，switch到底是如何实现的。</p> <p><strong>switch对整型支持的实现</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> switchDemoInt <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//output 5</span>
</code></pre></div><p>反编译后的代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> switchDemoInt
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">switchDemoInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token comment">// '\001'</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

        <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> <span class="token comment">// '\005'</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们发现，反编译后的代码和之前的代码比较除了多了两行注释以外没有任何区别，那么我们就知道，switch对int的判断是直接比较整数的值。</p> <p><strong>switch对字符型支持的实现</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> switchDemoInt <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'a'</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译后的代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> switchDemoChar
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">switchDemoChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token number">97</span><span class="token operator">:</span> <span class="token comment">// 'a'</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">98</span><span class="token operator">:</span> <span class="token comment">// 'b'</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过以上的代码作比较我们发现：对<strong>char类型进行比较的时候，实际上比较的是ascii码，编译器会把char型变量转换成对应的int型变量</strong></p> <p><strong>switch对字符串支持的实现</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> switchDemoString <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;hello&quot;</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;world&quot;</span><span class="token operator">:</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对代码进行反编译：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> switchDemoString
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">switchDemoString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s<span class="token punctuation">;</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">99162322</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">113318802</span><span class="token operator">:</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看到这个代码，你知道原来字符串的<code>switch是通过equals()和hashCode()</code>方法来实现的。记住，<strong>switch中只能使用整型，
比如byte。short，char(ackii码是整型)以及int。还好hashCode()方法返回的是int，而不是long</strong>。通过这个很容易记住hashCode返回的是int这个事实。
仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。
因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个equals方法，
如果你比较的是字符串字面量的话会非常快，比如”abc” ==”abc”。如果你把hashCode()方法的调用也考虑进来了，
那么还会再多一次的调用开销，因为字符串一旦创建了，它就会把哈希值缓存起来。因此如果这个switch语句是用在一个循环里的，
比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里hashCode()方法的调用开销其实不会很大。</p> <p>好，以上就是关于switch对整型、字符型、和字符串型的支持的实现方式，总结一下我们可以发现，
<strong>其实switch只支持一种数据类型，那就是整型，其他数据类型都是转换成整型之后再使用switch的。</strong></p> <h2 id="字符串池"><a href="#字符串池" class="header-anchor">#</a> 字符串池</h2> <p>字符串大家一定都不陌生，他是我们非常常用的一个类。String作为一个Java类，可以通过以下两种方式创建一个字符串：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;zhuangxiaoyan&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;zhuangxiaoyan&quot;</span><span class="token punctuation">)</span>；
</code></pre></div><p>而第一种是我们比较常用的做法，这种形式叫做&quot;字面量&quot;。在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，
用于保存字符串常量，这个内存区域被叫做字符串常量池。当代码中出现双引号形式（字面量）创建字符串对象时，JVM 会先对这个字符串进行检查，
如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。
这种机制，就是字符串驻留或池化。</p> <p><strong>在JDK 7以前的版本中，字符串常量池是放在永久代中的</strong>。因为按照计划，JDK会在后续的版本中通过元空间来代替永久代，所以首先在JDK 7中，将字符串常量池先从永久代中移出，暂时放到了堆内存中。
<strong>在JDK 8中，彻底移除了永久代，使用元空间替代了永久代，于是字符串常量池再次从堆内存移动到永久代中</strong></p> <h2 id="class常量池"><a href="#class常量池" class="header-anchor">#</a> Class常量池</h2> <p>在Java体系中，共用三种常量池。分别是字符串常量池、Class常量池和运行时常量池。</p> <p>有了字节码，无论是哪种平台（如Windows、Linux等），只要安装了虚拟机，都可以直接运行字节码。同样，有了字节码，也解除了Java虚拟机和Java语言之间的耦合。
这话可能很多人不理解，Java虚拟机不就是运行Java语言的么？这种解耦指的是什么？其实，目前Java虚拟机已经可以支持很多除Java语言以外的语言了，
如Groovy、JRuby、Jython、Scala等。之所以可以支持，就是因为这些语言也可以被编译成字节码。而虚拟机并不关心字节码是有哪种语言编译而来的。</p> <p><img src="/zhuangxiaoyan/assets/img/String06.19384388.png" alt="img_1.png"></p> <p>可以看到，上面的文件就是Class文件，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。要想能够读懂上面的字节码，需要了解Class类文件的结构，
读者可以看到，HelloWorld.class文件中的前八个字母是cafe babe，这就是Class文件的魔数（Java中的”魔数”）</p> <p>我们需要知道的是，在Class文件的4个字节的魔数后面的分别是4个字节的Class文件的版本号（第5、6个字节是次版本号，第7、8个字节是主版本号，
我生成的Class文件的版本号是52，这时Java 8对应的版本。也就是说，这个版本的字节码，在JDK 1.8以下的版本中无法运行）在版本号后面的，就是Class常量池入口了。</p> <p>Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，
还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。</p> <p><img src="/zhuangxiaoyan/assets/img/String07.2b951f79.png" alt="img.png"></p> <p>介绍完了什么是Class常量池以及如何查看常量池，那么接下来我们就要深入分析一下，Class常量池中都有哪些内容。
常量池中主要存放两大类常量：<strong>字面量（literal）<strong>和</strong>符号引用（symbolic references）</strong>。</p> <p>说简单点，字面量就是指由字母、数字等构成的字符串或者数值。
字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=123这里的a为左值，123为右值。在这个例子中123就是字面量。</p> <p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * 类和接口的全限定名 * 字段的名称和描述符 * 方法的名称和描述符</p> <p><strong>可以明确的是，Class常量池是Class文件中的资源仓库，其中保存了各种常量。而这些常量都是开发者定义出来，需要在程序的运行期使用的。
Class是用来保存常量的一个媒介场所，并且是一个中间场所。在JVM真的运行时，需要把常量池中的常量加载到内存中。</strong></p> <h2 id="intern方法"><a href="#intern方法" class="header-anchor">#</a> intern方法</h2> <p>在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池。</p> <p>当代码中出现双引号形式（字面量）创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，
则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。</p> <p>除了以上方式之外，还有一种可以在运行期将字符串内容放置到字符串常量池的办法，那就是使用intern。
intern的功能很简单：在每次赋值的时候使用 String 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用。</p> <h2 id="为什么concurrenthashmap中key不允许为null"><a href="#为什么concurrenthashmap中key不允许为null" class="header-anchor">#</a> 为什么ConcurrentHashMap中key不允许为null？</h2> <p>简单来说，就是为了避免在多线程环境下出现歧义问题。所谓歧义问题，就是如果key或者value为null，当我们通过get(key)获取对应的value的时候，
如果返回的结果是null我们没办法判断，它是put(k,v)的时候，value本身为null值，还是这个key本身就不存在。</p> <p>比如在这样一种情况下，线程t1调用containsKey方法判断key是否存在，假设当前这个key不存在，本来应该返回false。
但是在T1线程返回之前，正好有一个T2线程插入了这个key，但是value为null。这就导致原本T1线程返回的结果有可能是true，有可能是false，取决于T1和T2线程的执行顺序。</p> <p><img src="data:image/png;base64,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" alt="img.png"></p> <p>这种现象我们可以认为是线程安全性问题，而ConcurrentHashMap又是一个线程安全的集合，所以自然就不允许key或者value为null。</p> <p>而HashMap中是允许存null的，因为它不需要考虑到线程安全性问题。所以这个问题的核心本质还是ConcurrentHashMap这个并发安全性集合的特性。</p> <h2 id="simpledateformat是线程安全的吗"><a href="#simpledateformat是线程安全的吗" class="header-anchor">#</a> SimpleDateFormat是线程安全的吗?</h2> <p><strong>SimpleDateFormat不是线程安全的</strong>，SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息。
当我们把SimpleDateFormat作为多个线程的共享资源来使用的时候。<strong>意味着多个线程会共享SimpleDateFormat里面的Calendar引用</strong>，
多个线程对于同一个Calendar的操作，会出现数据脏读现象导致一些不可预料的错误。在实际应用中，我认为有4种方法可以解决这个问题。</p> <ol><li>第一种，把SimpleDateFormat定义成局部变量，每个线程调用的时候都创建一个新的实例。</li> <li>第二种，使用ThreadLocal工具，把SimpleDateFormat变成线程私有的。</li> <li>第三种，加同步锁，在同一时刻只允许一个线程操作SimpleDateFormat。</li> <li>第四种，在Java8里面引入了一些线程安全的日期API，比如LocalDateTimer、DateTimeFormatter等。</li></ol> <h2 id="hashmap是怎么解决哈希冲突的"><a href="#hashmap是怎么解决哈希冲突的" class="header-anchor">#</a> HashMap是怎么解决哈希冲突的？</h2> <p>要了解Hash冲突，那首先我们要先了解Hash算法和Hash表。</p> <p><img src="/zhuangxiaoyan/assets/img/hash001.c2e79946.png" alt="img.png"></p> <ol><li>Hash算法，就是把任意长度的输入，通过散列算法，变成固定长度的输出，这个输出结果是散列值。</li> <li>Hash表又叫做“散列表”，它是通过key直接访问在内存存储位置的数据结构，在具体实现上，我们通过hash函数把key映射到表中的某个位置，来获取这个位置的数据，从而加快查找速度。</li></ol> <p>所谓hash冲突，是由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，所以总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。</p> <p><strong>开放定址法</strong>，也称为线性探测法，就是从发生冲突的那个位置开始，按照一定的次序从hash表中找到一个空闲的位置，然后把发生冲突的元素存入到这个空闲位置中。ThreadLocal就用到了线性探测法来解决hash冲突的。</p> <p><img src="/zhuangxiaoyan/assets/img/hash002.50c3772b.png" alt="img.png"></p> <p>在hash表索引1的位置存了一个key=name，当再次添加key=hobby时，hash计算得到的索引也是1，这个就是hash冲突。而开放定址法，就是按顺序向前找到一个空闲的位置来存储冲突的key。</p> <p><strong>链式寻址法</strong>，这是一种非常常见的方法，简单理解就是把存在hash冲突的key，以单向链表的方式来存储，比如HashMap就是采用链式寻址法来实现的。存在冲突的key直接以单向链表的方式进行存储。</p> <p><img src="/zhuangxiaoyan/assets/img/hash003.cdeeadb3.png" alt="img.png"></p> <p><strong>再hash法</strong>，就是当通过某个hash函数计算的key存在冲突时，再用另外一个hash函数对这个key做hash，一直运算直到不再产生冲突。这种方式会增加计算时间，性能影响较大。</p> <p><strong>建立公共溢出区</strong>， 就是把hash表分为基本表和溢出表两个部分，凡事存在冲突的元素，一律放入到溢出表中。</p> <p>HashMap在JDK1.8版本中，<strong>通过链式寻址法+红黑树的方式来解决hash冲突问题</strong>，其中红黑树是为了优化Hash表链表过长导致时间复杂度增加的问题。当链表长度大于8并且hash表的容量大于64的时候，再向链表中添加元素就会触发转化。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/zhuangxiaoyan/interview/juc.html" class="prev">
        JUC面试问题
      </a></span> <span class="next"><a href="/zhuangxiaoyan/interview/jvm.html">
        JVM面试问题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/zhuangxiaoyan/assets/js/app.868ae4fe.js" defer></script><script src="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" defer></script><script src="/zhuangxiaoyan/assets/js/9.7d7583a8.js" defer></script>
  </body>
</html>
