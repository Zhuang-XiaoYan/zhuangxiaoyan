<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>java面试问题 | 庄小焱</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="我是庄小焱，PMP项目管理专家、系统架构设计师(高级)、CSDN博文专家、后端开发工程师。 博主在微服务、虚拟化、系统架构、大数据、机器学习领域不断学习，同时在博客中分享自己学习知识和相关技术， 欢迎大家和我交流学习，欢迎大家关注我的博客。">
    
    <link rel="preload" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css" as="style"><link rel="preload" href="/zhuangxiaoyan/assets/js/app.868ae4fe.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/16.2f5474ed.js" as="script"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/10.f03f824c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/11.8bbceb5f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/12.14f9a7e9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/13.875c4422.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/14.b913d772.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/15.04d0022c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/17.314561f8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/18.4f00aff9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/19.3198a9c6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/20.6ca58bc3.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/21.2b13b489.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/22.1ab1c76c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/23.71e25b05.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/24.ad6ea50e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/25.76e0a373.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/26.b9862941.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/27.aa410472.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/28.03808d20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/29.00bd7baa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/3.08485426.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/30.005c22a8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/31.93f0d38f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/32.340f8c91.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/33.4fd282b8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/34.3a5d80ea.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/35.46a3fd70.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/36.a4d7d4a0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/37.f4563f51.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/38.a4755c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/39.38a44f79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/4.4d57c8c0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/40.7ace36ef.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/41.16f6b68f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/42.6d72579b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/43.c87acddc.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/44.29fd9c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/45.1e066d5b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/46.38a90e06.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/47.d01627f0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/48.a24f2064.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/49.b385ae96.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/5.113b6e17.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/50.36614d52.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/51.0a4de0f4.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/52.f34a7e67.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/53.628cf4ca.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/54.cc220f8a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/55.44be834a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/56.a10f9160.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/57.889877cb.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/58.35998118.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/59.a96ac910.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/6.1a9b2f20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/60.69ed00aa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/61.cd318979.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/62.c1d36d16.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/63.d5921184.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/64.e337ae65.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/65.4754688d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/66.f1e18825.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/67.90234ef8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/68.17c41d12.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/69.d424f938.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/7.713b03d2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/70.dcbc2969.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/71.7dce671a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/72.ca24dbed.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/73.3746d1d5.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/74.b57bc73f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/75.9bcbf8d9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/76.ad9819f6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/77.1939880d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/78.d4fe71a2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/79.95e3a69e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/8.4562fbf2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/80.0c9cbcee.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/81.9f9d8638.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/82.4aeef92d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/83.d69f52f7.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/84.a5ef042c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/85.c37ffab6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/86.6d5b65db.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/87.afa8b536.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/88.1c19772d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/89.5f70dc04.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/9.7d7583a8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/90.2a690c79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/91.4d0be90d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/92.d82b3978.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/93.50ab1b48.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/94.b8bd6e2a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/95.1fc4557e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/96.7063edd6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/97.a7fd9d56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/98.c7605566.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/99.6fe2324c.js">
    <link rel="stylesheet" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zhuangxiaoyan/" class="home-link router-link-active"><!----> <span class="site-name">庄小焱</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>分布式设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/" aria-current="page" class="sidebar-link">场景面试问题总结</a></li><li><a href="/zhuangxiaoyan/interview/distributed-arithmetic.html" class="sidebar-link">分布式原理算法</a></li><li><a href="/zhuangxiaoyan/interview/distributed-id.html" class="sidebar-link">分布式ID原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-lock.html" class="sidebar-link">分布式锁原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-transaction.html" class="sidebar-link">分布式事务原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-throttling.html" class="sidebar-link">分布式限流原理与设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java语言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/java-base.html" aria-current="page" class="active sidebar-link">java面试问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#java基本类型与包装类" class="sidebar-link">java基本类型与包装类</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#包装类和基本类型的区别" class="sidebar-link">包装类和基本类型的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#和equals的区别" class="sidebar-link">==和equals的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#string、stringbuffer、stringbuilder" class="sidebar-link">String、StringBuffer、StringBuilder</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#final与static的区别" class="sidebar-link">final与static的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#final-finally-finalize区别" class="sidebar-link">final finally finalize区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#父子类的加载机制" class="sidebar-link">父子类的加载机制</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#普通类和抽象类区别" class="sidebar-link">普通类和抽象类区别？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#抽象类和接口的区别" class="sidebar-link">抽象类和接口的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#java内部类的对象" class="sidebar-link">JAVA内部类的对象</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#类的实例化创建" class="sidebar-link">类的实例化创建</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#深拷贝和浅拷贝的原理" class="sidebar-link">深拷贝和浅拷贝的原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#线程的状态" class="sidebar-link">线程的状态</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#线程的调度策略" class="sidebar-link">线程的调度策略</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#线程的创建方式" class="sidebar-link">线程的创建方式</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#线程同步的方法" class="sidebar-link">线程同步的方法</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#线程池的种类" class="sidebar-link">线程池的种类</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#五种线程池的使用场景" class="sidebar-link">五种线程池的使用场景</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#程序错误分为三种" class="sidebar-link">程序错误分为三种：</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#内存溢出和内存泄露" class="sidebar-link">内存溢出和内存泄露</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#java内存溢出的情况" class="sidebar-link">Java内存溢出的情况</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#代码导致oom的原因" class="sidebar-link">代码导致OOM的原因：</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#解决oom方法" class="sidebar-link">解决OOM方法：</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#反射机制原理" class="sidebar-link">反射机制原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#获取反射的三种方法" class="sidebar-link">获取反射的三种方法</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#反射机制的应用场景" class="sidebar-link">反射机制的应用场景</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#java的序列化和反序列" class="sidebar-link">Java的序列化和反序列</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#什么是字节码" class="sidebar-link">什么是字节码</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#重载和重写有什么区别" class="sidebar-link">重载和重写有什么区别？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#包装类型的缓存机制了解么" class="sidebar-link">包装类型的缓存机制了解么？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#自动装箱与拆箱吗" class="sidebar-link">自动装箱与拆箱吗？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#什么是可变长参数" class="sidebar-link">什么是可变长参数？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#java-泛型-generics" class="sidebar-link">Java 泛型（Generics）</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#spi机制" class="sidebar-link">SPI机制</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#什么是spi" class="sidebar-link">什么是SPI?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#有哪些常见的io模型" class="sidebar-link">有哪些常见的IO模型</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#过滤器与拦截器原理" class="sidebar-link">过滤器与拦截器原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#javaweb9大对象" class="sidebar-link">Javaweb9大对象</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#javaio类" class="sidebar-link">JavaIO类</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#如何避免sql注入" class="sidebar-link">如何避免sql注入</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#jdk1-8的新特性" class="sidebar-link">JDK1.8的新特性</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#finally块一定会执行吗" class="sidebar-link">finally块一定会执行吗？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#hashmap中的hash方法为什么要右移16位异或" class="sidebar-link">HashMap中的hash方法为什么要右移16位异或？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#thread和runnable的区别" class="sidebar-link">Thread和Runnable的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#什么是守护线程" class="sidebar-link">什么是守护线程</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#对序列化和反序列化的理解" class="sidebar-link">对序列化和反序列化的理解</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#new-string-abc-到底创建了几个对象" class="sidebar-link">new String(&quot;abc&quot;)到底创建了几个对象？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#java-spi是什么" class="sidebar-link">Java SPI是什么？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#new-integer-112-和integer-valueof-112-的区别" class="sidebar-link">new Integer(112)和Integer.valueOf(112)的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/java-base.html#转发与重定向的区别" class="sidebar-link">转发与重定向的区别</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mysql.html" class="sidebar-link">Mysql面试问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-backup.html" class="sidebar-link">数据库与缓存一致性</a></li><li><a href="/zhuangxiaoyan/interview/mysql-cluster.html" class="sidebar-link">Mysql主从问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-slow-query.html" class="sidebar-link">数据查询优化设计</a></li><li><a href="/zhuangxiaoyan/interview/mysql-split-table.html" class="sidebar-link">数据分库分表设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>并发编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/juc.html" class="sidebar-link">JUC面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>源码分析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jdk.html" class="sidebar-link">JDK面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>虚拟机</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jvm.html" class="sidebar-link">JVM面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/network.html" class="sidebar-link">网络面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/os.html" class="sidebar-link">OS面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring.html" class="sidebar-link">spring面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring-Cloud框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring-cloud.html" class="sidebar-link">SpringCloud面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>设计模式</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/pattern.html" class="sidebar-link">设计模式面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Redis中间件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/redis.html" class="sidebar-link">Redis面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Mybatis框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mybatis.html" class="sidebar-link">Mybatis面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>MQ框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mq.html" class="sidebar-link">MQ面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Nginx框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/nginx.html" class="sidebar-link">nginx面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>微服务设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/micro-idempotent.html" class="sidebar-link">幂等性原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-auth.html" class="sidebar-link">认证授权设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-encryption.html" class="sidebar-link">加密算法总结</a></li><li><a href="/zhuangxiaoyan/interview/micro-other.html" class="sidebar-link">综合场景面试问题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java面试问题"><a href="#java面试问题" class="header-anchor">#</a> java面试问题</h1> <h2 id="java基本类型与包装类"><a href="#java基本类型与包装类" class="header-anchor">#</a> java基本类型与包装类</h2> <table><thead><tr><th>基本数据类型</th> <th style="text-align:center;">byte</th> <th style="text-align:right;">boolean</th> <th>char</th> <th>short</th> <th>int</th> <th>float</th> <th>long</th> <th>double</th></tr></thead> <tbody><tr><td>包装类</td> <td style="text-align:center;">Byte</td> <td style="text-align:right;">Boolean</td> <td>Character</td> <td>Short</td> <td>Integer</td> <td>Float</td> <td>Long</td> <td>Double</td></tr></tbody></table> <h2 id="包装类和基本类型的区别"><a href="#包装类和基本类型的区别" class="header-anchor">#</a> 包装类和基本类型的区别</h2> <ul><li>包装类和基本类型:包装类是对象，拥有方法和字段, 对象的调用都是通过引用对象的地址，基本类型不是</li> <li>参数传递:包装类型是引用的传递,基本类型是值的传递</li> <li>声明不同:包装类型需要 new 在堆内存进行 new 来分配内存空间,基本数据类型不需要 new 关键字</li> <li>存储位置不同:包装类型是把对象放在堆中，然后通过对象的引用来调用,基本数据类型直接将值保存在值栈中</li> <li>初始值不同: 包装类型的初始值为 null,int 的初始值为 0、boolean 的初始值为false</li> <li>使用方式不同:包装类型是在集合如 coolection,Map时会使用,基本数据类型直接赋值使用就好.</li></ul> <h2 id="和equals的区别"><a href="#和equals的区别" class="header-anchor">#</a> ==和equals的区别</h2> <table><thead><tr><th>基本数据类型</th> <th style="text-align:center;">基本数据类型</th> <th style="text-align:right;">包装类</th></tr></thead> <tbody><tr><td>==</td> <td style="text-align:center;">比较的值是否相同</td> <td style="text-align:right;">比较地址值否相同</td></tr> <tr><td>equal</td> <td style="text-align:center;">如果没有对equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址；但是String、Date 等类对 equals 方法进行了重写的话，比较的是所指向的对象的内容</td> <td style="text-align:right;"></td></tr></tbody></table> <h2 id="string、stringbuffer、stringbuilder"><a href="#string、stringbuffer、stringbuilder" class="header-anchor">#</a> String、StringBuffer、StringBuilder</h2> <ul><li>都是继承与 AbstractStringBuilder</li> <li>string 定长度的不变效率最小</li> <li>StringBuffer会自动进行扩容工作，扩展为原数组长度的 2 倍加 2。线程安全/效率其次</li> <li>StringBuilder会自动进行扩容工作，扩展为原数组长度的 2 倍加 2。线程不安全/ 效率最高</li></ul> <p>StringBuffer()的初始容量可以容纳 16 个字符，当该对象的实体存放的字符的长度大于16 时，
实体容量就自动增加。StringBuffer 对象可以通过 length()方法获取实体中存放的字符序列长度，
通过 capacity()方法来获取当前实体的实际容量。底层都是一个字符数组的来实现的。
Stringbuffer 中就是比 Stringbuder 多了 synchronize 关键字。</p> <h2 id="final与static的区别"><a href="#final与static的区别" class="header-anchor">#</a> final与static的区别</h2> <table><thead><tr><th style="text-align:center;">final</th> <th style="text-align:center;">static</th></tr></thead> <tbody><tr><td style="text-align:center;">都可以修饰类、方法、成员变量</td> <td style="text-align:center;">都可以修饰类、方法、成员变量。</td></tr> <tr><td style="text-align:center;">都不能用于修饰构造方法。</td> <td style="text-align:center;">都不能用于修饰构造方法</td></tr> <tr><td style="text-align:center;">final 不可以修饰代码块</td> <td style="text-align:center;">static可以修饰类的代码块</td></tr> <tr><td style="text-align:center;">final可以修饰方法内的局部变量</td> <td style="text-align:center;">static不可以修饰方法内的局部变量</td></tr> <tr><td style="text-align:center;">final 修饰表示常量、一旦创建不可改变</td> <td style="text-align:center;">static修饰表示静态或全局，被修饰的属性和方法属于类，可以用类名.静态属性/方法名访问</td></tr> <tr><td style="text-align:center;">final 标记的成员变量必须在声明的同时赋值，或在该类的构造方法中赋值，不可以重新赋值</td> <td style="text-align:center;">static 修饰的代码块表示静态代码块，当 Java 虚拟机（JVM）加载类时，就会执行该代码块,只会被执行一次</td></tr> <tr><td style="text-align:center;">final 方法不能被子类重写</td> <td style="text-align:center;">static 修饰的属性，也就是类变量，是在类加载时被创建并进行初始化，只会被创建一次</td></tr> <tr><td style="text-align:center;">final 类不能被继承，没有子类，final 类中的方法默认是 final的</td> <td style="text-align:center;">static 修饰的变量可以重新赋值。  static 方法不能被重写,static 方法中不能用 this 和 super 关键字</td></tr></tbody></table> <h2 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="header-anchor">#</a> final finally finalize区别</h2> <ul><li>final 可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值.</li> <li>finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码方法,finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用存放一些关闭资源的代码</li> <li>finalize 是一个方法，属于 Object 类的一个方法，而 Object 类是所有类的父类，该方法一般由垃圾回收器来调，
当我们调用 System.gc() 方法的时候，由垃圾回收器调用 finalize()，回收垃圾，一个对象是否可回收的最后判断.</li></ul> <h2 id="父子类的加载机制"><a href="#父子类的加载机制" class="header-anchor">#</a> 父子类的加载机制</h2> <p>静态变量先于静态代码块执行，整个执行顺序是：</p> <ol><li>父类静态变量初始化。</li> <li>父类静态代码块。</li> <li>子类静态变量初始化。</li> <li>子类静态语句块。</li> <li>父类变量初始化。</li> <li>父类代码块。</li> <li>父类构造函数。</li> <li>子类变量初始化。</li> <li>子类语句块。</li> <li>子类构造函数。</li></ol> <h2 id="普通类和抽象类区别"><a href="#普通类和抽象类区别" class="header-anchor">#</a> 普通类和抽象类区别？</h2> <ul><li><p>抽象类 :不能被实例化,有抽象方法，抽象方法只需申明，无需实现，含有抽象方法的类必须申明为抽象类,
抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类,抽象方法不能被声明为静态,
抽象方法不能用 private 修饰,抽象方法不能用 final 修饰</p></li> <li><p>普通类 可以实例化</p></li></ul> <h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="header-anchor">#</a> 抽象类和接口的区别</h2> <ul><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。（单继承多实现方式）</li> <li>接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。实现接口或继承抽象类的普通子类都必须实现这些抽象方法
<strong>接口的特点：</strong></li></ul> <ol><li>只能包含抽象方法，静态方法和默认方法，不能为普通方法提供方法实现（在 JDK1.8 可以使用default 和 static 关键字来修饰接口中定义的普通方法）</li> <li>接口中的成员变量只能是 public static final 类型</li> <li>接口不能包含构造器</li> <li>接口里不能包含初始化块</li></ol> <p><strong>抽象类的特点：</strong></p> <ol><li>完全可以包含普通方法，接口中的普通方法默认为抽象方法</li> <li>抽象类中的成员变量可以是各种类型的</li> <li>抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li> <li>抽象类里完全可以包含初始化块</li></ol> <h2 id="java内部类的对象"><a href="#java内部类的对象" class="header-anchor">#</a> JAVA内部类的对象</h2> <p>Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。
根据定义的方式不同，内部类分为<strong>静态内部类，成员内部类，局部内部类，匿名内部</strong>类四种</p> <p><strong>静态内部类</strong></p> <p>可以访问外部类所有的静态变量和方法，即使是 private 的也一样。静态内部类和一般类一致，
可以定义静态变量、方法，构造方法等。其它类使用静态内部类需要使用“外部类.静态内部类”方式，
如下所示：<code>Out.Inner inner =new Out.Inner();inner.print();</code></p> <p><strong>成员内部类</strong></p> <p>定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变
量（final 修饰的除外）。这是因为成员内部类是非静态的， 类初始化的时候先初始化静态成员，
如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。
局部内部类：定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类</p> <p><strong>匿名内部类</strong></p> <p>要继承一个父类或者实现一个接口、直接使用 new来生成一个对象的引用匿名内部类
我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。
同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用</p> <h2 id="类的实例化创建"><a href="#类的实例化创建" class="header-anchor">#</a> 类的实例化创建</h2> <ol><li>运用反射，调用 java.lang.Class 或 java.lang.reflect.Constructor 类的newInstance() 方法</li> <li>调用对象的 clone() 方法</li> <li>运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject() 方法、不会调用构造函数</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 使用 new 关键字//创建对象方式 1:使用 new 关键字</span>
<span class="token class-name">User</span> u1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//创建对象方式 2:使用反射//发射方式创建对象要求被创建的对象编写空构造</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
<span class="token class-name">User</span> u2 <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> <span class="token operator">|</span> <span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;反射创建失败&quot;</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 使用clone方法创建对象:要求被创建或者被克隆的对象实现 Cloneable 接口,是在内存上对已有对象的影印，所以不会调用构造函数</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> u3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> u1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;u3:&quot;</span><span class="token operator">+</span>u3<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u1<span class="token operator">==</span>u3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;克隆创建失败&quot;</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="深拷贝和浅拷贝的原理"><a href="#深拷贝和浅拷贝的原理" class="header-anchor">#</a> 深拷贝和浅拷贝的原理</h2> <ul><li>浅拷贝:当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li> <li>深拷贝:除了对象本身被复制外，对象所包含的所有成员变量也将复制.</li></ul> <h2 id="线程的状态"><a href="#线程的状态" class="header-anchor">#</a> 线程的状态</h2> <p>Java 中的线程五有种状态分别是：创建、就绪，运行、挂起、结束。</p> <ul><li>运行态：进程实际占用 cpu 的时间的运行时</li> <li>就绪态：可以运行的 但是其他线程在运行而处于就绪态</li> <li>阻塞态：除非某种外部事件发生，否则进程不能运行</li></ul> <table><thead><tr><th style="text-align:left;">进程通信</th> <th style="text-align:center;">线程通信</th></tr></thead> <tbody><tr><td style="text-align:left;">socket通信</td> <td style="text-align:center;">wait/notify 等待</td></tr> <tr><td style="text-align:left;">消息队列</td> <td style="text-align:center;">Volatile 内存共享</td></tr> <tr><td style="text-align:left;">信号量</td> <td style="text-align:center;">CountDownLatch 并发工具</td></tr> <tr><td style="text-align:left;">共享内存</td> <td style="text-align:center;">CyclicBarrier 并发工具</td></tr> <tr><td style="text-align:left;">管道通信</td> <td style="text-align:center;"></td></tr></tbody></table> <h2 id="线程的调度策略"><a href="#线程的调度策略" class="header-anchor">#</a> 线程的调度策略</h2> <p>线程调度器选择优先级最高的线程运行，如果发生以下情况，就会终止线程的运行：</p> <ol><li>线程体中调用了yield方法让出了对cpu的占用权利</li> <li>线程体中调用了sleep方法使线程进入睡眠状态</li> <li>线程由于 IO 操作受到阻塞</li> <li>另外一个更高优先级线程出现</li> <li>在支持时间片的系统中，该线程的时间片用完</li></ol> <h2 id="线程的创建方式"><a href="#线程的创建方式" class="header-anchor">#</a> 线程的创建方式</h2> <ol><li>继承 Thread 类创建线程</li> <li>实现 Runnable 接口创建线程</li> <li>使用 Callable 和 Future 创建线程</li> <li>使用线程池例如用 Executor 框架</li></ol> <h2 id="线程同步的方法"><a href="#线程同步的方法" class="header-anchor">#</a> 线程同步的方法</h2> <ol><li>同步方法，有 synchronized 关键字修饰的方法。 由于 java 的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。
在调用该方法前，需要获得内置锁，否则就处于阻塞状态。synchronized 关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</li> <li>同步代码块：即有 synchronized 关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。
注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用 synchronized 代码块同步关键代码即可。</li> <li>使用局部变量实现线程同步。如果使用 ThreadLocal 管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，
这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li> <li>使用特殊域变量(volatile)实现线程同步
<ul><li>volatile 关键字为域变量的访问提供了一种免锁机制</li> <li>使用 volatile 修饰域相当于告诉虚拟机该域可能会被其他线程更新</li> <li>因此每次使用该域就要重新计算，而不是使用寄存器中的值</li> <li>volatile 不会提供任何原子操作，它也不能用来修饰 final 类型的变量</li></ul></li> <li>在 java 中新增了一个 java.util.concurrent 包来支持同步。ReentrantLock 类是可重入、互斥、实现了 Lock 接口的锁，
它与使用 synchronized 方法和快具有相同的基本行为和语义，并且扩展了其能力。</li> <li>wait 与 notify 关键字的来控制线程的同步。</li> <li>使用阻塞队列实现线程同步，前面 5 种同步方式都是在底层实现的线程同步，</li> <li>使用原子变量实现线程同步。在 java 的 util.concurrent.atomic 包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。</li></ol> <h2 id="线程池的种类"><a href="#线程池的种类" class="header-anchor">#</a> 线程池的种类</h2> <p><strong>newCachedThreadPool缓存线程池底层：</strong></p> <p>返回ThreadPoolExecutor实例,corePoolSize为0,maximumPoolSize为Integer.MAX_VALUE,
keepAliveTime为60L,unit为TimeUnit.SECONDS,workQueue为SynchronousQueue(同步队列)
通俗：当有新任务到来，则插入到 SynchronousQueue 中，由于 SynchronousQueue 是同步队列，
因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；
若池中线程空闲时间超过指定大小，则该线程会被销毁。
<strong>适用：执行很多短期异步的小程序或者负载较轻的服务器</strong></p> <p><strong>newFixedThreadPool固定数量的线程池</strong></p> <p>底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread;
keepAliveTime为0L(不限时),unit为：TimeUnit.MILLISECONDS,WorkQueue为：<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>无解阻塞队列
通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了,如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)
<strong>适用：执行长期的任务，性能好很多</strong></p> <p><strong>newSingleThreadExecutor单个线程的线程池</strong></p> <p>底层：FinalizableDelegatedExecutorService 包 装 的 ThreadPoolExecutor 实例 ，
corePoolSize为1,maximumPoolSize为1,keepAliveTime 为 0L,unit为：TimeUnit.MILLISECONDS；workQueue为：<code>new LinkedBlockingQueue&lt;Runnable&gt;()</code>无解阻塞队列
通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)
<strong>适用：一个任务一个任务执行的场景</strong></p> <p><strong>NewScheduledThreadPool延时缓存线程池</strong></p> <p>底层：创建ScheduledThreadPoolExecutor实例 ， corePoolSize为传递来的参数，maximumPoolSize为 Integer.MAX_VALUE；
keepAliveTime 为 0；unit 为：TimeUnit.NANOSECONDS；workQueue 为：new DelayedWorkQueue()一个按超时时间升序排序的队列
通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周 期性任务执行，如果所有线程均处于繁忙状态，
对于新任务会进入 DelayedWorkQueue 队列中，这是一种按照超时时间排序的队列结构
<strong>适用：周期性执行任务的场景</strong></p> <h2 id="五种线程池的使用场景"><a href="#五种线程池的使用场景" class="header-anchor">#</a> 五种线程池的使用场景</h2> <ul><li>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</li> <li>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</li> <li>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</li> <li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</li> <li>newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu数量的线程来并行执行。</li></ul> <h2 id="程序错误分为三种"><a href="#程序错误分为三种" class="header-anchor">#</a> 程序错误分为三种：</h2> <ul><li>编译错误: 是因为程序没有遵循语法规则。throws用在函数上，后面跟的是异常类，可以跟多个；而throw用在函数内，后面跟的是异常对象。</li> <li>运行时错误: 是因为程序在执行时，运行环境发现了不能执行的操作。（空指针异常、数组越界异常、SQL 异常、非法参数异常、找不到类文件异常等）</li> <li>逻辑错误: 是因为程序没有按照预期的逻辑顺序执行。异常也就是指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制。</li></ul> <h2 id="内存溢出和内存泄露"><a href="#内存溢出和内存泄露" class="header-anchor">#</a> 内存溢出和内存泄露</h2> <ul><li><strong>内存溢出</strong>是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。</li> <li><strong>内存泄露</strong>是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。
Java 中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们new了对象，并保存了其引用，
但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露。</li></ul> <h2 id="java内存溢出的情况"><a href="#java内存溢出的情况" class="header-anchor">#</a> Java内存溢出的情况</h2> <ol><li>Java 堆溢出（对象数量到达最大堆的容量限制后就会产生内存溢出异常）</li> <li>虚拟机栈和本地方法栈溢出。</li> <li>方法区和运行时常量池溢出</li> <li>本机直接内存溢出，DirectMemory 容量可通过-XX: MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值 (-Xmx 指定)一样。</li></ol> <h2 id="代码导致oom的原因"><a href="#代码导致oom的原因" class="header-anchor">#</a> 代码导致OOM的原因：</h2> <ul><li>检查代码中是否有死循环或递归调用。</li> <li>检查是否有大循环重复产生新对象实体。</li> <li>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。
这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li> <li>检查 List、MAP 等集合对象是否有使用完后，未清除的问题。List、MAP 等集合对象会始终存有对对象的引用，使得这些对象不能被 GC 回收。</li></ul> <h2 id="解决oom方法"><a href="#解决oom方法" class="header-anchor">#</a> 解决OOM方法：</h2> <p>增加jvm的内存大小。方法有：</p> <ol><li>在执行某个class文件时候，可以使用java -Xmx256Maa.class 来设置运行aa.class时jvm 所允许占用的最大内存为256M。</li> <li>对tomcat容器，可以在启动时对jvm设置内存限度。对 tomcat，可以在catalina.bat 中添加</li> <li>对resin容器，同样可以在启动时对 JVM 设置内存限度。在 bin 文件夹下创建一个startup.bat 文件，</li> <li>优化程序，释放垃圾。主要包括避免死循环，应该及时释放种资源。</li></ol> <h2 id="反射机制原理"><a href="#反射机制原理" class="header-anchor">#</a> 反射机制原理</h2> <p>JAVA 反射机制是在运行状态中，对于任意一个类，获取任意类的名称、package 信息、所有属性、方法、注解、类型、类加载器、
modifiers（public、static）、父类、现实接口等：对于任意一个对象，都能够调用它的任意一个方法和属性；
这种动态获取类信息以及动态调用对象内容就称为java语言的反射机制。</p> <p>我们知道，要使用一个类，就要先把它加载到虚拟机中，生成一个Class 对象。这个class对象就保存了这个类的一切信息。
反射机制的实现，就是获取这个Class对象，通过class 对象去访问类、对象的元数据以及运行时的数据。
有三种方法获得类的Class对象：<code>Class.forName(String className)、className.class、实例对象.getClass()；</code></p> <p>Java的反射机制：操作的就是这个对象的.class 文件，首先加载相应类的字节码（运行 eclipse的时候，.class 文件的字节码会加载到内存中），
随后解剖（反射 reflect）出字节码中的构造函数、方法以及变量（字段），或者说是取出。</p> <h2 id="获取反射的三种方法"><a href="#获取反射的三种方法" class="header-anchor">#</a> 获取反射的三种方法</h2> <p>通过 new 对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制在JDK中，主要由以下类来实现Java反射机制，除了Class类，一般位于java.lang.reflect 包中
java.lang.reflect 包中
java.lang.Class ：一个类
java.lang.reflect.Field ：类的成员变量(属性)
java.lang.reflect.Method ：类的成员方法
java.lang.reflect.Constructor ：类的构造方法
java.lang.reflect.Array ：提供了静态方法动态创建数组，访问数组的元素</p> <h2 id="反射机制的应用场景"><a href="#反射机制的应用场景" class="header-anchor">#</a> 反射机制的应用场景</h2> <p>例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的Spring／Hibernate等框架也大量使用到了反射机制。</p> <ol><li>我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动</li> <li>Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</li> <li>Spring通过XML配置模式装载Bean的过程：
<ul><li>将程序内所有XML或Properties 配置文件加载入内存中.</li> <li>Java 类里面解析xml或properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息.</li> <li>使用反射机制，根据这个字符串获得某个类的 Class 实例.</li> <li>动态配置实例的属性.</li></ul></li></ol> <h2 id="java的序列化和反序列"><a href="#java的序列化和反序列" class="header-anchor">#</a> Java的序列化和反序列</h2> <p>它是处理对象流的一种机制，即可以很方便的保存内存中 java 对象的状态，同时也为了方便传输。
JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。
比较常用的序列化协议有 <code>Hessian、Kryo、Protobuf、ProtoStuff</code>，这些都是基于二进制的序列化协议。
像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p> <p><strong>序列化和反序列的作用</strong></p> <ol><li>常用于不同进程之间的对象传输，方便传输，速度快，还很安全，被调用方序列化，调用方反序列化即可拿到传输前最原始的java 对象</li> <li>方便存储，不管是存储成文件还是数据库都行，存储为文件，下回要用可以直接反序列拿到对象。</li></ol> <p><strong>为什么要序列化</strong></p> <p>有序在不同的虚拟机中的，我们常常设计到 A 中的程序调用 B 中的程序，这个时候会出现问题的是怎么样A中没有 B 的对象。
需要通过网络传输才能得到 B 的对象，或者内存数据。</p> <p><strong>怎么来解决问题</strong></p> <p>将B中的序列化的数据经过序列化处理，传输到 A 中的，再利用但序列化的操作，生成一个 B 中的对象。并可以实现在A中的程序中的调用B中的方法。</p> <p><strong>实现的方法</strong></p> <p>有java中自带的<code>serializable</code>的接口。利用的<code>protocol buffer</code>的序列化分方式。第三是采用<code>thirft</code>的序列化的方式。</p> <p><strong>序列化的步骤</strong></p> <ol><li>创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：
Object OutputStreamoos=new Object OutputStream(newFileOutputStream(&quot;D:\object.out&quot;));</li> <li>通过对象输出流的 writeObject()方法写对象：
oos.writeObject(new User(&quot;xuliugen&quot;, &quot;123456&quot;, &quot;male&quot;));</li></ol> <p><strong>反序列化的步骤</strong></p> <ol><li>创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流：
Object InputStream ois=new Object InputStream(new FileInputStream(&quot;object.out&quot;));</li> <li>通过对象输出流的 readObject()方法读取对象：
User user = (User) ois.readObject();</li></ol> <p><strong>为什么不推荐使用 JDK 自带的序列化</strong></p> <ul><li>不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。</li> <li>性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li> <li>存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li></ul> <h2 id="什么是字节码"><a href="#什么是字节码" class="header-anchor">#</a> 什么是字节码</h2> <p>在Java中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。
所以，Java 程序运行时相对来说还是高效的（不过，和C++，Rust，Go 等语言还是有一定差距的），
由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p> <img src="/zhuangxiaoyan/interview/java-01.png" alt="java-01"> <p>我们需要格外注意的是.class-&gt;机器码这一步。在这一步JVM类加载器首先加载字节码文件，
然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，<strong>有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，
所以后面引进了JIT（just-in-time compilation）编译器</strong>，而 JIT 属于运行时编译。
<strong>当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来</strong>，下次可以直接使用。
而我们知道，机器码的运行效率肯定是高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语言。</p> <p>:::Tips
HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），
而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，
它的速度就越快。JDK9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，
这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。
:::</p> <p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p> <p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，
而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，如果全部使用 AOT 提前编译，
也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用JIT即时编译器。</p> <ul><li><p>编译型 ：编译型语言 会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，
开发效率比较低。常见的编译性语言有 C、C++、Go、Rust等等。</p></li> <li><p>解释型 ：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，
执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP等等。</p></li></ul> <h2 id="重载和重写有什么区别"><a href="#重载和重写有什么区别" class="header-anchor">#</a> 重载和重写有什么区别？</h2> <p>重载</p> <ul><li>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理。发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li> <li>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</li></ul> <p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p> <ul><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li> <li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li> <li>构造方法无法被重写</li></ul> <h2 id="包装类型的缓存机制了解么"><a href="#包装类型的缓存机制了解么" class="header-anchor">#</a> 包装类型的缓存机制了解么？</h2> <p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。
如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p> <p>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，
Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">// high value may be configured by property</span>
        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Character</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;=</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// must cache</span>
        <span class="token keyword">return</span> <span class="token class-name">CharacterCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CharacterCache</span> <span class="token punctuation">{</span>
   <span class="token keyword">private</span> <span class="token class-name">CharacterCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Character</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">[</span><span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">static</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
         cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>b <span class="token operator">?</span> TRUE <span class="token operator">:</span> FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
</code></pre></div><p>两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 true</span>

<span class="token class-name">Float</span> i11 <span class="token operator">=</span> <span class="token number">333f</span><span class="token punctuation">;</span>
<span class="token class-name">Float</span> i22 <span class="token operator">=</span> <span class="token number">333f</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i11 <span class="token operator">==</span> i22<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 false</span>

<span class="token class-name">Double</span> i3 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>
<span class="token class-name">Double</span> i4 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 false</span>
</code></pre></div><p>记住：所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p> <h2 id="自动装箱与拆箱吗"><a href="#自动装箱与拆箱吗" class="header-anchor">#</a> 自动装箱与拆箱吗？</h2> <p>很多人会有疑问，既然 Java 中为了提高效率，提供了八种基本数据类型，为什么还要提供包装类呢？
这个问题，其实前面已经有了答案，因为 Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。
为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p> <p><strong>拆箱与装箱</strong></p> <p>有了基本数据类型和包装类，肯定有些时候要在他们之间进行转换。比如把一个基本数据类型的 int 转换成一个包装类型的 Integer 对象。
我们认为包装类是对基本类型的包装，所以，把基本数据类型转换成包装类的过程就是打包装，英文对应于 boxing，中文翻译为装箱。
反之，把包装类转换成基本数据类型的过程就是拆包装，英文对应于 unboxing，中文翻译为拆箱。
在 Java SE5 之前，要进行装箱，可以通过以下代码： <code>Integer i = new Integer(10);</code>
在 Java SE5 中，为了减少开发人员的工作，Java 提供了自动拆箱与自动装箱功能。</p> <ul><li>自动装箱: 就是将基本数据类型自动转换成对应的包装类。</li> <li>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">//自动装箱</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> i<span class="token punctuation">;</span>     <span class="token comment">//自动拆箱</span>
</code></pre></div><p>Integer i=10 可以替代 Integer i = new Integer(10);，这就是因为 Java 帮我们提供了自动装箱的功能，不需要开发者手动去 new 一个 Integer 对象。</p> <p><strong>自动装箱与自动拆箱的实现原理</strong></p> <p>既然 Java 提供了自动拆装箱的能力，那么，我们就来看一下，到底是什么原理，Java 是如何实现的自动拆装箱功能。
我们有以下自动拆装箱的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> integer<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//装箱</span>
        <span class="token keyword">int</span> i<span class="token operator">=</span>integer<span class="token punctuation">;</span> <span class="token comment">//拆箱</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>对以上代码进行反编译后可以得到以下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> integer<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i<span class="token operator">=</span>integer<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>从上面反编译后的代码可以看出，int 的自动装箱都是通过 Integer.valueOf() 方法来实现的，Integer 的自动拆箱都是通过 integer.intValue 来实现的。
如果读者感兴趣，可以试着将八种类型都反编译一遍 ，你会发现以下规律：<code>自动装箱都是通过包装类的 valueOf() 方法来实现的.自动拆箱都是通过包装类对象的 xxxValue() 来实现的</code></p> <p><strong>哪些地方会自动拆装箱</strong></p> <ul><li>场景一、将基本数据类型放入集合类</li></ul> <p>我们知道，Java 中的集合类只能接收对象类型，那么以下代码为什么会不报错呢？</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> li <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        li<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>将上面代码进行反编译，可以得到以下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> li <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        li<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>场景二、包装类型和基本类型的大小比较</li></ul> <p>有没有人想过，当我们对 Integer 对象与基本类型进行大小比较的时候，实际上比较的是什么内容呢？看以下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">&quot;等于&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;不等于&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Boolean</span> bool <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bool <span class="token operator">?</span> <span class="token string">&quot;真&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;假&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对以上代码进行反编译，得到以下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">&quot;等于&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;不等于&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Boolean</span> bool <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bool<span class="token punctuation">.</span>booleanValue <span class="token operator">?</span> <span class="token string">&quot;真&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;假&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到，包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。</p> <ul><li>场景三、包装类型的运算</li> <li>场景四、三目运算符的使用</li> <li>场景五、函数参数与返回值</li></ul> <p><strong>自动拆装箱与缓存</strong></p> <p>Java SE 的自动拆装箱还提供了一个和缓存有关的功能，我们先来看以下代码，猜测一下输出结果：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> strings<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">Integer</span> integer1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> integer2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>integer1 <span class="token operator">==</span> integer2<span class="token punctuation">)</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;integer1 == integer2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;integer1 != integer2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Integer</span> integer3 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> integer4 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>integer3 <span class="token operator">==</span> integer4<span class="token punctuation">)</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;integer3 == integer4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;integer3 != integer4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>输出结果<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
        integer1 <span class="token operator">==</span> integer2
        integer3 <span class="token operator">!=</span> integer4
</code></pre></div><p>我们普遍认为上面的两个判断的结果都是 false。虽然比较的值是相等的，但是由于比较的是对象，
而对象的引用不一样，所以会认为两个 if 判断都是 false 的。在 Java 中，== 比较的是对象引用，
而 equals 比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回 false。
奇怪的是，这里两个类似的 if 条件判断返回不同的布尔值。</p> <p><strong>原因就和 Integer 中的缓存机制有关。在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。
整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间 -128 至 +127。只适用于自动装箱。使用构造函数创建对象不适用。</strong></p> <p>我们只需要知道，当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象。
其中的 Javadoc 详细的说明了缓存支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 -XX:AutoBoxCacheMax=size 修改。
实际上这个功能在 Java 5 中引入的时候,范围是固定的 -128 至 +127。后来在 Java 6 中，可以通过 java.lang.Integer.IntegerCache.high 设置最大值。</p> <p>这使我们可以根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128 到 127 范围呢？因为这个范围的数字是最被广泛使用的。
在程序中，第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存。</p> <p>在 Boxing Conversion 部分的 Java 语言规范(JLS)规定如下：如果一个变量 p 的值是：</p> <ul><li>-128 至 127 之间的整数 (§3.10.1)</li> <li>true 和 false 的布尔值 (§3.10.3)</li> <li>\u0000 至 \u007f 之间的字符 (§3.10.4)</li></ul> <p>范围内的时，将 p 包装成 a 和 b 两个对象时，可以直接使用 a == b 判断 a 和 b 的值是否相等。</p> <p><strong>自动拆装箱带来的问题</strong></p> <p>当然，自动拆装箱是一个很好的功能，大大节省了开发人员的精力，不再需要关心到底什么时候需要拆装箱。但是，他也会引入一些问题。</p> <p>包装对象的数值比较，不能简单的使用 ==，虽然 -128 到 127 之间的数字可以，但是这个范围之外还是需要使用 equals 比较。
前面提到，有些场景会进行自动拆装箱，同时也说过，由于自动拆箱，如果包装类对象为 null ，那么自动拆箱时就有可能抛出 NPE。
如果一个 for 循环中有大量拆装箱操作，会浪费很多资源。</p> <h2 id="什么是可变长参数"><a href="#什么是可变长参数" class="header-anchor">#</a> 什么是可变长参数？</h2> <p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。
就比如下面的这个 printVariable 方法就可以接受 0 个或者多个参数。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//......</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token class-name">String</span> arg1<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//......</span>
<span class="token punctuation">}</span>
</code></pre></div><p>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableLengthArgument</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printVariable</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> s <span class="token operator">:</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printVariable</span><span class="token punctuation">(</span><span class="token class-name">String</span> arg1<span class="token punctuation">,</span> <span class="token class-name">String</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arg1 <span class="token operator">+</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printVariable</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printVariable</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
输出
ab
a
b
c
d
</code></pre></div><h2 id="java-泛型-generics"><a href="#java-泛型-generics" class="header-anchor">#</a> Java 泛型（Generics）</h2> <p>Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。
编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code>
这行代码就指明了该 ArrayList 对象只能传入Person对象，如果传入其他类型的对象就会报错。</p> <p><code>ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</code> 并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，<strong>使用泛型后编译器自动转换</strong>。</p> <p>泛型一般有三种使用方式:<strong>泛型类、泛型接口、泛型方法</strong>。</p> <p><strong>泛型类</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span>
<span class="token comment">//在实例化泛型类时，必须指定T的具体类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">T</span> key<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Generic</span><span class="token punctuation">(</span><span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</code></p> <p><strong>泛型接口</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实现泛型接口，指定类型：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GeneratorImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GeneratorImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>泛型方法</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token class-name">E</span> element <span class="token operator">:</span> inputArray <span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> element <span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 创建不同类型数组：Integer, Double 和 Character</span>
<span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stringArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span> intArray  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span> stringArray  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>项目中哪里用到了泛型？</p> <ul><li>自定义接口通用返回结果<code>CommonResult&lt;T&gt;</code>通过参数 T 可根据具体的返回类型动态指定结果的数据类型</li> <li>定义 Excel 处理类<code>ExcelUtil&lt;T&gt;</code>用于动态指定 Excel 导出的数据类型</li> <li>构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）。</li></ul> <h2 id="spi机制"><a href="#spi机制" class="header-anchor">#</a> SPI机制</h2> <p>SPI即<code>ServiceProviderInterface</code>，字面意思就是：“服务提供者的接口”，专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。
SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。
很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p> <p><strong>SPI 和 API 有什么区别</strong></p> <p>说到SPI就不得不说一下API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下:</p> <img src="/zhuangxiaoyan/interview/API-implement.png" alt="API-implement"> <img src="/zhuangxiaoyan/interview/SPI-implement.png" alt="SPI-implement"> <p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p> <p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是API ，这种接口和实现都是放在实现方的。</p> <p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p> <p><strong>SPI 的优缺点？</strong></p> <p>通过 SPI 机制能够大大地提高接口设计的灵活性，</p> <p>但是 SPI 机制也存在一些缺点，</p> <ul><li>比如：需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li> <li>当多个 ServiceLoader 同时 load 时，会有并发问题。# 序列化和反序列化</li></ul> <h2 id="什么是spi"><a href="#什么是spi" class="header-anchor">#</a> 什么是SPI?</h2> <p>SPI全称是Service Provider Interface ，它是JDK内置的一种动态扩展点的实现。简单来说，就是我们可以定义一个标准的接口，然后第三方的库里面可以实现这个接口。
那么，程序在运行的时候，会根据配置信息动态加载第三方实现的类，从而完成功能的动态扩展机制。</p> <p><img src="data:image/png;base64,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" alt="img.png"></p> <p>在Java里面，SPI机制有一个非常典型的实现案例，就是数据库驱动java.jdbc.Driver,JDK里面定义了数据库驱动类Driver，它是一个接口，JDK并没有提供实现。
具体的实现是由第三方数据库厂商来完成的。在程序运行的时候，会根据我们声明的驱动类型，来动态加载对应的扩展实现，从而完成数据库的连接。</p> <p><img src="data:image/png;base64,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" alt="img.png"></p> <p>除此之外，在很多开源框架里面都借鉴了Java SPI的思想，提供了自己的SPI框架，比如Dubbo定义了ExtensionLoader，实现功能的扩展。Spring提供了SpringFactoriesLoader，实现外部功能的集成。</p> <h2 id="有哪些常见的io模型"><a href="#有哪些常见的io模型" class="header-anchor">#</a> 有哪些常见的IO模型</h2> <p>UNIX 系统下， IO 模型一共有 5 种：<code>同步阻塞 I/O</code>、<code>同步非阻塞 I/O</code>、<code>I/O 多路复用</code>、<code>信号驱动 I/O</code> 和<code>异步 I/O</code>。这也是我们经常提到的 5 种 IO 模型。</p> <p>Java 中 3 种常见IO模型</p> <p><strong>BIO 属于同步阻塞IO模型</strong></p> <p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。在客户端连接数量不高的情况下，是没问题的。
但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p> <p><strong>NIO(Non-blocking/NewI/O)</strong></p> <p>Java中的NIO于Java 1.4中引入，对应java.nio包，提供了Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，
不单纯是New。它是支持面向缓冲的，基于通道的I/O操作方法。对于高负载、高并发的（网络）应用，应使用NIO。</p> <p>Java 中的NIO可以看作是I/O多路复用模型。也有很多人认为，Java中的NIO属于同步非阻塞IO模型。</p> <p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。
相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。但是，
这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。这个时候，I/O 多路复用模型 就上场了。</p> <p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。
目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p> <ul><li>select 调用：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li> <li>epoll 调用：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul> <p>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</p> <p><strong>AIO(Asynchronous I/O)</strong></p> <p>AIO 也就是NIO 2。Java7中引入了NIO的改进版 NIO2,它是异步IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
目前来说 AIO的应用还不是很广泛。Netty之前也尝试使用过 AIO，不过又放弃了。这是因为，Nett使用了AIO 之后，在Linux系统上的性能并没有多少提升。</p> <h2 id="过滤器与拦截器原理"><a href="#过滤器与拦截器原理" class="header-anchor">#</a> 过滤器与拦截器原理</h2> <p><strong>Filter基于函数回调</strong></p> <ul><li>它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次.</li> <li>目的：是用来做一些过滤操作，获取我们想要的数据，比如：JavaWeb中对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。</li> <li>场景：修改字符编码(CharacterEncodingFilter)、过滤HttpServletRequest中敏感字符(XSSFilter自定义过滤器)、</li> <li>配置方式：web.xml</li></ul> <p><strong>拦截器</strong></p> <ul><li>基于Java的反射机制，属于面向切面编程(AOP)的一种运用，就是在Service或者一个方法前调用一个方法，或者在方法后调用一个方法，甚至在抛出异常的时候做业务逻辑的操作。</li> <li>由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入(DI)进行一些业务操作，同时一个拦截器实例在一个Controller生命周期之内可以多次调用。</li> <li>但缺点是只能对Controller请求进行拦截，也可以拦截静态资源，必须要添加上配置才可以避免静态资源被拦截，拦截器不能拦截的只有jsp。执行顺序：过滤前-----拦截前-----Action 处理-----拦截后-----过滤后</li> <li>Spring mvc的文件中配置</li></ul> <p><strong>监听器</strong></p> <ul><li>监听器主要用来监听只用。通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。</li> <li>Servlet 的监听器 Listener，它是实现了javax.servlet.ServletContextListener接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。</li> <li>在web.xml中配置</li></ul> <h2 id="javaweb9大对象"><a href="#javaweb9大对象" class="header-anchor">#</a> Javaweb9大对象</h2> <ol><li>request对象:客户端的请求信息被封装在 request 对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。</li> <li>response对象: response 对象包含了响应客户请求的有关信息，但在 JSP 中很少直接用到它。它是HttpServletResponse类的实例。</li> <li>session对象: session 对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。 是HttpSession 类的实例.</li> <li>out对象: out对象是JspWriter类的实例,是向客户端输出内容常用的对象.</li> <li>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例.</li> <li>application 对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；
这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。
服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。</li> <li>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个 JSP 页面要应用此对象，就必须把isErrorPage设为 true，否则无法编译。他实际上是 java.lang.Throwable 的对象</li> <li>pageContext对象,pageContext 对象提供了对 JSP 页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application 的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。</li> <li>config对象: config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</li></ol> <h2 id="javaio类"><a href="#javaio类" class="header-anchor">#</a> JavaIO类</h2> <p><code>InputStream/Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
<code>OutputStream/Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p> <h2 id="如何避免sql注入"><a href="#如何避免sql注入" class="header-anchor">#</a> 如何避免sql注入</h2> <ul><li>严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害</li> <li>校验参数的数据格式是否合法（可以使用正则或特殊字符的判断）</li> <li>对进入数据库的特殊字符进行转义处理，或编码转换</li> <li>预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接</li> <li>发布前，利用工具进行 SQL 注入检测</li> <li>报错信息不要包含 SQL 信息输出到 Web 页面 Spring</li></ul> <h2 id="jdk1-8的新特性"><a href="#jdk1-8的新特性" class="header-anchor">#</a> JDK1.8的新特性</h2> <ul><li>Lambda 表达式</li> <li>函数式接口</li> <li>函数式接口</li> <li>Stream API</li> <li>新时间日期 API：LocalDate 、 LocalTime 、 LocalDateTime</li></ul> <h2 id="finally块一定会执行吗"><a href="#finally块一定会执行吗" class="header-anchor">#</a> finally块一定会执行吗？</h2> <p>finally语句块在两种情况下不会执行：</p> <ul><li>程序没有进入到try语句块因为异常导致程序终止，这个问题主要是开发人员在编写代码的时候，异常捕获的范围不够。</li> <li>在try或者cache语句块中，执行了System.exit(0)语句，导致JVM直接退出</li></ul> <h2 id="hashmap中的hash方法为什么要右移16位异或"><a href="#hashmap中的hash方法为什么要右移16位异或" class="header-anchor">#</a> HashMap中的hash方法为什么要右移16位异或？</h2> <p>之所以要对hashCode无符号右移16位并且异或，核心目的是为了让hash值的散列度更高，尽可能减少hash表的hash冲突，从而提升数据查找的性能。
在HashMap的put方法里面，是通过Key的hash值与数组的长度取模计算得到数组的位置。而在绝大部分的情况下，n的值一般都会小于2^16次方，也就是65536。</p> <p>所以也就意味着i的值，始终是使用hash值的低16位与(n-1)进行取模运算，这个是由与运算符&amp;的特性决定的。
这样就会造成key的散列度不高，导致大量的key集中存储在固定的几个数组位置，很显然会影响到数据查找性能。</p> <p>因此，为了提升key的hash值的散列度，在hash方法里面，做了位移运算。首先使用key的hashCode无符号右移16位，意味着把hashCode的高位移动到了低位。
然后再用hashCode与右移之后的值进行异或运算，就相当于把高位和低位的特征进行和组合。从而降低了hash冲突的概率。</p> <h2 id="thread和runnable的区别"><a href="#thread和runnable的区别" class="header-anchor">#</a> Thread和Runnable的区别</h2> <ol><li><p>Thread是一个类，Runnable是接口，因为在Java语言里面的继承特性，接口可以支持多继承，而类只能单一继承。
所以如果在已经存在继承关系的类里面要实现线程的话，只能实现Runnable接口。</p></li> <li><p>Runnable表示一个线程的顶级接口，Thread类其实是实现了Runnable这个接口，我们在使用的时候都需要实现run方法。</p></li> <li><p>站在面向对象的思想来说，Runnable相当于一个任务，而Thread才是真正处理的线程，
所以我们只需要用Runnable去定义一个具体的任务，然后交给Thread去处理就可以了，这样达到了松耦合的设计目的。</p></li> <li><p>接口表示一种规范或者标准，而实现类表示对这个规范或者标准的实现，所以站在线程的角度来说，Thread才是真正意义上的线程实现。
Runnable表示线程要执行的任务，因此在线程池里面，提交一个任务传递的类型是Runnable。</p></li></ol> <h2 id="什么是守护线程"><a href="#什么是守护线程" class="header-anchor">#</a> 什么是守护线程</h2> <p>守护线程，<strong>它是一种专门为用户线程提供服务的线程，它的生命周期依赖于用户线程</strong>。只有JVM中仍然还存在用户线程正在运行的情况下，守护线程才会有存在的意义。
否则，一旦JVM进程结束，那守护线程也会随之结束。也就是说，守护线程不会阻止JVM的退出。但是用户线程会！</p> <p>守护线程和用户线程的创建方式是完全相同的，我们只需要调用用户线程里面的setDaemon方法并且设置成true，就表示这个线程是守护线程。</p> <p>因为守护线程拥有自己结束自己生命的特性，所以它适合用在一些后台的通用服务场景里面。比如JVM里面的垃圾回收线程，就是典型的使用场景。
这个场景的特殊之处在于，当JVM进程技术的时候，内存回收线程存在的意义也就不存在了。所以不能因为正在进行垃圾回收导致JVM进程无法技术的问题。
但是守护线程不能用在线程池或者一些IO任务的场景里面，因为一旦JVM退出之后，守护线程也会直接退出。就会可能导致任务没有执行完或者资源没有正确释放的问题。</p> <h2 id="对序列化和反序列化的理解"><a href="#对序列化和反序列化的理解" class="header-anchor">#</a> 对序列化和反序列化的理解</h2> <p>我认为，之所以需要序列化，核心目的是为了解决网络通信之间的对象传输问题。也就是说，如何把当前JVM进程里面的一个对象，跨网络传输到另外一个JVM进程里面。
而序列化，就是把内存里面的对象转化为字节流，以便用来实现存储或者传输。反序列化，就是根据从文件或者网络上获取到的对象的字节流，根据字节流里面保存的对象描述信息和状态。重新构建一个新的对象。</p> <p><img src="/zhuangxiaoyan/assets/img/Serialization.16e7ac62.png" alt="img.png"></p> <p>其次呢，序列化的前提是保证通信双方对于对象的可识别性，所以很多时候，我们会把对象先转化为通用的解析格式，比如json、xml等。然后再把他们转化为数据流进行网络传输，从而实现跨平台和跨语言的可识别性。</p> <p>我再补充一下序列化选择。市面上开源的序列化技术非常多，比如Json、Xml、Protobuf、Kyro、hessian等等。那在实际应用里面，哪种序列化最合适，我认为有几个关键因素。</p> <ul><li>序列化之后的数据大小，因为数据大小会影响传输性能</li> <li>序列化的性能，序列化耗时较长会影响业务的性能</li> <li>是否支持跨平台和跨语言</li> <li>技术的成熟度，越成熟的方案使用的公司越多，也就越稳定。</li></ul> <h2 id="new-string-abc-到底创建了几个对象"><a href="#new-string-abc-到底创建了几个对象" class="header-anchor">#</a> new String(&quot;abc&quot;)到底创建了几个对象？</h2> <ol><li>如果 abc 这个字符串常量不存在，则创建两个对象，分别是 abc 这个字符串常量，以及 new String 这个实例对象。</li> <li>如果 abc 这字符串常量存在，则只会创建一个对象</li></ol> <h2 id="java-spi是什么"><a href="#java-spi是什么" class="header-anchor">#</a> Java SPI是什么？</h2> <p>Java SPI，全称是Service Provider Interface。<strong>它是一种基于接口的动态扩展机制，相当于Java里面提供了一套接口。然后第三方可以实现这个接口来完成功能的扩展和实现</strong>。</p> <p>在Java的SDK里面，提供了一个数据库驱动的接口<code>java.sql.Driver</code>。它的作用是提供数据库的访问能力。不过，在Java里面并没有提供实现，因为不同的数据库厂商，
会有不同的语法和实现。所以只能由第三方数据库厂商来实现，比如<code>Oracle是oracle.jdbc.OracleDriver</code>，<code>mysql是com.mysql.jdbc.Driver</code>.
然后在应用开发的时候，根据集成的驱动实现连接到对应数据库。</p> <p><img src="/zhuangxiaoyan/assets/img/java-spi.72a38fcc.png" alt="img.png"></p> <p>Java中SPI机制主要思想是将装配的控制权移到程序之外实现标准和实现的解耦，以及提供动态可插拔的能力，在模块化的设立中，这种思想非常重要。实现Java SPI，需要满足几个基本的格式</p> <ol><li>需要先定义一个接口，作为扩展的标准.</li> <li>在classpath目录下创建<code>META-INF/service</code>文件目录.</li> <li>在这个目录下，以接口的全限定名命名的配置文件， 文件内容是这个接口的实现类.</li> <li>在应用程序里面，使用ServiceLoad，就可以根据接口名称找到classpath所有的扩展时间</li> <li>然后根据上下文场景选择实现类完成功能的调用。</li></ol> <p><img src="/zhuangxiaoyan/assets/img/java-spi02.445f7a57.png" alt="img.png"></p> <p>Java SPI有一定的不足之处，比如，不能根据需求去加载扩展实现，每次都会加载扩展接口的所有实现类并进行实例化，实例化会造成性能开销，并且加载一些不需要用到的实现类，会导致内存资源的浪费。</p> <h2 id="new-integer-112-和integer-valueof-112-的区别"><a href="#new-integer-112-和integer-valueof-112-的区别" class="header-anchor">#</a> new Integer(112)和Integer.valueOf(112)的区别</h2> <ol><li>new Integer，是创建一个Integer对象实例。</li> <li>Integer.valueOf(112)，Integer默认提供了Cache机制，在-128到127区间范围内的数据，通过valueOf方法不需要创建新的对象实例，只需要从缓存中获取即可。</li></ol> <h2 id="转发与重定向的区别"><a href="#转发与重定向的区别" class="header-anchor">#</a> 转发与重定向的区别</h2> <p><strong>地址栏</strong></p> <ol><li>转发：不变，不会显示出转向的地址</li> <li>重定向：会显示转向之后的地址</li></ol> <p><strong>请求</strong></p> <ol><li>转发：一次请求</li> <li>重定向：至少提交了两次请求</li></ol> <p><strong>数据：</strong></p> <ol><li>转发：对request对象的信息不会丢失，因此可以在多个页面交互过程中实现请求数据的共享</li> <li>重定向：request信息将丢失</li></ol> <p><strong>原理：</strong></p> <ol><li>转发：是在服务器内部控制权的转移，是由服务器区请求，客户端并不知道是怎样转移的，因此客户端浏览器的地址不会显示出转向的地址。</li> <li>重定向：是服务器告诉了客户端要转向哪个地址，客户端再自己去请求转向的地址，因此会显示转向后的地址，也可以理解浏览器至少进行了两次的访问请求。</li></ol> <p><strong>转发和重定向的流程</strong></p> <ol><li>重定向的流程: 浏览器发送请求-&gt;服务器运行-&gt;相应请求-------&gt;,返回给浏览器一个新的地址与响应码,浏览器进行判断为重定向,自动发送一个新的请求给服务器，请求地址为刚刚服务器发送给浏览器的地址。-&gt;服务器运行-&gt;相应请求</li> <li>转发的流程:发送请求 --&gt;服务器运行–&gt;进行请求的重新设置，例如通过request.setAttribute(name,value)–&gt;根据转发的地址，获取该地址的网页–&gt;响应请求给浏览器</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/zhuangxiaoyan/interview/distributed-throttling.html" class="prev">
        分布式限流原理与设计
      </a></span> <span class="next"><a href="/zhuangxiaoyan/interview/mysql.html">
        Mysql面试问题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/zhuangxiaoyan/assets/js/app.868ae4fe.js" defer></script><script src="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" defer></script><script src="/zhuangxiaoyan/assets/js/16.2f5474ed.js" defer></script>
  </body>
</html>
