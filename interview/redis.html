<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis面试问题 | 庄小焱</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="我是庄小焱，PMP项目管理专家、系统架构设计师(高级)、CSDN博文专家、后端开发工程师。 博主在微服务、虚拟化、系统架构、大数据、机器学习领域不断学习，同时在博客中分享自己学习知识和相关技术， 欢迎大家和我交流学习，欢迎大家关注我的博客。">
    
    <link rel="preload" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css" as="style"><link rel="preload" href="/zhuangxiaoyan/assets/js/app.868ae4fe.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/4.4d57c8c0.js" as="script"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/10.f03f824c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/11.8bbceb5f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/12.14f9a7e9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/13.875c4422.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/14.b913d772.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/15.04d0022c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/16.2f5474ed.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/17.314561f8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/18.4f00aff9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/19.3198a9c6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/20.6ca58bc3.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/21.2b13b489.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/22.1ab1c76c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/23.71e25b05.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/24.ad6ea50e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/25.76e0a373.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/26.b9862941.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/27.aa410472.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/28.03808d20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/29.00bd7baa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/3.08485426.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/30.005c22a8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/31.93f0d38f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/32.340f8c91.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/33.4fd282b8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/34.3a5d80ea.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/35.46a3fd70.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/36.a4d7d4a0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/37.f4563f51.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/38.a4755c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/39.38a44f79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/40.7ace36ef.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/41.16f6b68f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/42.6d72579b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/43.c87acddc.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/44.29fd9c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/45.1e066d5b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/46.38a90e06.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/47.d01627f0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/48.a24f2064.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/49.b385ae96.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/5.113b6e17.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/50.36614d52.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/51.0a4de0f4.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/52.f34a7e67.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/53.628cf4ca.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/54.cc220f8a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/55.44be834a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/56.a10f9160.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/57.889877cb.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/58.35998118.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/59.a96ac910.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/6.1a9b2f20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/60.69ed00aa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/61.cd318979.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/62.c1d36d16.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/63.d5921184.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/64.e337ae65.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/65.4754688d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/66.f1e18825.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/67.90234ef8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/68.17c41d12.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/69.d424f938.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/7.713b03d2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/70.dcbc2969.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/71.7dce671a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/72.ca24dbed.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/73.3746d1d5.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/74.b57bc73f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/75.9bcbf8d9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/76.ad9819f6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/77.1939880d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/78.d4fe71a2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/79.95e3a69e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/8.4562fbf2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/80.0c9cbcee.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/81.9f9d8638.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/82.4aeef92d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/83.d69f52f7.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/84.a5ef042c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/85.c37ffab6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/86.6d5b65db.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/87.afa8b536.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/88.1c19772d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/89.5f70dc04.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/9.7d7583a8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/90.2a690c79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/91.4d0be90d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/92.d82b3978.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/93.50ab1b48.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/94.b8bd6e2a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/95.1fc4557e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/96.7063edd6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/97.a7fd9d56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/98.c7605566.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/99.6fe2324c.js">
    <link rel="stylesheet" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zhuangxiaoyan/" class="home-link router-link-active"><!----> <span class="site-name">庄小焱</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>分布式设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/" aria-current="page" class="sidebar-link">场景面试问题总结</a></li><li><a href="/zhuangxiaoyan/interview/distributed-arithmetic.html" class="sidebar-link">分布式原理算法</a></li><li><a href="/zhuangxiaoyan/interview/distributed-id.html" class="sidebar-link">分布式ID原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-lock.html" class="sidebar-link">分布式锁原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-transaction.html" class="sidebar-link">分布式事务原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-throttling.html" class="sidebar-link">分布式限流原理与设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java语言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/java-base.html" class="sidebar-link">java面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mysql.html" class="sidebar-link">Mysql面试问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-backup.html" class="sidebar-link">数据库与缓存一致性</a></li><li><a href="/zhuangxiaoyan/interview/mysql-cluster.html" class="sidebar-link">Mysql主从问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-slow-query.html" class="sidebar-link">数据查询优化设计</a></li><li><a href="/zhuangxiaoyan/interview/mysql-split-table.html" class="sidebar-link">数据分库分表设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>并发编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/juc.html" class="sidebar-link">JUC面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>源码分析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jdk.html" class="sidebar-link">JDK面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>虚拟机</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jvm.html" class="sidebar-link">JVM面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/network.html" class="sidebar-link">网络面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/os.html" class="sidebar-link">OS面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring.html" class="sidebar-link">spring面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring-Cloud框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring-cloud.html" class="sidebar-link">SpringCloud面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>设计模式</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/pattern.html" class="sidebar-link">设计模式面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Redis中间件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/redis.html" aria-current="page" class="active sidebar-link">Redis面试问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#谈谈你对redis的理解" class="sidebar-link">谈谈你对Redis的理解？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的为什么快" class="sidebar-link">Redis的为什么快？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的基础数据结构" class="sidebar-link">Redis的基础数据结构</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-string类型原理" class="sidebar-link">Redis string类型原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-list底层原理" class="sidebar-link">Redis-list底层原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-hash底层原理" class="sidebar-link">redis hash底层原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-set底层实现" class="sidebar-link">redis-set底层实现</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-zset底层实现" class="sidebar-link">redis-zset底层实现</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么要设计sds" class="sidebar-link">为什么要设计sds？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么会设计stream-stream用在什么样场景" class="sidebar-link">为什么会设计Stream，Stream用在什么样场景</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#消息id的设计是否考虑了时间回拨的问题" class="sidebar-link">消息ID的设计是否考虑了时间回拨的问题</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-hyperloglog原理" class="sidebar-link">redis-HyperLogLog原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-geohash原理" class="sidebar-link">redis-GeoHash原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的渐进式rehash原理" class="sidebar-link">redis的渐进式rehash原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#skiplist的索引过程-能否越两级搜索" class="sidebar-link">SkipList的索引过程，能否越两级搜索?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#reids的应用场景" class="sidebar-link">reids的应用场景</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#一致性hash算法与hash环数据倾斜问题" class="sidebar-link">一致性Hash算法与Hash环数据倾斜问题</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的哨兵机制的原理" class="sidebar-link">redis的哨兵机制的原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis中分布式集群的数据倾斜问题" class="sidebar-link">Redis中分布式集群的数据倾斜问题</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的缓存失效与解决方案" class="sidebar-link">redis的缓存失效与解决方案</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#布隆过滤器实现原理" class="sidebar-link">布隆过滤器实现原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的脑裂" class="sidebar-link">redis的脑裂</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#主从异步复制导致的数据丢失" class="sidebar-link">主从异步复制导致的数据丢失</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#哨兵集群如何实现自动发现" class="sidebar-link">哨兵集群如何实现自动发现</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis持久化的方式和原理" class="sidebar-link">redis持久化的方式和原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis是单线程还是多线程" class="sidebar-link">redis是单线程还是多线程？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis事务原理" class="sidebar-link">redis事务原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的主从同步策略" class="sidebar-link">redis的主从同步策略？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster数据分片原理" class="sidebar-link">redis-cluster数据分片原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster-gossip通信协议" class="sidebar-link">Redis Cluster Gossip通信协议</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster主节点从节点选举" class="sidebar-link">Redis Cluster主节点从节点选举</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster请求路由方式" class="sidebar-link">Redis Cluster请求路由方式</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster的添加新的节点" class="sidebar-link">redis-cluster的添加新的节点</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster集群的缩容" class="sidebar-link">Redis Cluster集群的缩容</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster集群不可用" class="sidebar-link">Redis Cluster集群不可用</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#缓存预热" class="sidebar-link">缓存预热</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#缓存更新" class="sidebar-link">缓存更新</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis中海量数据查询指定数据" class="sidebar-link">redis中海量数据查询指定数据?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis中-kys与scan的实现原理" class="sidebar-link">redis中 kys与scan的实现原理？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#删除key的命令会阻塞redis吗" class="sidebar-link">删除Key的命令会阻塞Redis吗？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis实现一个延时队列" class="sidebar-link">Redis实现一个延时队列？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis主从复制原理" class="sidebar-link">Redis主从复制原理?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis哨兵机制和集群有什么区别" class="sidebar-link">Redis哨兵机制和集群有什么区别？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis的缓存淘汰策略" class="sidebar-link">Redis的缓存淘汰策略？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#怎么防止缓存击穿的问题" class="sidebar-link">怎么防止缓存击穿的问题？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis存在线程安全问题吗" class="sidebar-link">Redis存在线程安全问题吗？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#单机模式的优缺点" class="sidebar-link">单机模式的优缺点</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#主从架构的优缺点" class="sidebar-link">主从架构的优缺点</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-sentinel哨兵的优缺点" class="sidebar-link">redis-sentinel哨兵的优缺点</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-cluster模式的优缺点" class="sidebar-link">Redis-Cluster模式的优缺点</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis延迟队列的应用场景" class="sidebar-link">Redis延迟队列的应用场景</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis性能优化方案" class="sidebar-link">Redis性能优化方案</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis分布式锁的代码" class="sidebar-link">redis分布式锁的代码</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#什么是bigkey-bigkey的危害是什么" class="sidebar-link">什么是bigkey,bigkey的危害是什么？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis如何解决key冲突" class="sidebar-link">Redis如何解决key冲突?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis集群方案什么情况下会导致整集群不可用" class="sidebar-link">Redis集群方案什么情况下会导致整集群不可用?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis和memcache区别-优缺点对比" class="sidebar-link">Redis和Memcache区别，优缺点对比</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis如何做内存优化" class="sidebar-link">Redis如何做内存优化？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-key-的过期时间和永久有效分别怎么设置" class="sidebar-link">Redis key 的过期时间和永久有效分别怎么设置？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-中的管道有什么用" class="sidebar-link">Redis 中的管道有什么用？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#什么是redis事务" class="sidebar-link">什么是redis事务</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis事务相关命令" class="sidebar-link">Redis事务相关命令</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis事务的三个阶段" class="sidebar-link">Redis事务的三个阶段</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#watch是如何监视实现的呢" class="sidebar-link">watch是如何监视实现的呢</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么-redis-不支持回滚" class="sidebar-link">为什么 Redis 不支持回滚</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis-对-acid的支持性理解" class="sidebar-link">redis 对 ACID的支持性理解</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis事务其他实现" class="sidebar-link">Redis事务其他实现</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis集群的主从复制模型是怎样的" class="sidebar-link">Redis集群的主从复制模型是怎样的?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#全量复制的三个阶段" class="sidebar-link">全量复制的三个阶段?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么会设计增量复制" class="sidebar-link">为什么会设计增量复制?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#增量复制的流程" class="sidebar-link">增量复制的流程?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么不持久化的主服务器自动重启非常危险呢" class="sidebar-link">为什么不持久化的主服务器自动重启非常危险呢?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么主从全量复制使用rdb而不使用aof" class="sidebar-link">为什么主从全量复制使用RDB而不使用AOF?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么还有无磁盘复制模式" class="sidebar-link">为什么还有无磁盘复制模式?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#为什么还会有从库的从库的设计" class="sidebar-link">为什么还会有从库的从库的设计?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis哨兵机制" class="sidebar-link">Redis哨兵机制?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#哨兵实现了什么功能呢" class="sidebar-link">哨兵实现了什么功能呢</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#哨兵集群是通过什么方式组建的" class="sidebar-link">哨兵集群是通过什么方式组建的?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#哨兵是如何监控redis集群的" class="sidebar-link">哨兵是如何监控Redis集群的?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#哨兵如何判断主库已经下线了呢" class="sidebar-link">哨兵如何判断主库已经下线了呢?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#哨兵的选举机制是什么样的" class="sidebar-link">哨兵的选举机制是什么样的?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#新的主库选择出来后-如何进行故障的转移" class="sidebar-link">新的主库选择出来后，如何进行故障的转移?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis集群会有写操作丢失吗-为什么" class="sidebar-link">Redis集群会有写操作丢失吗？为什么？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis并不能保证数据的强一致性-这意味这在实际中集群在特定的条件下可能会丢失写操作。" class="sidebar-link">Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis如何做大量数据插入" class="sidebar-link">Redis如何做大量数据插入？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis2-6开始redis-cli支持一种新的被称之为pipe-mode的新模式用于执行大量数据插入工作。" class="sidebar-link">Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis实现分布式锁实现-什么是-redlock" class="sidebar-link">redis实现分布式锁实现? 什么是 RedLock?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis缓存有哪些问题-如何解决redis和其它数据库一致性问题如何解决" class="sidebar-link">redis缓存有哪些问题，如何解决redis和其它数据库一致性问题如何解决</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/redis.html#redis性能问题有哪些-如何分析定位解决" class="sidebar-link">redis性能问题有哪些，如何分析定位解决</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Mybatis框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mybatis.html" class="sidebar-link">Mybatis面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>MQ框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mq.html" class="sidebar-link">MQ面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Nginx框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/nginx.html" class="sidebar-link">nginx面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>微服务设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/micro-idempotent.html" class="sidebar-link">幂等性原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-auth.html" class="sidebar-link">认证授权设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-encryption.html" class="sidebar-link">加密算法总结</a></li><li><a href="/zhuangxiaoyan/interview/micro-other.html" class="sidebar-link">综合场景面试问题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis面试问题"><a href="#redis面试问题" class="header-anchor">#</a> Redis面试问题</h1> <h2 id="谈谈你对redis的理解"><a href="#谈谈你对redis的理解" class="header-anchor">#</a> 谈谈你对Redis的理解？</h2> <ul><li>Redis是一个基于Key-Value存储结构的Nosql开源内存数据库。</li> <li>它提供了5种常用的数据类型，String、Map、Set、ZSet、List。针对不同的结构，可以解决不同场景的问题。因此它可以覆盖应用开发中大部分的业务场景，比如top10问题、好友关注列表、热点话题等。</li> <li>由于Redis是基于内存存储，并且在数据结构上做了大量的优化所以IO性能比较好，在实际开发中，会把它作为应用与数据库之间的一个分布式缓存组件。</li> <li>并且它又是一个非关系型数据的存储，不存在表之间的关联查询问题，所以它可以很好的提升应用程序的数据IO效率。</li> <li>作为企业级开发来说，它又提供了主从复制+哨兵、以及集群方式实现高可用，在Redis集群里面，通过hash槽的方式实现了数据分片，进一步提升了性能。</li></ul> <h2 id="redis的为什么快"><a href="#redis的为什么快" class="header-anchor">#</a> Redis的为什么快？</h2> <ol><li>Redis是基于内存操作，需要的时候需要我们手动持久化到硬盘中</li> <li>Redis高效数据结构，对数据的操作也比较简单，支持字符串（strings)、列表（lists)、散列(hash)、集合(sets)、有序集合(sorted sets）等。。</li> <li>Redis是单线程模型，从而避开了多线程中上下文频繁切换的操作</li> <li>使用多路I/O复用模型，非阻塞I/O</li></ol> <h2 id="redis的基础数据结构"><a href="#redis的基础数据结构" class="header-anchor">#</a> Redis的基础数据结构</h2> <p>五大基本数据结构:</p> <ol><li>String：是采用的结构体+链表的结构 SDS 这样的一个结构。</li> <li>List：采用的是结构体+双链表</li> <li>Hash：数组+链表的的这样的一种的</li> <li>Set: inset 的结构+hashtable 的这样的这样的一种结构</li> <li>Zset：采用的是跳跃表(skiplist)/ziplist 两种数据结构</li></ol> <p>当存储的信息是不需要修改的情况采用的是的String结构。当对象的某个属性需要频繁修改时，采用的hash结构，如果使用hash类型，则可以针对某个属性单独修改，
没有序列化，也不需要修改整个对象。比如，商品的价格、销量、关注数、评价数等可能经常发生变化的属性，就适合存储在 hash 类型里。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-data.6e06150b.png" alt="img.png"></p> <h2 id="redis-string类型原理"><a href="#redis-string类型原理" class="header-anchor">#</a> Redis string类型原理</h2> <p>String 类型，也就是字符串类型，是Redis中最简单的存储类型。它可以存储字符串、整数或浮点数。</p> <p>在 Redis 中，String 类型的数据结构并不是采用 C 语言中自带的字符串类型，C 语言中的数据结构存在很多问题，比如：<strong>获取字符串长度的需要通过运算、非二进制安全、不可修改</strong>
因此，String 在 Redis 中有其他三种编码方式： <strong>int、embstr、raw</strong> 。其中， <strong>raw 和 embstr 类型，都是基于动态字符串（SDS）实现</strong>的，下面我们先来看看动态字符串的结构是怎样的。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-string01.475456f1.png" alt="img.png"></p> <div class="language-C++ extra-class"><pre class="language-text"><code>struct __attribute__ ((__packed__)) hisdshdr8 {
    uint8_t len;          // 已经保存的字符串字节数，不包含结束标示
    uint8_t alloc;        // 申请的总的字节数，不包含结束标示
    unsigned char flags;  // 不同的 SDS 的头类型，用来控制 SDS 的头大小
    char buf[];           // 真正存储数据 
};
</code></pre></div><p>flags 这个成员变量。在 redis 中其实定义了<strong>5 个SDS结构体（其中 hisdshdr5 已经弃用）如图所示。他们之间的主要区别在于len和alloc 的长度不同</strong>。
在 redis 中，为了尽可能地节省内存空间，当字符串长度在不同的区间时，会选择不同的结构体，
<strong>当字符串长度在 0~255 个字节之间时，会选择 hisdshdr8</strong> ，这样一来，用于表示字符串字节数和申请的总字节数的空间就会被大大节省，以此类推。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-code.7c5ba4fa.png" alt="img_1.png"></p> <p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为 “hello” 的 SDS，假如我们要给这个 SDS 追加一段字符串 ”world” ，这里首先会申请新内存空间：</p> <ol><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1</li> <li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。</li></ol> <p>这种机制称为内存预分配。内存预分配可以减少进行内存重新分配的开销，减少内存碎片，使得 redis 的性能得到提高，空间利用率也得到提高。</p> <p><strong>RAW</strong>： <strong>raw 是 string 的基本编码方式，基于简单动态字符串（SDS）实现，存储上限为512mb</strong>。当一个字符串采用raw的编码方式的时候，它的结构如图所示。</p> <p><img src="/zhuangxiaoyan/assets/img/string-raw.63b5ab12.png" alt="img.png"></p> <p><strong>EMBSTR</strong> ： <strong>如果存储在 SDS 中的数据小于等于 44 字节，则会采用 EMBSTR 编码</strong>，此时 **RedisObject 与 SDS 是一段连续空间。
而不是像 RAW 的编码方式一样，由 ptr 指向另外一片空间，申请内存时只需要调用一次内存分配函数，效率更高。结构如下，</p> <p><img src="/zhuangxiaoyan/assets/img/string-EMBSTR.f284db93.png" alt="img.png"></p> <p>为什么是 44 字节？Redis 默认的内存分配器 jemalloc 分配内存大小的单位是 $2^n$ ，因此，如果分配的空间大小为 2、4 、8 … 字节等 $2^n$ 字节，就不会产生内存碎片。
而 redisObject 和 hisdshdr8 中 len alloc flags三个成员变量加起来刚刚好是 16 + 4 = 20 字节，如果 char[] （数据大小）的大小为 44 字节时，
加起来刚刚好是 64 字节，也即 262^626 不会产生内存碎片。</p> <p><strong>INT</strong> ： <strong>如果存储的字符串是整数值，并且大小在 LONG MAX 范围内，则会采用 INT 编码</strong>，直接将数据保存在 RedisObject 的 ptr 指针位置（刚好8字节)，不再需要SDS了。</p> <p><img src="/zhuangxiaoyan/assets/img/string-int.3a1661c5.png" alt="img.png"></p> <p><strong>String类型使用</strong></p> <ol><li>几乎所有场景都是用String类型来存储数据。</li> <li>使用String类型的incr命令，实现原子递增</li> <li>使用计数器实现手机验证码频率限流。</li> <li>基于登录场景中，保存token信息。</li></ol> <h2 id="redis-list底层原理"><a href="#redis-list底层原理" class="header-anchor">#</a> Redis-list底层原理</h2> <p>list底层有两种数据结构：**链表linkedlist和压缩列表ziplist。<strong>当list元素个数少且元素内容长度不大时，使用ziplist实现，否则使用linkedlist。</strong></p> <p>Redis使用的链表是双向链表。为了方便操作，使用了一个list结构来持有这个链表。如图所示：</p> <p><strong>链表</strong>: Redis使用的链表是双向链表。为了方便操作，使用了一个list结构来持有这个链表。如图所示：</p> <p><img src="/zhuangxiaoyan/assets/img/Redis-list.98669fd0.png" alt="img.png"></p> <div class="language-C++ extra-class"><pre class="language-text"><code>typedef struct list{
    //表头节点
    listNode *head;
    //表尾节点
    listNode *tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void *(*free)(void *ptr);
    //节点值对比函数
    int (*match)(void *ptr,void *key);
}list;
</code></pre></div><p>data存的其实也是一个指针。链表里面的元素是上面介绍的string。因为是双向链表，所以可以很方便地把它当成一个栈或者队列来使用。</p> <p><strong>压缩列表</strong>: 与上面的链表相对应，压缩列表有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，
它允许存储的数据大小不同。每个节点上增加一个length属性来记录这个节点的长度，这样比较方便地得到下一个节点的位置。</p> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmwAAADpCAYAAACZd2tnAAAflklEQVR4Xu3dCXAkV33H8V57kUb3vTp2Je3q2tUtrWzDGhNvgGAMBmJuzBFThpBKcDBQBDAQr0lCwKGCDQWGEIerEsChKAJFgEDFdjjDURjCFUNYAwZzY2MwYIOV/196T/36TY/UPd1zSPp+qt7uzOtjZv7drflNT3dPEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFTOX65eRqPRErYgoNFotMRt9ehRmmkBMtA3oBOr10s7QTPtstXVor7d3KhH2C6+6WRw7qtvli3nBG2trcb07eZGPcJGLaRdNTx88utzczevnnbaiV3fVlau0/8DlGk9sJ3wu3c1DSgIUY/Qo6+9LnjMtdf73bsY60YU9QhRC3HtoUPXXTs+fr3fvxut7WUjsGVAYCtGQImiHiECm491I4p6hKhFQGBzEdiyIrAVI6BEUY8Qgc3HuhFFPULUIiCwuQhsWRHYihFQoqhHiMDmY92Ioh4hahEQ2FwEtqwIbMUIKFHUI0Rg87FuRFGPELUICGwuAltWBLZiBJQo6hEisPlYN6KoR4haBAQ2F4EtKwJbMQJKFPUIEdh8rBtR1CNELQICm4vAlhWBrRgBJYp6hAhsPtaNKOoRohYBgc1FYMuKwFaMgBJFPUIENh/rRhT1CFGLgMDmIrBlRWArRkCJoh4hApuPdSOKeoSoRUBgcxHYsiKwFSOgRFGPEIHNx7oRRT1C1CIgsLkIbFkR2IoRUKKoR4jA5mPdiKIeIWoRENhcBLasCGzFCChR1CNEYPOxbkRRjxC1CAhsLgJbVgS2YgSUKOoRIrD5WDeiqEeIWgQENheBLSsCWzECShT1CBHYfKwbUdQjRC0CApuLwJZVToGtvb39wUePHtUNdMC97Y+3LVQpoORVp5aWlvmFhYUfyc1CXvOMqFI9VN2vRzsvsDVIO9XvTKFq68Y2QT1C1CKofGCrxt/JvB6DwJZVnQe2xsbGcf3P76+oKgWUUnUq8zX36T+l5plJleqhKrUe5aaGga3M9aKIzmffvn1/OjY29t6lpaU7gmz1rdq64cqrFmJgZGTkTfqBZ3l5+dcTExMfampqOuCPlEJN6lGnql6LvNYL+7dH1of/KDUsSLjdENhCBLas6jiwtbS0PCCP+aRWpYASV6esrzlunplVqR6qEutRrmoU2LKuFy6dz+zs7DcmJyc/nMM8q7ZuWHnWYmBg4LLh4eHXNjc3n97W1nbWzMzM16ampv7LHy+FqtejjlW1FnmuF/Zvj4T433R2dj4ibliQ8HEIbCECW1Z1HNjymk9qVQooca8vri+NrNPHqlI9VCXWo1zVKLAlrMUevyNOoVA4pP8nnOdWqrZuWAmfd6JaiJ7InZ6eC82829z+FKpejzpW1VrkuV7YeY2Ojl4jH27+L3D22iV8nA0EthCBLasUgU0XmN/m5+e/q8Pi3mjlU+vK+Pj4vy0tLf1yYWHhhwcOHLgiWD9eZkA+ufxW/zi685dPuq86cuTI5/S2/zhm3tZemdcr9GsMmfcvDh069E7p67QD9fFlPp/WT0eLi4s/279//yudabeWY0DxX0OpmpUa185H9wBMTEx8QF7Pbfq6Dh8+/Ak9ds2fjz/PXORYD+W/xlI1iXktJZe7Hbetre1+U1NTH9Wvt6anp78oNVo00+ajvMCW6Xn7tbLrhZ22q6vrYbrHTKb7fJBg27Ji6luOtOtGXdbC6u7ufozM5x652eIPSyhtPXayNLWoq/XCTtfY2Dgpf5tu7e/vv9SOl3a7ySOw+a9NW9zfTDN6plqKPfJ6Xzg3N/ctHa57nPv6+p6Z5jWXskpgyyhFYJOVd8K2zs7OR8oCvKejo+NBOizujVY3DtkontLQ0DDT29v7xxI2fiXh6W90fAkfH9RjaJzZ75EV8DuyojzLPpb88Xyqzqepqek+et+OKCvjlbLx3dTa2npchh2bmZn58sGDB/9ZhxUKhYOykt2l4VAed1a/5pDn8Ed22kRyDChJa2bHLfWaBwYG/kI3Ig3BMuze+odFNzR/Pv48c5FjPVTSmvivZbPlbseVPy4fk+H3l+V+po4rdfps+Mg5KCOwZX3epdYLZ9ob9A+wrBvL2r/VtmX59S1TqnWjXmthjYyMvFk+DH3c708hVT12uMS1qLf1wt025P3jyRp8ZL77/WHO9CXlEdiS/s3U+1lrOTg4+FfyXv1zrae8h07L/xdJ+PtJmtdcCoEtqxSBzXGK7sGSTySvsR1xb7TyqeYCZ5pAwtrLdMHLzT0y7Ika4OR2qw6TFee+ErTulpv77Pj+imh06h4mXdlsh4ZC/SQgN/fqfMxGe8yZJp2cA4qxac0264sj9XuCGa89rvZ625ukfJWph9q0Jt5r2XS523Hl/3PtcPmQ8Az9wyY3m21fZukDWy7PO2652j7dK2T7VJJtS8XNswxp1o26rYUZdpZ+2NM3dn9YCmnqsdMlrUXdrRfevPZoiPdDjxm2pTwCm2PTv5lB9lq2Sji9s6+v78/scDUwMPC8NK+5FAJbVmUENv0UIqn9q3Kzyfa5K4297Z9tJZ8MHm7G6ZbWrGeoyYb0WB0mnwquGh8ff787ftyGoX9MtU9XQKfdZcbTMyVPnZyc/Ih+DSufll9vP1GlUoGAslXNNusz9g0NDZ3QT4b6iUg3Sr/e/m1v+vJVoB5qq5q4t7da7nZcWd5DzrzONcP7bV9mKQNbXs87brnavkKhMGr7jC23LRU3zzIkXjfquRbyt2pYv/oaHBx8sT8spcT12AUS1aIe1wt/XvLYR+U5/VaDnT9sK3kGtq3+Zmatpe5x09uNjY2Tdrg3TqLXXAqBLauUgU1W/BH5ZPJTWeCnuf3uSuPcHnTHkU81jzf9ayubfGJ5y6FDh94RrO+OvkU2nse548dtGLqbV/v0E0RDQ8MRtwXO9aR02rGxsXfLuL+ToPNy259IzgElSc026xNNEtJO6iUHZIM6TzamwxJ+z4+p97YJbElq4t7earnHve64vsxSBra8nnfSPmurbUttNn0KideNOq5Fp7wJfkk+4L3R6y9H4nrsAolqUY/rRdx0ugNAD0WRYQ/xh20mr8CW5G9m1lrqdHpbDy2yw5UeA+hPVw4CW1YpA5uEhvcNDAy8xO93F7q93dHR8QfuOHp8yPT09Bfs/ZaWlgfqd+V6Orb8f3vgfGpQMp9zdD7enrpB6bvHfjLaSl9f38U6fpDmIOKcA0qSmjl9Ra9ZNqKztc/91COftJ7t19u/bcfNLOd6qCQ18V7Lpss97nXH9WWWMrAFOT3vuPUibjxrq21LbTZ9CmnWjXqsRcPk5OR18uHuXUG2Cwhbaeqx0yWtRd2tFyWm69FDeiTkvTNmWEl5BbYkfzODjLXU2ult/Ro1nGrtcKZX+tOVg8CWVYrApiuBfh2ne3jcgyB1mLvQ7W351PoVTeaS7mf1qwbp+513LMEp+slGT07Q06ed/jWyIS3ofGQlfb4eSGr7x8fH36NnyOj1cRrWT2h4mj1YVMfT8fWrUD3zRf4Qv13G/V6Q5o9xjgElac3s+HGvWafVPj2YVGspNX3S3NzcN/16+7ftPDPLsR4qaU3817LZcvfHLdWXWfrAlsvzjlsv4sZzlNy2bL27Yw7SLkOqdaPeanHw4MF/0ZN39Ll462LyvxdRqeqRB93zYi7wurfUbW+Saklci3pbL0pNpxeclv574oaVkkdgS/o3U+9nraVe2UHPMNX3ap1eXvNzZH7f8acrB4EtqxSBTRbarbrQ/KbD3IVub+sKc+TIkRuXl5d/oxek1KDhzVKPHbhCx9Vduf4wNTIycrUeHGpCl9UhG9jb9NORDtNLXOh37zpAVrBpeczP6IGTemaP/sHyTlneWo4BJWnN3GniXrPuUZON6Afarxuknrnk19u/vTHDrHKsh0pak5jXUnK5x4wb25dZGYEtyOl5++tFqfGsUtuWX3e3/mVIO912qUXsfBJIW4/M9E1V31DlZqHUbW+SaklTi7paLzaZ7lR9TysxLFYegS3p30wzetZautPfrredw5kSveZSVglsGaUIbJUgQeSSubm5m+VmogsaVkXOAWXbox6h8gJbTVRp29oW60aVaqG2RT2qpO5rUY31Io/AtlMQ2LKqcWDTg32HhoZe6vfXFAElinqEtlFgq9K2tS3WjSrVQm2LelRJ3deiGusFgS1EYMuqRoFNjzGQDeXyxcXF24I8L7uQBwJKFPUIbYPAVuVtq67XjSrXQtV1PaqsbmtRzfWCwBYisGVVo8Cm363rpSr0NGJ/WM0RUKKoR2gbBLYqb1t1vW5UuRaqrutRZXVbi2quFwS2EIEtqxoFtrpGQImiHqFtENiqjHUjinqEqEVAYHMR2LIisBUjoERRjxCBzce6EUU9QtQiILC5CGxZEdiKEVCiqEeIwOZj3YiiHiFqERDYXAS2rAhsxQgoUdQjRGDzsW5EUY8QtQgIbC4CW1YEtmIElCjqESKw+Vg3oqhHiFoEBDYXgS0rAlsxAkoU9QgR2HysG1HUI0QtAgKbi8CWFYGtGAElinqECGw+1o0o6hGiFgGBzUVgy4rAVoyAEkU9QgQ2H+tGFPUIUYuAwOYisGVFYCtGQImiHiECm491I4p6hKhFQGBzEdiyIrAVI6BEUY8Qgc3HuhFFPULUIiCwuQhsWRHYihFQoqhHiMDmY92Ioh4hahEQ2FwEtqwIbMUIKFHUI0Rg87FuRFGPELUICGwuAltWBLZiBJQo6hEisPlYN6KoR4haBAQ2F4EtKw1sl61et/Y/bb1pQPH7dnOjHmG7+KaTwbmvPilbzmW0tbYa07eb22pM325tqzF9u65dNTx88qbZ2ZNrYWW3t5WV6whsWekeNhqNlqwFAY1GoyVuGlJo6y0AAAAAAAAAAAAAAAAAdpClpaUztfn9AAAAqA97jh49uqpNb/sDAQAAUGPHjh1rsoHt+PHjBX84AAAAamxlZaXXBrYzzjijxx8OAACAGltaWjpoA5ve9ocDAACgxk477bTjNrAtLy+f7Q8HAABAjUlQe7oNbCsrK0/zhwMAAKDGJKRd7QS2q/3hAAAAqC29pMe3bWCT9i3t80cCAABAjegxayaofVzaJ8xxbL/njwcAAIDa0L1rN5ivQi/QZsLbDTrMHxkAAABVJgHtJSagfVrunqJNbn/G7GV7sT8+AAAAqmRmZqZVQtmVJqz9bHFxcdYO09vaZ4ZdqeO60wIAgF1iZWWlWcLAhPx/b70GGK3yTep93vLy8kXy/zXSfmwC2W2yDM7yl4/030+HmXF03GvMtOf586VVpum2YbaRZn/5AABQMfPz813yBnSptE9Ju9uEAVqNmgSB9ywuLu73l5Olw3Qcfzpa1ZtuK7rNXKrbkL+cAADIjbzZXCjtDudN6E5pX5H2SWnX06rS3ift9dIuOf3004f9ZVSKjqvTmGl1Hv58aZVpum3oNqLbit1udBu60F9GAABktry8fLl5s7lbbr9Rv+qRdi9/PADFdFvRbUa3Hd2GdFvSbcofDwCAssmby/kmrP14aWnpTH84gOR0G9JtyWxT5/vDAQBI7fjx43tXVla+ad5czvGHA0hPtyXdpnTb0m3MHw4AQCrLy8uPMl/fXOcPA1C+o+vHuOkHoUf6wwAASGUl/EHxp/vDAJRPtynzYeh1/jAAAFKRN5QbTWBb8IcBKJ9uU2bbutEfBgBAKvJm8gN9Uzl27Fi3PwxA+c4444wes4ft+/4wAABSkTeUD0u7ngOjgXzppT5029JtzB8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPVv9UTw39JWaTRa3bQ7pJ3nb6sAgF0s5s2CRqPVvn3W31YBALuYfYPw+7H9sBy3P1mGJ8w2ecIfBgDYxQhsOwfLcfsjsAEAYhHYdg6W4/ZHYAMAxCKw7Rwsx+2PwAYAiLXDA9spfoc41e/YKXbwctw1CGwAgFjVCGxdXV1P8vuSamxsnBocHHyx3Gzxh21lYmLiA4VCYcTtGxsbe/vQ0NDL3b68NTQ0HJH/Ov3+Sqv0ckTlEdgAALGqEdiOHj3qzr9lcXHxtlLNGW+NhK4PSf/P9+/f/zLbt7y8/Fu3zc/P3+JOY3V3d1/khrPOzs4/lHG/54e4PLW1tZ2nr3dgYOD5/rBKq/RyROUR2AAAsWoQ2Fq9+1ZRf19f38UzMzNfkYA1Ojc3920NQ9pvxtvYg3XgwIEr9f+urq4nLi0t/cJpv5R2p9snAe8ub5xf2PlkpUFwYWHhh/J8rpCQeXtzc/OKP04lVXo5ovIIbACAWJUMbBJefqxNA5a93djYOOkHMyMS2HRvmO5xk9BzmtxtaWpqus/8/Px35faAG9ja29vPlYD0d3a6GurXcDk6OnrN2p3+/kvk+d6qX+n6I1ZKpZYjqofABgCIVcnAplpaWubT7mHr6el5su4dkzD2YAljVw0PD79G+/ft2/fckZGRq53Adur09PQXZbyHujPaQqv5/159fX3PDHI4CUFD6Ozs7E1jY2Pvlbv3sv3y3F+he9xaW1vPdkavmEouR1QHgQ0AEKvSgW1wcPCv4wLb/Pz8990mweYHdjz9arOzs/PherupqemAfm3Z3Ny8LHf3SOu3ga23t/dPzO2ecPZBwd2jZ/fwab8ONLc1tNmAuNZfLnmuF+jXn6Ojo28NTFjr7+9/gfzXbW6/UL+GlaD56iD6PHNXyeWI6iCwAQBiVTiwFfTYMw1GesamhLDzgwR72HwSih4m/7Xb+zawFQqFsSNHjtwo8/53ub/XDF4LbHZctVVgkzD1er2dto2Pj79fwtivJZQ9y388c6bompaWlgfOzs6e1OCpe+PccfNUweWIKiGwAQBiVTKwDQwMPE8vo2EDjIS3b7a3tz/EBCVfJLD54ci21tbW42Y8e9JBx/T09P+YS3+ocvaw9evzS9uGhoYul/9nzeNu8AOb0aR7Dr2+XFVqOaJ6CGwAgFgVDGwdejmOlpaWJSeI6V4w+5XoLV77rhfkdNyN1tHR8Shz+Y52L7AFMuxBuifP3E29h80dNw8lAlvFVWg5oooIbACAWBUMbHpZjj/X/70AVeqrT7+/bXBw8EXB+kkBbRLWvtPZ2fkIHeAHNj2TdHl5+Tfmbjl72HJFYKsfvb29TwvWl3cqPT09TykUCgf9/kojsAEAYlUysFllBramw4cPf2J0dPQfh4eHXzs2NvavdoCO19XV9YT+/v5n67Xajhw58jlzHJtiD1uF6Fm7+tr8pntR/XE309jYOK7/+f2VoM+vnOClZycfPHjwLX5/pRHYAACx6jiwqZ6ZmZmv6SU+5PaA7dTxOjo6Hj05OfkRbXr5DOnuMoM3DWx61mmwfrYpgS0lG9j0mngSuiZsk0EN/rilSLh7gKn7xvLM0VoQd5tZFjN+f7C+Dqi16/r5v55RqlXwua8hsAEAYtUqsPk/SaXND1pK98bo15q9vb1Pt31mvFK/1ekGtiZpneb+2iU39CQBbd3d3Y/Ry20E8T8Qn8lOD2xBhsCScB42TKWi803aTHBX9kLMVpO77FpbW+cC53dsEzz3TAhsAIBY1QhseukL527cnjRVqn/tGLXAuYbZoUOH3qHd4RgRG4FNL7fh/vqA0uvC6cVs9QQG58zSXOnj77bAZoe1tbXdb2pq6qO6zPWixi0tLYt2HD802eVkp9XLt8zOzn5Dpvu8dA/oHq2enp4L7fRqeHj4VfoVuNtneUFM9ZjHaHP6/PEK8riP1xvm8b8+MjLyhsBcUFmvn6fri1lX2szPo1Xs61wCGwAgVjUCG6qj0ssxSWCTsPax1tbW+0uwOVN//UHC1WftOPr1aXd391NNYFr7WtWb9gYNfOYiycHExMQHza9HWHv05BP/uneWH9hkPqfrnlt3HOWPpyFMj5fUsKg/iSZdvRo2zXGTp2jo1GMkJbj9SC/WHM4pfwQ2AEAsAtvOUenlaIOV7j2zTULO/7rD9Ldd7fgSbp4hffcEzt7QuNBn+/Rratun9Lp1Erh+Fawfc6bB6r7ymHfLzX3ueJYfxCTYXSrT/9R8rVlyvIGBgcvMGc0NumdU98rqSQcS0t5nAuPa3l15nufYvXGVQmADAMQisO0clV6OzteeZ9mLB5szPjeGNTc3Dznjn2vCWb8/jyAmsBUKhVHbZzQvLS3dIUHusXpHQ5T+uoQ3zgYviPXoz52Njo6+Tf7/if7aRInxrFN075leO3D//v0vM30NIyMjb9avRM3lQRKfXFEuAhsAIBaBbeeo9HKMC1ubDcvSZ+mlNcwxi/p16C0S3h7nj2M5Qax7amrqk5OTkx+W23v0jGL9WTAb/PzApsFSv7rVsObv5VM9PT1P1hNf9PE1zEn4m/fHyQuBDQAQa7cEtkKhcCimT/folLysh+5dCcLLhcQpOa1nn3iu35m3Si/HzYJV3LASfefEBKai8SzdM2Z+MeMB8v/twfqZv7F0HnqSgv5uqx6TFjjLTkObnhWsgcx9fD2ZQC8bY39Czb+Mh3s5j6Ghob+dmZn5ks5r40FzRmADAMTKO7DZN1+/1fLiqg0NDdPmWKjIpUCmp6e/IG/gF7l9Lj9YuMxelx81Nzev+MNidOi4nZ2dj/QH5CnP5RjHLtuY67B1xIWuuD5ZDxa0b2Bg4Pk6n1LjOU7RPVt65qh7tm8cnYcG4+Hh4b8PYsJ0V1fXBfp8veWqZ5DqMXL+5T0iNnl+uSKwAQBiVSqwxbypJz7+J++Lq+qekZGRkTe5ffq11vL6z1npY+ibu20b1wCLC2xy/9562Qo9Pkp/bcEdZvTqdPoVXKmmB+u79wuFwpg/k3LkuRzjlArjfX19z4wLXXF9SpbF1RqgJYh9b7PxrAMHDlyhw1tbW4/7w1xxyytOifEIbACA+lWpwBZkeHNLOI8kF1ddexP2m/YPDw+/Tm7/zv/ay91j5ryx75Xn9FD9VQUNWOag9PaNR4laC2z2jrkd+S3LuL485Lkc60l/f/8lc3NzNwdbLPMSQWyNXppDvwLXy42Y+vtfdW/6iwcJ1sdcENgAALGqGdjssCpeXNXuNdnYg6b3NZRp8NJfPHCn070+7iUgTAAY1sfSr+X08g+BcwHfEtYCm+51kmm+r7d1b5zets3v82dQrjyXYz3R48aGhoZe6vf7zPKKDWx6+REZfo+sL3eNjo7+kz9c9G22LMywPr8/bwQ2AECsWgS2Kl5ctehrLr2ve8gk1L0mMFezt+TN/G55vMnA+R1KuT9lQpzuUfN/j9Jt9ieu2MOWE13+EtQuNxe/3bg0SCnmR94jy3S7IbABAGJVKrDp3jPbanhx1djApv0aGCUofioIH3ePDpM3/RH9P21z9swVBba5ublv6Vd6tpnhBLYt6HLVMz51WfnDdioCGwAgVqUCW51cXLXouCR3vmNjY+/SFqwfG9VohmnQ26vNeby9enajXv7B3o9p1qAJjGvkubwn8M5YNI9ZdBZjVnkuR9QGgQ0AEKtSgS3Y5CtRd1iWPmuTi6uW3MNm7rbrHhzdy6e3zbCNHwrX++4xUaOjo2/V35QMwq8/i+hxcXqRVf3a1T1uLabd6k+bVZ7LEbVBYAMAxKrTwJbXxVW3Cmz2em96yZF+M2xjb5n/HES3BryRkZE3BCVCW2dn58PNCQ867ynzld7v2+Hap79V2d/f/+xwqnzkuRxRGwQ2AECsSgW2mOuw1eLiqlsGNkuf4/L6ddk2eIGtv6GhYUZPStCTGvRnj/QMUnd8deDAgVdIoPsHe7+5ufmoHsOm/YODgy/SaTs6Oh7lTpOXPJcjaoPABgCIVanA5rcaXVy15HXYnHHWdHV1PUlDn9O1dhKCXkZEQ6A+F/MD4GpwamrqP5eWlu7US4hIiDts+hsknH1bp7Ez0ZAnr+WN9hi6sbGxd7evn3TRYcfJS57LEbVBYAMAxMo7sNVKiYur2j1sGycHuIFtZmbmq7Ozs1+X/7+sJwrIPF5gJ9Rrtem4et0u/U3RmB/83qM/daTz0HH0LFE9Fk7uf02n1ePd9OvQhYWFH+qJELoHT/fWyWO8UH+YXKfRPW/mB8pLXYQ3lZ2wHHc7AhsAINZOCWwlLq7a4P+ckZ61Gphrdel1u/QrSwlSZ8R8vdmkv4Zgru21mT32LFjRaq4P17Jv377nmK9zY491Ey0y/Jgef+cPKNdOWI67HYENABBruwe2tBdX3cm283LEOgIbACDWdg9su/HiqqVs5+WIdQQ2AECs7R7YEGI5bn8ENgBALBvYzBsFbXs3luP2bxvbo7+tAgB2MXljuNt5k6DRaPXQLg9e5G+rAIBdTN4cHrha/CmfRqPVql0ePFf+7/a3VQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGDn+H/ka/LkVz98fwAAAABJRU5ErkJggg==" alt="img.png"></p> <ol><li>zlbytes：列表的总长度</li> <li>zltail：指向最末元素</li> <li>zllen：元素的个数</li> <li>entry：元素的内容，里面记录了前一个Entry的长度，用于方便双向遍历</li> <li>zlend：恒为0xFF，作为ziplist的定界符</li></ol> <p>压缩列表不只是list的底层实现，也是hash的底层实现之一。当hash的元素个数少且内容长度不大时，使用压缩列表来实现。</p> <p><strong>list实际使用场景</strong></p> <ol><li>消息队列：列表类型可以使用 rpush 实现先进先出的功能，同时又可以使用 lpop 轻松的弹出（查询并删除）第一个元素，所以列表类型可以用来实现消息队列，</li> <li>在发红包的场景中，假设发一个10元，10个红包，需要保证抢红包的人不会多抢到，也不会少抢到。</li></ol> <h2 id="redis-hash底层原理"><a href="#redis-hash底层原理" class="header-anchor">#</a> redis hash底层原理</h2> <p><strong>hash底层有两种实现：压缩列表和字典（dict）</strong>。压缩列表刚刚上面已经介绍过了，下面主要介绍一下字典的数据结构。</p> <p><strong>字典</strong>： 字典其实就类似于Java语言中的Map,Python语言中的dict。与Java中的HashMap类似，
<strong>Redis底层也是使用的散列表作为字典的实现，解决hash冲突使用的是链表法</strong>。Redis同样使用了一个数据结构来持有这个散列表：</p> <p><img src="/zhuangxiaoyan/assets/img/redis-hash01.2b8909b9.png" alt="img.png"></p> <p>在键增加或减少时，会扩容或缩容，并且进行rehash，根据hash值重新计算索引值。那如果这个字典太大了怎么办呢？</p> <p><strong>为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成</strong>。
当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，
并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，
老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。这个过程也被称为渐进式rehash。</p> <p><strong>Hash实际应用场景</strong></p> <p>Hash表使用用来<strong>存储对象数据，比如用户信息</strong>，相对于通过将对象转化为json存储到String类型中，Hash结构的灵活性更大，它可以任何添加和删除对象中的某些字段。</p> <p><strong>购物车功能</strong></p> <ol><li>以用户ID作为key</li> <li>以商品id作为field</li> <li>以商品的数量作为value</li></ol> <p><strong>对象类型数据</strong></p> <p>比如优化之后的用户信息存储，减少数据库的关联查询导致的性能慢的问题。</p> <ol><li>用户信息</li> <li>商品信息</li> <li>计数器</li></ol> <h2 id="redis-set底层实现"><a href="#redis-set底层实现" class="header-anchor">#</a> redis-set底层实现</h2> <p>set里面没有重复的集合。<strong>set的实现比较简单。如果是整数类型，就直接使用整数集合intset</strong> 使用二分查找来辅助，速度还是挺快的。
不过在插入的时候，由于要移动元素，时间复杂度是O(N)。<strong>如果不是整数类型，就使用上面在hash字典。key为set的值，value为空。</strong></p> <p><strong>set类型的实际应用场景</strong></p> <p>标签管理功能：这种标签系统在电商系统、社交系统、视频网站，图书网站，旅游网站等都有着广泛的应用。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，</p> <p>相关商品信息展示：比如在电商系统中，当用户查看某个商品时，可以推荐和这个商品标签有关的商品信息。</p> <h2 id="redis-zset底层实现"><a href="#redis-zset底层实现" class="header-anchor">#</a> redis-zset底层实现</h2> <p>zset是可排序的set。与hash的实现方式类似，<strong>如果元素个数不多且不大，就使用压缩列表ziplist来存储。</strong> 如果元素个数多采用redis-skiplist来实现。
不过由于zset包含了score的排序信息，所以在ziplist内部，是按照score排序递增来存储的。意味着每次插入数据都要移动之后的数据。</p> <p><strong>跳表</strong></p> <p>跳表（skiplist）是另一种实现dict的数据结构。跳表是对链表的一个增强。我们在使用链表的时候，即使元素的有序排列的，
但如果要查找一个元素，也需要从头一个个查找下去，时间复杂度是O(N)。而跳表顾名思义，就是跳跃了一些元素，可以抽象多层。</p> <p>如下图所示，比如我们要查找8，先在最上层L2查找，发现在1和9之间；然后去L1层查找，发现在5和9之间；然后去L0查找，发现在7和9之间，然后找到8。
当元素比较多时，使用跳表可以显著减少查找的次数。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-skiplist.52a85c40.png" alt="img.png"></p> <p>同list类似，<strong>Redis内部也不是直接使用的跳表，而是使用了一个自定义的数据结构来持有跳表</strong>。下图左边蓝色部分是skiplist，
右边是4个zskiplistNode。zskiplistNode内部有很多层L1、L2等，指针指向这一层的下一个结点。BW是回退指针（backward），
用于查找的时候回退。然后下面是score和对象本身object。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-skiplist02.92856abf.png" alt="img.png"></p> <p><strong>ZSet的使用场景</strong></p> <ol><li>排行榜系统</li> <li>热点话题排名</li></ol> <h2 id="为什么要设计sds"><a href="#为什么要设计sds" class="header-anchor">#</a> 为什么要设计sds？</h2> <h2 id="为什么会设计stream-stream用在什么样场景"><a href="#为什么会设计stream-stream用在什么样场景" class="header-anchor">#</a> 为什么会设计Stream，Stream用在什么样场景</h2> <h2 id="消息id的设计是否考虑了时间回拨的问题"><a href="#消息id的设计是否考虑了时间回拨的问题" class="header-anchor">#</a> 消息ID的设计是否考虑了时间回拨的问题</h2> <h2 id="redis-hyperloglog原理"><a href="#redis-hyperloglog原理" class="header-anchor">#</a> redis-HyperLogLog原理</h2> <p>HyperLogLog是Redis2.8.9提供的一种数据结构，他提供了一种基数统计方法,简单来说就是一个集合中不重复元素的个数，比如有一个集合{1,2,3,1,2}，那么它的基数就是3。</p> <p>Redis 提供了 HyperLogLog 数据结构就是用来解决这种统计问题的。HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，
标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了。HyperLogLog 数据结构是 Redis 的高级数据结构，它非常有用。</p> <h2 id="redis-geohash原理"><a href="#redis-geohash原理" class="header-anchor">#</a> redis-GeoHash原理</h2> <p><strong>基于数据库实现LBS服务</strong></p> <p>计算附近的人，通过一个坐标计算这个坐标附近的其他数据，按照距离排序，如何下手呢？</p> <p>以用户为中心，给定一个 1000 米作为半径画圆，那么圆形区域内的用户就是我们想要邂逅的附近的人。将经纬度存储到 MySQL。
我们可以通过区域来过滤出有限「女神」坐标数据，再对矩形区域内的数据进行全量距离计算再排序，这样计算量明显降低。在圆形外套上一个正方形，
根据用户经、纬度的最大最小值（经、纬度 + 距离），作为筛选条件过滤数据，就很容易将正方形内的人信息搜索出来。</p> <p>多出来的这部分区域内的用户，到圆点的距离一定比圆的半径要大，那么我们就计算用户中心点与正方形内所有用户的距离，筛选出所有距离小于等于半径的用户，
圆形区域内的所用户即符合要求的附近的人。为了满足高性能的矩形区域算法，数据表需要在经纬度坐标加上复合索引 (longitude, latitude)，这样可以最大优化查询性能。</p> <p><strong>GeoHash算法</strong> ：将二维的经纬度数据映射到一维的整数，这样所有的元素都将在挂载到一条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近。
当我们想要计算附近的人时，首先将目标位置映射到这条线上，然后在这个一维的线上获取附近的点就行了。</p> <h2 id="redis的渐进式rehash原理"><a href="#redis的渐进式rehash原理" class="header-anchor">#</a> redis的渐进式rehash原理</h2> <p>redis的渐进式rehas背景：在键增加或减少时，会扩容或缩容，并且进行rehash，根据hash值重新计算索引值。</p> <p><strong>为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成</strong>。
当负载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，将新数据插入新散列表中，
并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，
老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。这个过程也被称为渐进式rehash。</p> <h2 id="skiplist的索引过程-能否越两级搜索"><a href="#skiplist的索引过程-能否越两级搜索" class="header-anchor">#</a> SkipList的索引过程，能否越两级搜索?</h2> <p>在一般情况下，跳表的查找过程，是从最高层开始逐层向下查找的，每次查找都是在当前层中找到小于目标元素的最大元素，然后跳转到下一层，继续进行查找。
如果最后找到了目标元素，就返回这个元素所在的节点，否则返回空。所以，对于跳跃表中的索引过程，并没有直接跳跃两层检索的情况，也是逐层进行判断最终获得查找的结果。</p> <h2 id="reids的应用场景"><a href="#reids的应用场景" class="header-anchor">#</a> reids的应用场景</h2> <p>实际上，所谓的应用场景，其实就是合理的利用Redis本身的数据结构的特性来完成相关业务功能，就像mysql，它可以用来做服务注册，
也可以用来做分布式锁，但是mysql它本质是一个关系型数据库，只是用到了其他特性而已。</p> <ol><li>缓存——提升热点数据的访问速度</li> <li>共享数据——数据的存储和共享的问题</li> <li>全局ID —— 分布式全局ID的生成方案（分库分表）</li> <li>分布式锁——进程间共享数据的原子操作保证</li> <li>在线用户统计和计数</li> <li>队列、栈——跨进程的队列/栈</li> <li>消息队列——异步解耦的消息机制</li> <li>服务注册与发现 —— RPC通信机制的服务协调中心（Dubbo支持Redis）</li> <li>购物车</li> <li>新浪/Twitter 用户消息时间线</li> <li>抽奖逻辑（礼物、转发）</li> <li>点赞、签到、打卡</li> <li>商品标签</li> <li>用户（商品）关注（推荐）模型</li> <li>电商产品筛选</li> <li>排行榜</li></ol> <h2 id="一致性hash算法与hash环数据倾斜问题"><a href="#一致性hash算法与hash环数据倾斜问题" class="header-anchor">#</a> 一致性Hash算法与Hash环数据倾斜问题</h2> <p><strong>采用一致性哈希算法(consistent hashing)</strong></p> <p>将key和节点name同时hashing，然后进行映射匹配，采用的算法是MURMUR_HASH。采用一致性哈希而不是采用简单类似哈希求模映射的<strong>主要原因是当增加或减少节点时，
不会产生由于重新匹配造成的rehashing</strong>。一致性哈希只影响相邻节点key分配，影响量小。</p> <p>为了避免一致性哈希只影响相邻节点造成节点分配压力，ShardedJedis会对每个Redis节点根据名字(没有，Jedis会赋予缺省名字)会虚拟化出160个虚拟节点进行散列。
根据权重weight，也可虚拟化出160倍数的虚拟节点。用虚拟节点做映射匹配，可以在增加或减少Redis节点时，key在各Redis节点移动再分配更均匀，而不是只有相邻节点受影响。</p> <p><strong>Hash环的数据倾斜问题：</strong></p> <p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，
例如系统中只有两台服务器，其环分布如图所示，此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。
为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。
具体做法可以在服务器IP或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，
于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p> <h2 id="redis的哨兵机制的原理"><a href="#redis的哨兵机制的原理" class="header-anchor">#</a> redis的哨兵机制的原理</h2> <p>Redis里面的Master-Slave集群，是不具备故障恢复能力的。也就是Master节点挂了以后，需要从集群中的其他Slave节点选举新的Master继续提供服务。
因此在Redis里面引入了Sentinel哨兵机制，通过哨兵来监控集群的状态，实现Master选举。哨兵是一个单独的进程，所以为了保证哨兵的可靠性，我们也会对哨兵做部署集群。</p> <p>假设哨兵节点有3个，那这个时候这三个节点分别去监听Redis的三个主从节点，这里就存在一个问题：一旦Redis主从集群的某个节点出现故障，
而故障节点被其中一个Sentinel哨兵节点检测到，但是另外两个节点还没检测到，那三个哨兵节点如何在意见上达成意见上的一致呢？
同时，哨兵节点怎么判断哪一个Slave节点应该成为Master呢？</p> <p>当Redis集群中的Master节点出现故障，哨兵节点检测到以后，会从Redis集群中的其他Slave节点选举出一个作为新的Master。</p> <p><strong>筛选</strong></p> <p>在筛选阶段，会过滤掉不健康的节点，比如（下线或者断线），或者没有回复Sentinel哨兵心跳响应的Slave节点。同时，还会评估实例过往的网络连接情况，
如果在一定时间内，Slave和Master经常性断链，而且超出了一定的阈值，也不会考虑。经过筛选后，留下的都是健康的节点了。</p> <p><strong>选举机制</strong></p> <p>接下来就对健康节点进行综合评估，具体有三个维度，按照顺序来判断。</p> <ol><li>根据Slave优先级来判断，通过 slave-priority 配置项（redis.conf），可以给不同的从库设置不同优先级，优先级高的优先成为master。</li> <li>选择数据偏移量差距最小的，即slave_repl_offset与 master_repl_offset进度差距，其实就是比较 slave 与 原master 复制进度差距，避免丢失过多数据的问题。</li> <li>slave runID，在优先级和复制进度都相同的情况下，选用runID最好的，runID越小说明创建时间越早，优先选为master。</li></ol> <p>经过以上步骤，就可以选举出新的Master节点了。另外，如果哨兵存在集群的情况下，如果其中一个哨兵节点认为Redis集群主线故障，另外两个哨兵还没感知到的情况下。
在进行Master选举之前，Sentinel哨兵集群需要通过共识算法来达成一致，这里用到了Raft协议。</p> <h2 id="redis中分布式集群的数据倾斜问题"><a href="#redis中分布式集群的数据倾斜问题" class="header-anchor">#</a> Redis中分布式集群的数据倾斜问题</h2> <p>一致性hash，是一种比较特殊的hash算法，它的核心思想是解决在分布式环境下，hash表中可能存在的动态扩容和缩容的问题。
一般情况下，我们会使用hash表的方式以key-value的方式来存储数据，但是当数据量比较大的时候，我们就会把数据存储到多个节点上，然后通过hash取模的方法来决定当前key存储到哪个节点上。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-hash.8100de77.png" alt="img.png"></p> <p>这种方式有一个非常明显的问题，**就是当存储节点增加或者减少的时候，原本的映射关系就会发生变化。**也就是需要对所有数据按照新的节点数量重新映射一遍，这个涉及到大量的数据迁移和重新映射，迁移代价很大。</p> <p>而一致性hash就是用来优化这种动态变化场景的算法，它的具体工作原理也很简单。首先，一致性Hash是通过一个Hash环的数据结构来实现的，这个环的起点是0，终点是2^32-1。也就是这个环的数据分布范围是[0,2^32-1]。</p> <p>然后我们把存储节点的ip地址作为key进行hash之后，会在Hash环上确定一个位置。接下来就是把需要存储的目标key使用hash算法计算后得到一个hash值，同样也会落到hash环的某个位置上。</p> <p>然后这个目标key会按照顺时针的方向找到离自己最近的一个节点进行数据存储。假设现在需要新增一个节点node4，那数据的映射关系的影响范围只限于node3和node1，只有少部分的数据需要重新映射迁移就行了。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-hash02.545a5e87.png" alt="img.png"></p> <p>如果是已经存在的节点node1因为故障下线了，只那只需要把原本分配在node1上的数据重新分配到node2上就行了。同样对数据影响的范围非常小。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-hash03.02f3e227.png" alt="img.png"></p> <p>所以，在我看来，一致性hash算法的好处是扩展性很强，在增加或者减少服务器的时候，数据迁移范围比较小。
另外，在一致性Hash算范里面，为了避免hash倾斜导致数据分配不均匀的情况，我们可以使用虚拟节点的方式来解决。</p> <h2 id="redis的缓存失效与解决方案"><a href="#redis的缓存失效与解决方案" class="header-anchor">#</a> redis的缓存失效与解决方案</h2> <ol><li><strong>缓存雪崩</strong>：<strong>缓存雪崩是指缓存同一时间大面积的失效</strong>，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</li></ol> <p><strong>解决方案</strong></p> <ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li> <li>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</li> <li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</li></ul> <ol start="2"><li><strong>缓存穿透</strong>：<strong>指缓存和数据库中都没有的数据</strong>，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者,攻击会导致数据库压力过大。</li></ol> <p><strong>解决方案：</strong></p> <ul><li>接口层增加校验（限流操作)，如用户鉴权校验(token方法)，id做基础校验，直接拦截。</li> <li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击。</li> <li><strong>采用布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li></ul> <ol start="3"><li><strong>缓存击穿</strong>：<strong>指缓存没有但数据库中有的数据（一般是缓存时间到期)</strong>，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，
造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li></ol> <p><strong>解决方案：</strong></p> <ul><li>设置热点数据永远不过期。</li> <li>加互斥锁，互斥锁。</li></ul> <p><strong>实际的工作中，采用服务降级或者扩容的方式，系统监控与预警的方式来实现缓存的失效的问题。</strong></p> <p>不过，在我看来，您提出来的这个问题，有点过于放大了它带来的影响。</p> <ol><li>首先，在一个成熟的系统里面，对于比较重要的热点数据，必然会有一个专门缓存系统来维护，同时它的过期时间的维护必然和其他业务的key会有一定的差别。而且非常重要的场景，我们还会<strong>设计多级缓存系统</strong>。</li> <li>即便是触发了缓存雪崩，<strong>数据库本身的容灾能力也并没有那么脆弱，数据库的主从、双主、读写分离这些策略</strong>都能够很好的缓解并发流量。</li> <li>最后，<strong>数据库本身也有最大连接数的限制，超过限制的请求会被拒绝，再结合熔断机制，也能够很好的保护数据库系统</strong>，最多就是造成部分用户体验不好。</li> <li>另外，在程序设计上，为了避免缓存未命中导致大量请求穿透到数据库的问题，<strong>还可以在访问数据库这个环节加锁。虽然影响了性能，但是对系统是安全的</strong>。</li></ol> <h2 id="布隆过滤器实现原理"><a href="#布隆过滤器实现原理" class="header-anchor">#</a> 布隆过滤器实现原理</h2> <p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。
它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p> <p><img src="/zhuangxiaoyan/assets/img/BloomFilter.98434066.png" alt="img.png"></p> <p>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</p> <ol><li>对给定元素再次进行相同的哈希计算；</li> <li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。例如下面的图例种：</li> <li></li></ol> <p><img src="/zhuangxiaoyan/assets/img/BloomFilter02.37f40ac1.png" alt="img.png"></p> <p><strong>布隆过滤器应用场景</strong></p> <ol><li>数据库防止穿库. Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。</li> <li>判断用户是否访问过,判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</li> <li>解决缓存穿透: 一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。</li> <li>Web拦截器，黑名单校验: 如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。</li></ol> <h2 id="redis的脑裂"><a href="#redis的脑裂" class="header-anchor">#</a> redis的脑裂</h2> <p>脑裂其实就是网络分区导致的现象，比如，我们的master机器网络突然不正常了发生了网络分区，和其他的slave机器不能正常通信了，
其实master并没有挂还活着好好的呢，但是哨兵可不是吃闲饭的啊，它会认为master挂掉了啊，那么问题来了，client可能还在继续写master的呀，
还没来得及更新到新的master呢，那这部分数据就会丢失。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-twomaster.ca0c0bd1.png" alt="img.png"></p> <p>减少脑裂数据的丢失（不能保证完全保证数据不丢失，竟可能的少丢失）</p> <ol><li>如果master出现了脑裂，和其他的slave失去了通信，不能继续给指定数量的slave发送数据。</li> <li>slave超过10秒没有给自己返回ack消息。</li> <li>master就会拒绝客户端的写请求</li></ol> <h2 id="主从异步复制导致的数据丢失"><a href="#主从异步复制导致的数据丢失" class="header-anchor">#</a> 主从异步复制导致的数据丢失</h2> <p><img src="/zhuangxiaoyan/assets/img/redis-master-salve-data.94ab52bd.png" alt="img.png"></p> <p>redis master 和slave 数据复制是异步的，像前面说的MySQL差不多，这样就有可能会出现部分数据还没有复制到slave中，master就挂掉了，那么这部分的数据就会丢失了。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-master-salve-data02.3058a9fc.png" alt="img.png"></p> <p>解决方案：现在当我们的slave在数据复制的时候，发现返回的ACK时延太长达到了 min-slaves-max-lag 配置，
这个时候就会认为如果master宕机就会导致大量数据丢失，所以就提前进行了预测，就不再去接收客户端的任何请求了，来将丢失的数据降低在可控范围内。</p> <h2 id="哨兵集群如何实现自动发现"><a href="#哨兵集群如何实现自动发现" class="header-anchor">#</a> 哨兵集群如何实现自动发现</h2> <ol><li>通过redis的pub/sub系统实现的，每个哨兵都会往__sentinel__:hello这个channel里发送一个消息。</li> <li>其他哨兵可以消费到这个消息，且可以感知到其他哨兵的存在。</li> <li>每隔两秒钟，每个哨兵都会向自己监控的某个master、slaves对应的__sentinel__:hello channel里发送一个消息（包括自己的host、ip和runid还有对这个master的监控配置）。</li> <li>每个哨兵也会去监听自己监控的每个master+slaves对应的__sentinel__:hello channel，然后去感知到同样在监听这个master+slaves的其他哨兵的存在。</li> <li>每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</li></ol> <h2 id="redis持久化的方式和原理"><a href="#redis持久化的方式和原理" class="header-anchor">#</a> redis持久化的方式和原理</h2> <p>首先，Redis本身是一个基于Key-Value结构的内存数据库，为了避免Redis故障导致数据丢失的问题，所以提供了RDB和AOF两种持久化机制。</p> <p><strong>RDB是通过快照的方式来实现持久化的，也就是说会根据快照的触发条件，把内存里面的数据快照写入到磁盘，以二进制的压缩文件进行存储。</strong></p> <p><img src="/zhuangxiaoyan/assets/img/redis-rdb.37c8b9fc.png" alt="img.png"></p> <p>RDB快照的触发方式有很多，比如:</p> <ul><li>执行bgsave命令触发异步快照，执行save命令触发同步快照，同步快照会阻塞客户端的执行指令。</li> <li>根据redis.conf文件里面的配置，自动触发bgsave</li> <li>主从复制的时候触发</li></ul> <p>AOF是Redis里面的一种数据持久化方式，<strong>它采用了指令追加的方式</strong>。近乎实时的去实现数据指令的持久化，因为AOF，会把每个数据更改的操作指令，追加存储到aof文件里面。
所以很容易导致AOF文件出现过大，造成IO性能问题。</p> <p><img src="data:image/png;base64,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" alt="img.png"></p> <p>Redis为了解决这个问题，设计了<strong>AOF重写机制，也就是说把AOF文件里面相同的指令进行压缩，只保留最新的数据指令</strong>。
简单来说，如果aof文件里面存储了某个key的多次变更记录，但是实际上，最终在做数据恢复的时候，只需要执行最新的指令操作就行了，历史的数据就没必要存在这个文件里面占空间。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-data02.2b6d9d62.png" alt="img.png"></p> <p><strong>AOF文件重写的具体过程分为几步：</strong></p> <ul><li>首先，根据当前Redis内存里面的数据，重新构建一个新的AOF文件</li> <li>然后，读取当前Redis里面的数据，写入到新的AOF文件里面</li> <li>最后，重写完成以后，用新的AOF文件覆盖现有的AOF文件</li></ul> <p>另外，因为AOF在重写的过程中需要读取当前内存里面所有的键值数据，再生成对应的一条指令进行保存。而这个过程是比较耗时的，对业务会产生影响。
所以Redis把重写的过程放在一个后台子进程里面来完成，这样一来，子进程在做重写的时候，主进程依然可以继续处理客户端请求。
最后，<strong>为了避免子进程在重写过程中，主进程的数据发生变化</strong>，<strong>导致AOF文件和Redis内存中的数据不一致的问题</strong>，Redis还做了一层优化。
就是<strong>子进程在重写的过程中，主进程的数据变更需要追加到AOF重写缓冲区里面。等到AOF文件重写完成以后，再把AOF重写缓冲区里面的内容追加到新的AOF文件里面。</strong></p> <p>首先，Redis本身是一个基于Key-Value结构的内存数据库，为了避免Redis故障导致数据丢失的问题，所以提供了RDB和AOF两种持久化机制。
RDB是通过快照的方式来实现持久化的，也就是说会根据快照的触发条件，把内存里面的数据快照写入到磁盘，以二进制的压缩文件进行存储。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-data03.37c8b9fc.png" alt="img.png"></p> <p>RDB快照的触发方式有很多，比如</p> <ul><li>执行bgsave命令触发异步快照，执行save命令触发同步快照，同步快照会阻塞客户端的执行指令。</li> <li>根据redis.conf文件里面的配置，自动触发bgsave</li> <li>主从复制的时候触发</li></ul> <p>AOF持久化，它是一种近乎实时的方式，把Redis Server执行的事务命令进行追加存储。简单来说，就是客户端执行一个数据变更的操作，
Redis Server就会把这个命令追加到aof缓冲区的末尾，然后再把缓冲区的数据写入到磁盘的AOF文件里面，至于最终什么时候真正持久化到磁盘，是根据刷盘的策略来决定的。</p> <h2 id="redis是单线程还是多线程"><a href="#redis是单线程还是多线程" class="header-anchor">#</a> redis是单线程还是多线程？</h2> <ul><li>首先，Redis在6.0支持的多线程，并不是说<strong>指令操作的多线程</strong>，而是针对<strong>网络IO的多线程支持</strong>。也就是Redis的命令操作，仍然是线程安全的。</li> <li>Redis本身的性能瓶颈，取决于三个纬度，网络、CPU、内存。而真正影响内存的关键问题是像内存和网络。而Redis6.0的多线程，本质上解决网络IO的处理效率问题。
在Redis6.0之前。Redis Server端处理接受到客户端请求的时候，Socket连接建立到指令的读取、解析、执行、写回都是由一个线程来处理，这种方式，在客户端请求比较多的情况下，单个线程的网络处理效率太慢，导致客户端的请求处理效率较低。
于是在Redis6.0里面，针对网络IO的处理方式改成了多线程，通过多线程并行的方式提升了网络IO的处理效率。但是对于客户端指令的执行过程，还是使用单线程方式来执行。</li> <li>最后，Redis6.0里面多线程默认是关闭的，需要在redis.conf文件里面修改io-threads-do-reads配置才能开启。另外，之所以指令执行不使用多线程，我认为有两个方面的原因。
<ul><li>内存的IO操作，本身不存在性能瓶颈，Redis在数据结构上已经做了非常多的优化。</li> <li>如果指令的执行使用多线程，那Redis为了解决线程安全问题，需要对数据操作增加锁的同步，不仅仅增加了复杂度，还会影响性能，代价太大不合算。</li></ul></li></ul> <p><img src="data:image/png;base64,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" alt="img.png"></p> <h2 id="redis事务原理"><a href="#redis事务原理" class="header-anchor">#</a> redis事务原理</h2> <p>大家应该对事务比较了解，简单地说，事务表示一组动作，要么全部执行，要么全部不执行。
Redis提供了简单的事务功能，<strong>将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结衷。另外discard命令是回滚</strong>。
<strong>但是要注意Redis的事务功能很弱。在事务回滚机制上，Redis只能对基本的语法错误进行判断</strong>。</p> <p><strong>redis运行时错误</strong>: 例如:事务内第一个命令简单的设置一个string类型，第二个对这个key进行sadd命令，这种就是运行时命令错误，因为语法是正确的。</p> <p><strong>事务是Redis实现在服务器端的行为，用户执行MULTI命令时，服务器会将对应这个用户的客户端对象设置为一个特殊的状态，
在这个状态下后续用户执行的查询命令不会被真的执行，而是被服务器缓存起来，直到用户执行EXEC命令为止，
服务器会将这个用户对应的客户端对象中缓存的命令按照提交的顺序依次执行。</strong></p> <h2 id="redis的主从同步策略"><a href="#redis的主从同步策略" class="header-anchor">#</a> redis的主从同步策略？</h2> <p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。
redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p> <p><strong>全量同步</strong></p> <p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：</p> <ol><li>从服务器连接主服务器，发送SYNC命令；</li> <li>主服务器接收到SYNC命名后，开始执行<strong>BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令</strong>；</li> <li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li> <li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li> <li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li> <li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ol> <p><img src="/zhuangxiaoyan/assets/img/redis-fullsync.b34d1956.png" alt="img.png"></p> <p><strong>增量同步</strong></p> <p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。
增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p> <h2 id="redis-cluster数据分片原理"><a href="#redis-cluster数据分片原理" class="header-anchor">#</a> redis-cluster数据分片原理</h2> <p>集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。
Key 与哈希槽映射过程可以分为两大步骤：</p> <ol><li>根据键值对的 key，使用 CRC16 算法，计算出一个 16 bit 的值；</li> <li>将 16 bit 的值对 16384 执行取模，得到 0 ～ 16383 的数表示 key 对应的哈希槽。</li></ol> <p>Cluster 还允许用户强制某个 key 挂在特定槽位上，通过在 key 字符串里面嵌入 tag 标记，这就可以强制 key 所挂在的槽位等于 tag 所在的槽位。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-slot.6c81bb6f.png" alt="img.png"></p> <h2 id="redis-cluster-gossip通信协议"><a href="#redis-cluster-gossip通信协议" class="header-anchor">#</a> Redis Cluster Gossip通信协议</h2> <p>该集群有三个 Redis 节点组成，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。<strong>三个节点相互连接组成一个对等的集群，
它们之间通过 Gossip协议相互交互集群信息，最后每个节点都保存着其他节点的 slots 分配情况</strong>。 Gossip的作用：1.去中心化，以实现分布式和弹性扩展；2. 失败检测，以实现高可用；</p> <p>Gossip 协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip 消息，常用的 Gossip 消息可分为：Ping 消息、Pong 消息、Meet 消息、Fail 消息。</p> <ol><li>Meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，Meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 Ping、Pong 消息交换；</li> <li>Ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送 Ping 消息，用于检测节点是否在线和交换彼此状态信息。Ping 消息发送封装了自身节点和部分其它节点的状态数据；</li> <li>Pong 消息：当接收到 Ping、Meet 消息时，作为响应消息回复给发送方确认消息正常通信。Pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 Pong 消息来通知整个集群对自身状态进行更新；</li> <li>Fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 Fail 消息，其他节点接收到 Fail 消息之后把对应节点更新为下线状态。</li></ol> <p><img src="/zhuangxiaoyan/assets/img/Gossip.4345892d.png" alt="img.png"></p> <ul><li><p>集中式的优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；
不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。 很多中间件都会借助zookeeper集中式存储元数据。</p></li> <li><p>gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；
缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。</p></li></ul> <h2 id="redis-cluster主节点从节点选举"><a href="#redis-cluster主节点从节点选举" class="header-anchor">#</a> Redis Cluster主节点从节点选举</h2> <p><strong>跟哨兵类似，两者都是基于 Raft 算法来实现的：</strong></p> <ol><li>集群的配置纪元 +1，是一个自曾计数器，初始值 0 ，每次执行故障转移都会 +1。</li> <li>检测到主节点下线的从节点向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li> <li>这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li> <li>参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，如果收集到的票 &gt;= (N/2) + 1 支持，那么这个从节点就被选举为新主节点。</li> <li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li></ol> <p><img src="/zhuangxiaoyan/assets/img/redis-cluster-select.b4e5e763.png" alt="img.png"></p> <h2 id="redis-cluster请求路由方式"><a href="#redis-cluster请求路由方式" class="header-anchor">#</a> Redis Cluster请求路由方式</h2> <p>客户端直连 Redis 服务，进行读写操作时，Key 对应的 Slot 可能并不在当前直连的节点上，经过“重定向”才能转发到正确的节点。
和普通的查询路由相比，Redis Cluster 借助客户端实现的请求路由是一种混合形式的查询路由，它并非从一个 Redis 节点到另外一个 Redis，
而是借助客户端转发到正确的节点。实际应用中，可以在客户端缓存 Slot 与 Redis 节点的映射关系，当接收到 MOVED 响应时修改缓存中的映射关系。
如此，基于保存的映射关系，请求时会直接发送到正确的节点上，从而减少一次交互，提升效率。</p> <p><strong>哈希槽与实例之间的映射关系由于新增实例或者负载均衡重新分配导致改变了？</strong></p> <p>集群中的实例通过 Gossip 协议互相传递消息获取最新的哈希槽分配信息，但是，客户端无法感知。Redis Cluster 提供了重定向机制：
客户端将请求发送到实例上，这个实例没有相应的数据，该 Redis 实例会告诉客户端将请求发送到其他的实例上。</p> <p><strong>Redis如何告知客户端重定向访问新实例呢？</strong></p> <p>分为两种情况：</p> <p><strong>MOVED 错误</strong>： MOVED 错误（负载均衡，数据已经迁移到其他实例上）：当客户端将一个键值对操作请求发送给某个实例，
而这个键所在的槽并非由自己负责的时候，该实例会返回一个 MOVED 错误指引转向正在负责该槽的节点。</p> <p><strong>ASK 错误。</strong> 如果某个 slot 的数据比较多，部分迁移到新实例，还有一部分没有迁移咋办？</p> <p>如果请求的 key 在当前节点找到就直接执行命令，否则时候就需要 ASK 错误响应了，槽部分迁移未完成的情况下，
如果需要访问的 key 所在 Slot 正在从从 实例 1 迁移到 实例 2，实例 1 会返回客户端一条 ASK 报错信息：客户端请求的 key 所在的哈希槽正在迁移到实例 2 上，
你先给实例 2 发送一个 ASKING 命令，接着发发送操作命令。
比如客户端请求定位到 key的槽16330 在实例 172.17.18.1 上，节点1如果找得到就直接执行命令，
否则响应 ASK 错误信息，并指引客户端转向正在迁移的目标节点 172.17.18.2。</p> <p>注意：ASK 错误指令并不会更新客户端缓存的哈希槽分配信息。所以客户端再次请求 Slot 16330 的数据，还是会先给 172.17.18.1 实例发送请求，
只不过节点会响应 ASK 命令让客户端给新实例发送一次请求。MOVED指令则更新客户端本地缓存，让后续指令都发往新实例。</p> <h2 id="redis-cluster的添加新的节点"><a href="#redis-cluster的添加新的节点" class="header-anchor">#</a> redis-cluster的添加新的节点</h2> <p><img src="/zhuangxiaoyan/assets/img/redis-cluster-addnode.78b5e394.png" alt="img.png"></p> <p><img src="/zhuangxiaoyan/assets/img/redis-cluster-addnode02.d4f1f071.png" alt="img.png"></p> <h2 id="redis-cluster集群的缩容"><a href="#redis-cluster集群的缩容" class="header-anchor">#</a> Redis Cluster集群的缩容</h2> <p><img src="/zhuangxiaoyan/assets/img/redis-cluster-cutenode.720b0090.png" alt="img.png"></p> <h2 id="redis-cluster集群不可用"><a href="#redis-cluster集群不可用" class="header-anchor">#</a> Redis Cluster集群不可用</h2> <p>**如果某个主节点没有从节点，那么当它发生故障时，集群将完全处于不可用状态。**不过 Redis 也提供了一个参数cluster-require-full-coverage可以允许部分节点故障，
其它节点还可以继续提供对外访问。比如 7000 主节点宕机，作为 slave 的 7003 成为 Master 节点继续提供服务。当下线的节点 7000 重新上线，它将成为当前70003的从节点。</p> <h2 id="缓存预热"><a href="#缓存预热" class="header-anchor">#</a> 缓存预热</h2> <p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，
然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据!。</p> <p><strong>解决方案</strong></p> <ol><li>直接写个缓存刷新页面，上线时手工操作一下。</li> <li>数据量不大，可以在项目启动的时候自动进行加载。</li> <li>定时刷新缓存。</li></ol> <h2 id="缓存更新"><a href="#缓存更新" class="header-anchor">#</a> 缓存更新</h2> <p>缓存更新除了缓存服务器自带的缓存失效策略之外(Redis 默认的有6中策略可供选择)，我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种:。</p> <ol><li>定时去清理过期的缓存。</li> <li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ol> <h2 id="redis中海量数据查询指定数据"><a href="#redis中海量数据查询指定数据" class="header-anchor">#</a> redis中海量数据查询指定数据?</h2> <ol><li><strong>是keys命令</strong>，由于Redis单线程这一特性，keys命令是以阻塞的方式执行的，keys是以遍历的方式实现的复杂度是0(n)，Redis库中的 key越多，查找实现代价越大，产生的阻塞时间越长。,</li> <li><strong>是scan命令</strong>，以非阻塞的方式实现 key值的查找，绝大多数情况下是可以替代 keys命令的，可选性更强。</li></ol> <h2 id="redis中-kys与scan的实现原理"><a href="#redis中-kys与scan的实现原理" class="header-anchor">#</a> redis中 kys与scan的实现原理？</h2> <p>由于 Redis 是单线程在处理用户的命令，而 Keys 命令会一次性遍历所有 Key，于是在 命令执行过程中，无法执行其他命令。
这就导致如果 Redis 中的 key 比较多，那么 Keys 命令执行时间就会比较长，从而阻塞 Redis。
所以很多教程都推荐使用 Scan 命令来代替 Keys，因为 Scan 可以限制每次遍历的 key 数量。可以理解为Scan是渐进式的Keys。</p> <p><strong>Keys的缺点</strong>：</p> <ol><li>没有limit，我们只能一次性获取所有符合条件的key，如果结果有上百万条，那么等待你的就是“无穷无尽”的字符串输出。</li> <li>keys命令是遍历算法，时间复杂度是O(N)。如我们刚才所说，这个命令非常容易导致Redis服务卡顿。因此，我们要尽量避免在生产环境使用该命令。</li></ol> <p><strong>Scan命令有两个比较明显的优势</strong>：</p> <ol><li>Scan命令的时间复杂度虽然也是O(N)，但它是分次进行的，不会阻塞线程。</li> <li>Scan命令提供了 count 参数，可以控制每次遍历的集合数。</li></ol> <p>Scan 命令注意事项：</p> <ol><li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li> <li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li> <li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;</li></ol> <p>使用时遇到一个 特殊场景，跨区域远程连接 Redis 并进行模糊查询，扫描所有指定前缀的 Key。Redis 中大概几百万 Key。
<strong>最开始也没多想，直接就是开始 Scan，然后 Count 参数指定的是 1000。</strong> 最后发现这个接口需要几十上百秒才返回。</p> <p>什么原因呢？：Scan 命令中的 Count 指定一次扫描多少 Key，这里指定为 1000，几百万Key就需要几千次迭代，即和 Redis 交互几千次，
然后因为是远程连接，网络延迟比较大，所以耗时特别长。最后将 Count 参数调大后，减少了交互次数，就好多了。
Count 参数越大，Redis 阻塞时间也会越长，需要取舍。可以发现 Count 越大，总耗时就越短，不过越后面提升就越不明显了。所以推荐的 Count 大小为 1W 左右。
如果不考虑 Redis 的阻塞，其实 Keys 比 Scan 会快很多，毕竟一次性处理，省去了多余的交互。</p> <p><strong>Scan原理</strong></p> <p>Redis使用了Hash表作为底层实现，原因不外乎高效且实现简单。类似于HashMap那样数组+链表的结构。其中第一维的数组大小为2n(n&gt;=0)。每次扩容数组长度扩大一倍。
Scan命令就是对这个一维数组进行遍历。每次返回的游标值也都是这个数组的索引。Count 参数表示遍历多少个数组的元素，
将这些元素下挂接的符合条件的结果都返回。因为每个元素下挂接的链表大小不同，所以每次返回的结果数量也就不同。</p> <ol><li>整个遍历从开始到结束期间， 一直存在于Redis数据集内的且符合匹配模式的所有Key都会被返回；</li> <li>如果发生了rehash，同一个元素可能会被返回多次，遍历过程中新增或者删除的Key可能会被返回，也可能不会。</li></ol> <h2 id="删除key的命令会阻塞redis吗"><a href="#删除key的命令会阻塞redis吗" class="header-anchor">#</a> 删除Key的命令会阻塞Redis吗？</h2> <ol><li>删除单个字符串类型的key ，时间复杂度为0(1)。</li> <li>删除单个列表、集合、有序集合或哈希表类型的 key ，时间复杂度为0(M)，M为以上数据结构内的元素数量。</li></ol> <h2 id="redis实现一个延时队列"><a href="#redis实现一个延时队列" class="header-anchor">#</a> Redis实现一个延时队列？</h2> <p>要回答这个问题，首先的明白什么是延时队列。其次，还得了解Redis里面哪些结构可以支持这个特性。
延时队列是一种特殊类型的消息队列，它允许把消息发送到队列中，但不立即投递给消费者，而是在一定时间后再将消息投递给消费者。
所以它通常用于需要在未来某个时间执行任务的场景，比如订单的超时处理、定时任务等。</p> <p>在Redis里面可以使用Zset这个有序集合来实现延时队列。具体的实现方式可以分成几个步骤。</p> <ol><li>使用ZADD命令把消息添加到sorted set中，并将当前时间作为score（分数）：<code>ZADD delay-queue &lt;timestamp&gt; &lt;message&gt;</code></li> <li>启动一个消费者线程，使用ZRANGEBYSCORE命令获取定时从Zset中获取当前时间之前的所有消息：<code>ZRANGEBYSCORE delay-queue 0 &lt;current_time&gt; WITHSCORES LIMIT 0 &lt;batch_size&gt;</code></li> <li>消费者处理完消息后，可以从有序集合中删除这些消息：<code>ZREMRANGEBYSCORE delay-queue 0 &lt;current_time&gt;</code></li></ol> <p>这种方式实现的延迟队列，消费端需要不断的向Redis发起轮训，所以它会存在两个问题：</p> <ol><li>轮训存在时间间隔，所以延时消息的实际消费时间会大于设定的时间。</li> <li>大量轮训会对Redis服务器造成压力。</li></ol> <h2 id="redis主从复制原理"><a href="#redis主从复制原理" class="header-anchor">#</a> Redis主从复制原理?</h2> <p>Redis主从复制，是指在Redis集群里面，Master节点和Slave节点数据同步的一种机制。简单来说就是把一台Redis服务器的数据，复制到其他Redis服务器中。
其中负责复制数据的来源称为master，被动接收数据并同步的节点称为slave。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-master-salve.b4c612f5.png" alt="img.png"></p> <p>在Redis里面，提供了<strong>全量复制和增量复制两种模式</strong>。全量复制一般发生在Slave节点初始化阶段，这个时候需要把master上所有数据都复制一份。</p> <p><strong>全量复制工作原理</strong></p> <ol><li>Slave向Master发送SYNC命令，Master收到命令以后生成数据快照。</li> <li>把快照数据发送给Slave节点，Salve节点收到数据后丢弃旧的数据，并重新载入新的数据。</li></ol> <p>需要注意，在主从复制过程中，Redis并没有采用实现强数据一致性，因此会存在一定时间的数据不一致问题。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-master-salve02.386c5c4b.png" alt="img.png"></p> <p><strong>增量复制工作原理</strong></p> <p>增量复制，就是指Master收到数据变更之后，把变更的数据同步给所有Slave节点。
增量复制的原理是，Master和Slave都会维护一个复制偏移量（offset），用来表示Master向Slave传递的字节数。
每次传输数据，Master和Slave维护的Offset都会增加对应的字节数量。Redis只需要根据Offset就可以实现增量数据同步了。?</p> <h2 id="redis哨兵机制和集群有什么区别"><a href="#redis哨兵机制和集群有什么区别" class="header-anchor">#</a> Redis哨兵机制和集群有什么区别？</h2> <p>Redis集群有几种实现方式，<strong>一个是主从集群、一个是Redis Cluster</strong>。</p> <p><strong>主从集群</strong></p> <p>就是在Redis集中包括一个Master节点和多个Slave节点。Master负责数据的读写，Slave节点负责数据的读取。
Master上收到的数据变更，会同步到Slave节点上实现数据的同步。通过这种架构实现可以Redis的读写分离，提升数据的查询性能。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-cluster03.7d7daeef.png" alt="img.png"></p> <p><strong>Redis主从集群不提供容错和恢复功能</strong>，一旦Master节点挂了，不会自动选出新的Master，导致后续客户端所有写请求直接失败。
所以Redis提供了哨兵机制，专门用来监听Redis主从集群提供故障的自动处理能力。哨兵会监控Redis主从节点的状态，当Master节点出现故障，会自动从剩余的Slave节点中选一个新的Master。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-cluster04.163f419c.png" alt="img.png"></p> <p>哨兵模式下虽然解决了Master选举的问题，但是在线扩容的问题还是没有解决。于是就有了第三种集群方式，</p> <p><strong>Redis Cluster</strong></p> <p>它实现了Redis的分布式存储，也就是每个节点存储不同的数据实现数据的分片。在Redis Cluster中，引入了Slot槽来实现数据分片，
Slot的整体取值范围是0~16383，每个节点会分配一个Slot区间当我们存取Key的时候，Redis根据key计算得到一个Slot的值，
然后找到对应的节点进行数据的读写。在高可用方面，Redis Cluster引入了主从复制模式，
一个Master节点对应一个或多个Slave节点，当Master出现故障，会从Slave节点中选举一个新的Master继续提供服务。</p> <p><img src="/zhuangxiaoyan/assets/img/redis-cluster05.cb5a0f23.png" alt="img.png"></p> <p>Redis Cluster虽然解决了在线扩容以及故障转移的能力，但也同样有缺点，比如:</p> <ol><li>客户端的实现会更加复杂</li> <li>Slave节点只是一个冷备节点，不提供分担读操作的压力</li> <li>对于Redis里面的批量操作指令会有限制</li></ol> <p>因此主从模式和Cluster模式各有优缺点，在使用的时候需要根据场景需求来选择。</p> <p>因为Redis集群有两种，一种是主从复制，一种是Redis Cluster，我不清楚您问的是哪一种。按照我的理解，我认为您可能说的是Redis哨兵集群和Redis Cluster的区别。</p> <p>对于这个问题，我认为可以从3个方面来回答:</p> <ol><li><strong>Redis哨兵集群是基于主从复制来实现的，所以它可以实现读写分离</strong>，分担Redis读操作的压力,而<strong>Redis Cluster 集群的Slave节点只是实现冷备机制</strong>，它只有在Master宕机之后才会工作。</li> <li><strong>Redis哨兵集群无法在线扩容</strong>，所以它的并发压力受限于单个服务器的资源配置。<strong>Redis Cluster提供了基于Slot槽的数据分片机制，可以实现在线扩容提升写数据的性能</strong>。</li> <li><strong>从集群架构上来说，Redis 哨兵集群是一主多从</strong>， <strong>而Redis Cluster是多主多从</strong>。</li></ol> <h2 id="redis的缓存淘汰策略"><a href="#redis的缓存淘汰策略" class="header-anchor">#</a> Redis的缓存淘汰策略？</h2> <ul><li>第一个方面：当Redis使用的内存达到maxmemory参数配置的阈值的时候，Redis就会根据配置的内存淘汰策略。把访问频率不高的key从内存中移除。maxmemory默认情况是当前服务器的最大内存。</li> <li>Redis默认提供了8种缓存淘汰策略，这8种缓存淘汰策略总的来说，我认为可以归类成五种
<ol><li>第一种，采用LRU策略，就是把不经常使用的key淘汰掉。</li> <li>第二种，采用LFU策略，它在LRU算法上做了优化，增加了数据访问次数，从而确保淘汰的是非热点key。</li> <li>第三种，随机策略，也就是是随机删除一些key。</li> <li>第四种，ttl策略，从设置了过期时间的key里面，挑选出过期时间最近的key进行优先淘汰。</li> <li>第五种，当内存不够的时候，直接报错，这是默认的策略。
这些策略可以在redis.conf文件中手动配置和修改，我们可以根据缓存的类型和缓存使用的场景来选择合适的淘汰策略。</li></ol></li> <li>我们在使用缓存的时候，建议是增加这些缓存的过期时间。因为我们知道这些缓存大概的生命周期，从而更好的利用内存。</li></ul> <h2 id="怎么防止缓存击穿的问题"><a href="#怎么防止缓存击穿的问题" class="header-anchor">#</a> 怎么防止缓存击穿的问题？</h2> <p>在实际应用中，我们会在程序和数据库之间增加一个缓存层。一方面是为了提升数据检索效率，提升程序性能，另一方面是为了缓解数据库的并发压力。</p> <p>缓存击穿，<strong>表示请求因为某些原因全部打到了数据库，缓存并没有起到流量缓冲的作用</strong>。</p> <p>我认为有2种情况会导致缓存击穿</p> <ul><li>在Redis里面保存的热点key，在缓存过期的瞬间，有大量请求进来，导致请求全部打在数据库上。</li> <li>客户端恶意发起大量不存在的key的请求，由于访问的key对应的数据本身就不存在，所以每次必然都会穿透到数据库，导致缓存成为了摆设。</li></ul> <p>总之，当Redis承担了流量缓冲功能的时候，就需要考虑到Redis失效导致并发压力过大对后端存储设备造成冲击的问题。因此，我认为可以通过几种方法来解决。</p> <ul><li>对于热点数据，我们可以不设置过期时间，或者在访问数据的时候对数据过期时间进行续期。</li> <li>对于访问量较高的缓存数据，我们可以设计多级缓存，尽量减少后端存储设备的压力。</li> <li>使用分布式锁，当发现缓存失效的时候，不是先从数据库加载，而是先获取分布式锁，获得分布式锁的线程从数据库查询数据后写回到缓存里面。后续没有获得锁的线程就只需要等待和重试即可。这个方案牺牲了一定的性能，但是确保护了数据库避免被压垮。</li> <li>对于恶意攻击类的场景，可以使用布隆过滤器，应用启动的时候把存在的数据缓存到布隆过滤器里面。每一次请求进来的时候先访问布隆过滤器，如果不存在，则说明这个数据一定没有在数据库里面，就没必要再去访问数据库了。</li> <li>另外，我们在整个缓存架构设计中，除了尽可能避免缓存穿透的问题，还需要从全局视角做整体考虑。比如业务隔离、多级缓存、部署隔离、安全性考虑等。</li></ul> <h2 id="redis存在线程安全问题吗"><a href="#redis存在线程安全问题吗" class="header-anchor">#</a> Redis存在线程安全问题吗？</h2> <p>第一个，从Redis 服务端层面。Redis Server本身是一个线程安全的K-V数据库，也就是说在Redis Server上执行的指令，不需要任何同步机制，不会存在线程安全问题。
虽然Redis 6.0里面，<strong>增加了多线程的模型，但是增加的多线程只是用来处理网络IO事件</strong>，<strong>对于指令的执行过程，仍然是由主线程来处理，所以不会存在多个线程通知执行操作指令的情况</strong>。</p> <p><img src="data:image/png;base64,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" alt="img.png"></p> <p>为什么Redis没有采用多线程来执行指令，我认为有几个方面的原因。</p> <ul><li>Redis Server本身可能出现的性能瓶颈点无非就是网络IO、CPU、内存。但是CPU不是Redis的瓶颈点，所以没必要使用多线程来执行指令。</li> <li>如果采用多线程，意味着对于redis的所有指令操作，都必须要考虑到线程安全问题，也就是说需要加锁来解决，这种方式带来的性能影响反而更大。</li></ul> <p>第二个，从Redis客户端层面。虽然Redis Server中的指令执行是原子的，但是如果有多个Redis客户端同时执行多个指令的时候，就无法保证原子性。</p> <p><img src="data:image/png;base64,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" alt="img.png"></p> <p>假设两个redis client同时获取Redis Server上的key1，同时进行修改和写入，<strong>因为多线程环境下的原子性无法被保障</strong>，
<strong>以及多进程情况下的共享资源访问的竞争问题，使得数据的安全性无法得到保障</strong>。</p> <p>当然，对于客户端层面的线程安全性问题，解决方法有很多，比如尽可能的使用Redis里面的原子指令，或者对多个客户端的资源访问加锁，或者通过Lua脚本来实现多个指令的操作等等。</p> <h2 id="单机模式的优缺点"><a href="#单机模式的优缺点" class="header-anchor">#</a> 单机模式的优缺点</h2> <p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p> <p><strong>优点：</strong></p> <ol><li>架构简单，部署方便。</li> <li>高性价比：缓存使用时无需备用节点(单实例可用性可以用 supervisor 或 crontab 保证)，当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务。</li> <li>高性能。</li></ol> <p><strong>缺点：</strong></p> <ol><li>不保证数据的可靠性。</li> <li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务。</li> <li>高性能受限于单核 CPU 的处理能力(Redis 是单线程机制)，CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</li></ol> <h2 id="主从架构的优缺点"><a href="#主从架构的优缺点" class="header-anchor">#</a> 主从架构的优缺点</h2> <p>主（master）和 从（slave）部署在不同的服务器上，当主节点服务器写入数据时会同步到从节点的服务器上，一般主节点负责写入数据，从节点负责读取数据。
<strong>从节点设置只读属性，而主节点没有只写属性，因此，主节点可读可以写</strong></p> <p><strong>优点：</strong></p> <ol><li>读写分离，提高效率</li> <li>主节点负责写操作，从节点负责读操作；如果写少读多场景，配置多个从节点的话，效率非常高</li> <li>数据热备份，提供多个副本。</li> <li>从节点宕机，影响较小</li></ol> <p><strong>缺点：</strong></p> <ol><li>主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预。</li> <li>因为只有主节点能进行写操作，一旦主节点宕机，整个服务就无法使用。当然此时从节点仍可以进行读操作，但是对于整个服务流程来说，是无法使用的。</li> <li>Master的写的压力难以降低。</li> <li>如果写操作比较多，那么只有一个主节点的话，无法分担压力。</li> <li>主节点存储能力受到单击限制。</li> <li>主节点只能有一个，因此单节点内存大小不会太大，因此存储数据量受限。</li> <li>主从数据同步，可能产生部分的性能影响甚至同步风暴。</li></ol> <h2 id="redis-sentinel哨兵的优缺点"><a href="#redis-sentinel哨兵的优缺点" class="header-anchor">#</a> redis-sentinel哨兵的优缺点</h2> <p>为了解决这两个问题，在2.8版本之后redis正式提供了sentinel架构。在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态。
如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般。
<strong>与主从相比，哨兵仅解决了手动切换主从节点问题，至于其他的问题，基本上仍然存在。哨兵的主要问题还是由于中心架构，仅存在一个master节点引起的，写的效率太低。</strong></p> <p><strong>优点：</strong></p> <ol><li>对节点进行监控，来完成自动的故障发现与转移</li></ol> <p><strong>缺点：</strong></p> <ol><li><strong>特别是在主从切换的瞬间存在访问瞬断的情况，等待时间比较长，至少十来秒不可用</strong>。</li> <li>哨兵模式只有一个主节点对外提供服务，没法支持很高的并发</li> <li>单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。</li></ol> <h2 id="redis-cluster模式的优缺点"><a href="#redis-cluster模式的优缺点" class="header-anchor">#</a> Redis-Cluster模式的优缺点</h2> <p>Redis Cluster 是 3.0 版后推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，
比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p> <p>Redis Cluster 集群节点最小配置 6 个节点以上(3 主 3 从)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。
Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p> <p>注意：集群模式下 从节点不提供读写，与主从模式不一样。
总结一下经验，分布式场景下：集群模式一般从节点不参与读写，仅作为备用节点。而主从一般都要负责读或写，都要参与具体的工作。</p> <p><strong>优点：</strong></p> <ol><li>无中心架构。即有多个master节点，不像哨兵模式下仅有一个。这样写的压力就可以分散了；并且存储量也可以扩展了，
因为多个主节点都可以存储一部分数据，总量要远大于单主节点架构。</li> <li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li> <li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除。</li> <li>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够 实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。</li></ol> <p><strong>缺点：</strong></p> <ol><li>如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。</li></ol> <h2 id="redis延迟队列的应用场景"><a href="#redis延迟队列的应用场景" class="header-anchor">#</a> Redis延迟队列的应用场景</h2> <ol><li>订单超过30分钟未支付，自动关闭。</li> <li>订单完成后, 如果用户一直未评价, 5天后自动好评。</li> <li>会员到期前15天, 到期前3天分别发送短信提醒。</li> <li>当订单一直处于未支付状态时，如何及时的关闭订单，并退还库存？</li> <li>如何定期检查处于退款状态的订单是否已经退款成功？</li> <li>新创建店铺，N天内没有上传商品，系统如何知道该信息，并发送激活短信？</li></ol> <h2 id="redis性能优化方案"><a href="#redis性能优化方案" class="header-anchor">#</a> Redis性能优化方案</h2> <p>Redis 是基于单线程模型实现的，也就是 Redis 是使用一个线程来处理所有的客户端请求的，尽管 Redis 使用了非阻塞式 IO，
并且对各种命令都做了优化（大部分命令操作时间复杂度都是 O(1)），但由于 Redis 是单线程执行的特点，因此它对性能的要求更加苛刻，
我们将通过一些优化手段，让 Redis 更加高效的运行。</p> <ol><li>缩短键值对的存储长度；</li> <li>使用 lazy free（延迟删除）特性；</li> <li>设置键值的过期时间；</li> <li>禁用耗时长的查询命令(<strong>比如keys</strong>)；</li> <li>使用 slowlog 优化耗时命令；</li> <li>使用 Pipeline 批量操作数据；</li> <li>避免大量数据同时失效；</li> <li>客户端使用优化；</li> <li>限制Redis内存大小；</li> <li>使用物理机而非虚拟机安装Redis服务；</li> <li>检查数据持久化策略；</li> <li>使用分布式架构来增加读写速度。</li></ol> <h2 id="redis分布式锁的代码"><a href="#redis分布式锁的代码" class="header-anchor">#</a> redis分布式锁的代码</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/buy&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span>REDIS_LOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 每个人进来先要进行加锁，key值为&quot;good_lock&quot;</span>
    <span class="token class-name">String</span> value <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> result <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;goods&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> total <span class="token operator">=</span> result <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果在此处需要调用其他微服务，处理时间较长。。。</span>
            <span class="token keyword">int</span> realTotal <span class="token operator">=</span> total <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            template<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;goods&quot;</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>realTotal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;购买商品成功，库存还剩：&quot;</span> <span class="token operator">+</span> realTotal <span class="token operator">+</span> <span class="token string">&quot;件&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">&quot;购买商品成功，库存还剩：&quot;</span> <span class="token operator">+</span> realTotal <span class="token operator">+</span> <span class="token string">&quot;件&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;购买商品失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token string">&quot;购买商品失败&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果锁依旧在同时还是在被当前线程持有，那就解锁。 如果是其他的线程持有 那就不能释放锁资源</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> lock<span class="token punctuation">.</span><span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="什么是bigkey-bigkey的危害是什么"><a href="#什么是bigkey-bigkey的危害是什么" class="header-anchor">#</a> 什么是bigkey,bigkey的危害是什么？</h2> <p>bigkey是指key对应的value所占的内存空间比较大，例如一个字符串类型的value可以最大存到512MB，一个列表类型的value最多可以存储2^(23)-1个元素。</p> <p>如果按照数据结构来细分的话，一般分为字符串类型biqkey和非字符串类型bigkey。</p> <ol><li>字符串类型:体现在单个value值很大，一般认为超过10KB就是bigkey，但这个值和具体的OPS相关。</li> <li>非字符串类型:哈希、列表、集合、有序集合,体现在元素个数过多。bigkey无论是空间复杂度和时间复杂度都不太友好，下面我们将介绍它的危害。</li></ol> <p><strong>bigkey的危害体现在三个方面:</strong></p> <ol><li>内存空间不均匀.(平衡):例如在Redis Cluster中,bigkey会造成节点的内存空间使用不均匀。</li> <li>超时阻塞:由于Redis单线程的特性，操作bigkey比较耗时，也就意味着阻塞Redis可能性增大。</li> <li>网络拥塞:每次获取bigkey产生的网络流量较大。</li></ol> <h2 id="redis如何解决key冲突"><a href="#redis如何解决key冲突" class="header-anchor">#</a> Redis如何解决key冲突?</h2> <ol><li>业务隔离：业务A SET A1, key区分出来。</li> <li>key的设计: 业务模块+系统名称+关键biz-pay-orderid-11,userid。</li> <li>分布式锁: 多个客户端你并发写key原有值1，修改顺序，2-&gt;3-&gt;4,2客户端拿到锁才能进行操作。时间戳set key 7:00set key 6:00。</li></ol> <h2 id="redis集群方案什么情况下会导致整集群不可用"><a href="#redis集群方案什么情况下会导致整集群不可用" class="header-anchor">#</a> Redis集群方案什么情况下会导致整集群不可用?</h2> <p>为了保证集群完整性，默认情况下当集群16384个槽任何一个没有指派到节点时整个集群不可用。执行任何键命令返回( error)CLUSTERDOWN Hash slot not served错误。
这是对集群完整性的一种保护措施，保证所有的槽都指派给在线的节点。但是当持有槽的主节点下线时，从故障发现到自动完成转移期间整个集群是不可用状态，
对于大多数业务无法容忍这种情况，因此可以将参数cluster-require-full-coverage配置为no，当主节点故障时只影响它负责槽的相关命令执行，
不会影响其他主节点的可用性。但是从集群的故障转移的原理来说，集群会出现不可用</p> <ol><li>当访问一个Master和Slave节点都挂了的时候，cluster-require-full-coverage=yes，会报槽无法获取。</li> <li>集群主库半数宕机(根据failover 原理，fail掉一个主需要一半以上主都投票通过才可以)。</li> <li>另外，当集群Master节点个数小于3个的时候，或者集群可用节点个数为偶数的时候，基于fail的这种选举机制的自动主从切换过程可能会不能正常工作，
一个是标记 fail 的过程，一个是选举新的 master的过程，都有可能异常。</li></ol> <h2 id="redis和memcache区别-优缺点对比"><a href="#redis和memcache区别-优缺点对比" class="header-anchor">#</a> Redis和Memcache区别，优缺点对比</h2> <ol><li>Redis和Memcache都是将数据存放在内存中，都是内存数据库。<strong>不过memcache还可用于缓存其他东西，例如图片、视频等等</strong>。</li> <li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li> <li>虚拟内存：Redis当物理内存用完时，可以将一些很久没用到的value交换到磁盘。</li> <li>过期策略：memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire设定，例如expire name 10。</li> <li>分布式设定memcache集群，利用magent做一主多从;redis可以一主一从,也可以做一主多从。</li> <li>存储数据安全：memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化。</li> <li>灾难恢复：memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复。</li> <li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol> <h2 id="redis如何做内存优化"><a href="#redis如何做内存优化" class="header-anchor">#</a> Redis如何做内存优化？</h2> <h2 id="redis-key-的过期时间和永久有效分别怎么设置"><a href="#redis-key-的过期时间和永久有效分别怎么设置" class="header-anchor">#</a> Redis key 的过期时间和永久有效分别怎么设置？</h2> <p>EXPIRE 和 PERSIST 命令</p> <h2 id="redis-中的管道有什么用"><a href="#redis-中的管道有什么用" class="header-anchor">#</a> Redis 中的管道有什么用？</h2> <p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。
这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p> <h2 id="什么是redis事务"><a href="#什么是redis事务" class="header-anchor">#</a> 什么是redis事务</h2> <h2 id="redis事务相关命令"><a href="#redis事务相关命令" class="header-anchor">#</a> Redis事务相关命令</h2> <h2 id="redis事务的三个阶段"><a href="#redis事务的三个阶段" class="header-anchor">#</a> Redis事务的三个阶段</h2> <h2 id="watch是如何监视实现的呢"><a href="#watch是如何监视实现的呢" class="header-anchor">#</a> watch是如何监视实现的呢</h2> <h2 id="为什么-redis-不支持回滚"><a href="#为什么-redis-不支持回滚" class="header-anchor">#</a> 为什么 Redis 不支持回滚</h2> <h2 id="redis-对-acid的支持性理解"><a href="#redis-对-acid的支持性理解" class="header-anchor">#</a> redis 对 ACID的支持性理解</h2> <h2 id="redis事务其他实现"><a href="#redis事务其他实现" class="header-anchor">#</a> Redis事务其他实现</h2> <p>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完基于
中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</p> <h2 id="redis集群的主从复制模型是怎样的"><a href="#redis集群的主从复制模型是怎样的" class="header-anchor">#</a> Redis集群的主从复制模型是怎样的?</h2> <h2 id="全量复制的三个阶段"><a href="#全量复制的三个阶段" class="header-anchor">#</a> 全量复制的三个阶段?</h2> <h2 id="为什么会设计增量复制"><a href="#为什么会设计增量复制" class="header-anchor">#</a> 为什么会设计增量复制?</h2> <h2 id="增量复制的流程"><a href="#增量复制的流程" class="header-anchor">#</a> 增量复制的流程?</h2> <p>如果在网络断开期间,repl_backlog_size环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢?</p> <h2 id="为什么不持久化的主服务器自动重启非常危险呢"><a href="#为什么不持久化的主服务器自动重启非常危险呢" class="header-anchor">#</a> 为什么不持久化的主服务器自动重启非常危险呢?</h2> <h2 id="为什么主从全量复制使用rdb而不使用aof"><a href="#为什么主从全量复制使用rdb而不使用aof" class="header-anchor">#</a> 为什么主从全量复制使用RDB而不使用AOF?</h2> <h2 id="为什么还有无磁盘复制模式"><a href="#为什么还有无磁盘复制模式" class="header-anchor">#</a> 为什么还有无磁盘复制模式?</h2> <h2 id="为什么还会有从库的从库的设计"><a href="#为什么还会有从库的从库的设计" class="header-anchor">#</a> 为什么还会有从库的从库的设计?</h2> <h2 id="redis哨兵机制"><a href="#redis哨兵机制" class="header-anchor">#</a> Redis哨兵机制?</h2> <h2 id="哨兵实现了什么功能呢"><a href="#哨兵实现了什么功能呢" class="header-anchor">#</a> 哨兵实现了什么功能呢</h2> <h2 id="哨兵集群是通过什么方式组建的"><a href="#哨兵集群是通过什么方式组建的" class="header-anchor">#</a> 哨兵集群是通过什么方式组建的?</h2> <h2 id="哨兵是如何监控redis集群的"><a href="#哨兵是如何监控redis集群的" class="header-anchor">#</a> 哨兵是如何监控Redis集群的?</h2> <h2 id="哨兵如何判断主库已经下线了呢"><a href="#哨兵如何判断主库已经下线了呢" class="header-anchor">#</a> 哨兵如何判断主库已经下线了呢?</h2> <h2 id="哨兵的选举机制是什么样的"><a href="#哨兵的选举机制是什么样的" class="header-anchor">#</a> 哨兵的选举机制是什么样的?</h2> <p>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库&quot;客观下线?能否自动切换?</p> <p>主库判定客观下线了，那么如何从剩余的从库中选择一个新的主库呢?</p> <h2 id="新的主库选择出来后-如何进行故障的转移"><a href="#新的主库选择出来后-如何进行故障的转移" class="header-anchor">#</a> 新的主库选择出来后，如何进行故障的转移?</h2> <h2 id="redis集群会有写操作丢失吗-为什么"><a href="#redis集群会有写操作丢失吗-为什么" class="header-anchor">#</a> Redis集群会有写操作丢失吗？为什么？</h2> <h2 id="redis并不能保证数据的强一致性-这意味这在实际中集群在特定的条件下可能会丢失写操作。"><a href="#redis并不能保证数据的强一致性-这意味这在实际中集群在特定的条件下可能会丢失写操作。" class="header-anchor">#</a> Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</h2> <h2 id="redis如何做大量数据插入"><a href="#redis如何做大量数据插入" class="header-anchor">#</a> Redis如何做大量数据插入？</h2> <h2 id="redis2-6开始redis-cli支持一种新的被称之为pipe-mode的新模式用于执行大量数据插入工作。"><a href="#redis2-6开始redis-cli支持一种新的被称之为pipe-mode的新模式用于执行大量数据插入工作。" class="header-anchor">#</a> Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</h2> <h2 id="redis实现分布式锁实现-什么是-redlock"><a href="#redis实现分布式锁实现-什么是-redlock" class="header-anchor">#</a> redis实现分布式锁实现? 什么是 RedLock?</h2> <h2 id="redis缓存有哪些问题-如何解决redis和其它数据库一致性问题如何解决"><a href="#redis缓存有哪些问题-如何解决redis和其它数据库一致性问题如何解决" class="header-anchor">#</a> redis缓存有哪些问题，如何解决redis和其它数据库一致性问题如何解决</h2> <h2 id="redis性能问题有哪些-如何分析定位解决"><a href="#redis性能问题有哪些-如何分析定位解决" class="header-anchor">#</a> redis性能问题有哪些，如何分析定位解决</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/zhuangxiaoyan/interview/pattern.html" class="prev">
        设计模式面试问题
      </a></span> <span class="next"><a href="/zhuangxiaoyan/interview/mybatis.html">
        Mybatis面试问题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/zhuangxiaoyan/assets/js/app.868ae4fe.js" defer></script><script src="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" defer></script><script src="/zhuangxiaoyan/assets/js/4.4d57c8c0.js" defer></script>
  </body>
</html>
