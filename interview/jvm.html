<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM面试问题 | 庄小焱</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="我是庄小焱，PMP项目管理专家、系统架构设计师(高级)、CSDN博文专家、后端开发工程师。 博主在微服务、虚拟化、系统架构、大数据、机器学习领域不断学习，同时在博客中分享自己学习知识和相关技术， 欢迎大家和我交流学习，欢迎大家关注我的博客。">
    
    <link rel="preload" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css" as="style"><link rel="preload" href="/zhuangxiaoyan/assets/js/app.868ae4fe.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" as="script"><link rel="preload" href="/zhuangxiaoyan/assets/js/13.875c4422.js" as="script"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/10.f03f824c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/11.8bbceb5f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/12.14f9a7e9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/14.b913d772.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/15.04d0022c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/16.2f5474ed.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/17.314561f8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/18.4f00aff9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/19.3198a9c6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/20.6ca58bc3.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/21.2b13b489.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/22.1ab1c76c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/23.71e25b05.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/24.ad6ea50e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/25.76e0a373.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/26.b9862941.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/27.aa410472.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/28.03808d20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/29.00bd7baa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/3.08485426.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/30.005c22a8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/31.93f0d38f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/32.340f8c91.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/33.4fd282b8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/34.3a5d80ea.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/35.46a3fd70.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/36.a4d7d4a0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/37.f4563f51.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/38.a4755c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/39.38a44f79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/4.4d57c8c0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/40.7ace36ef.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/41.16f6b68f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/42.6d72579b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/43.c87acddc.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/44.29fd9c56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/45.1e066d5b.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/46.38a90e06.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/47.d01627f0.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/48.a24f2064.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/49.b385ae96.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/5.113b6e17.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/50.36614d52.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/51.0a4de0f4.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/52.f34a7e67.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/53.628cf4ca.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/54.cc220f8a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/55.44be834a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/56.a10f9160.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/57.889877cb.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/58.35998118.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/59.a96ac910.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/6.1a9b2f20.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/60.69ed00aa.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/61.cd318979.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/62.c1d36d16.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/63.d5921184.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/64.e337ae65.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/65.4754688d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/66.f1e18825.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/67.90234ef8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/68.17c41d12.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/69.d424f938.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/7.713b03d2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/70.dcbc2969.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/71.7dce671a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/72.ca24dbed.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/73.3746d1d5.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/74.b57bc73f.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/75.9bcbf8d9.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/76.ad9819f6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/77.1939880d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/78.d4fe71a2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/79.95e3a69e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/8.4562fbf2.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/80.0c9cbcee.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/81.9f9d8638.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/82.4aeef92d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/83.d69f52f7.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/84.a5ef042c.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/85.c37ffab6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/86.6d5b65db.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/87.afa8b536.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/88.1c19772d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/89.5f70dc04.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/9.7d7583a8.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/90.2a690c79.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/91.4d0be90d.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/92.d82b3978.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/93.50ab1b48.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/94.b8bd6e2a.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/95.1fc4557e.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/96.7063edd6.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/97.a7fd9d56.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/98.c7605566.js"><link rel="prefetch" href="/zhuangxiaoyan/assets/js/99.6fe2324c.js">
    <link rel="stylesheet" href="/zhuangxiaoyan/assets/css/0.styles.43ec611f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zhuangxiaoyan/" class="home-link router-link-active"><!----> <span class="site-name">庄小焱</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zhuangxiaoyan/resume/" class="nav-link">
  庄小焱简历
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/blog/" class="nav-link">
  庄小焱博客
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/project/" class="nav-link">
  实战项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/interview/" class="nav-link router-link-active">
  面试项目
</a></div><div class="nav-item"><a href="/zhuangxiaoyan/ai/" class="nav-link">
  AI项目
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="个人账号" class="dropdown-title"><span class="title">个人账号</span> <span class="arrow down"></span></button> <button type="button" aria-label="个人账号" class="mobile-dropdown-title"><span class="title">个人账号</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://zhuang-xiaoyan.github.io/zhuangxiaoyan/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/Zhuang-XiaoYan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/xjl2462612540" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/weixin_41605937" target="_blank" rel="noopener noreferrer" class="nav-link external">
  庄小焱-CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>分布式设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/" aria-current="page" class="sidebar-link">场景面试问题总结</a></li><li><a href="/zhuangxiaoyan/interview/distributed-arithmetic.html" class="sidebar-link">分布式原理算法</a></li><li><a href="/zhuangxiaoyan/interview/distributed-id.html" class="sidebar-link">分布式ID原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-lock.html" class="sidebar-link">分布式锁原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-transaction.html" class="sidebar-link">分布式事务原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/distributed-throttling.html" class="sidebar-link">分布式限流原理与设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java语言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/java-base.html" class="sidebar-link">java面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mysql.html" class="sidebar-link">Mysql面试问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-backup.html" class="sidebar-link">数据库与缓存一致性</a></li><li><a href="/zhuangxiaoyan/interview/mysql-cluster.html" class="sidebar-link">Mysql主从问题</a></li><li><a href="/zhuangxiaoyan/interview/mysql-slow-query.html" class="sidebar-link">数据查询优化设计</a></li><li><a href="/zhuangxiaoyan/interview/mysql-split-table.html" class="sidebar-link">数据分库分表设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>并发编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/juc.html" class="sidebar-link">JUC面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>源码分析</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jdk.html" class="sidebar-link">JDK面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>虚拟机</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/jvm.html" aria-current="page" class="active sidebar-link">JVM面试问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm的内存模型" class="sidebar-link">JVM的内存模型</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#堆和栈的区别" class="sidebar-link">堆和栈的区别</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm的异常与解决方法" class="sidebar-link">JVM的异常与解决方法</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm中对象分配规则" class="sidebar-link">JVM中对象分配规则</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#对象内存布局" class="sidebar-link">对象内存布局</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#java对象创建过程" class="sidebar-link">Java对象创建过程</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm堆中的新生代" class="sidebar-link">jvm堆中的新生代</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm堆中的老生代" class="sidebar-link">jvm堆中的老生代</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#永久代和元空间" class="sidebar-link">永久代和元空间</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#什么要废除永久代" class="sidebar-link">什么要废除永久代</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#什么情况会造成元空间溢出" class="sidebar-link">什么情况会造成元空间溢出？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#永久代-元空间溢出的解决方法" class="sidebar-link">永久代/元空间溢出的解决方法</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#对象是怎么从年轻代进入老年代的" class="sidebar-link">对象是怎么从年轻代进入老年代的？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm中class文件加载原理" class="sidebar-link">JVM中class文件加载原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm类加载器类型" class="sidebar-link">JVM类加载器类型</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm类加载为什么要使用双亲委派模式" class="sidebar-link">jVM类加载为什么要使用双亲委派模式</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#java的类加载是否一定遵循双亲委托模型" class="sidebar-link">Java的类加载是否一定遵循双亲委托模型？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#判断对象是否为垃圾" class="sidebar-link">判断对象是否为垃圾</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#垃圾回收算法" class="sidebar-link">垃圾回收算法</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#新生代的算法实现" class="sidebar-link">新生代的算法实现</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#老年代的算法实现" class="sidebar-link">老年代的算法实现</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#minorgc-majorgc、fullgc都什么时候发生" class="sidebar-link">MinorGC，MajorGC、FullGC都什么时候发生？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#fullgc的发生条件" class="sidebar-link">FullGC的发生条件</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#垃圾分代收集的过程" class="sidebar-link">垃圾分代收集的过程？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#垃圾回收器的类型" class="sidebar-link">垃圾回收器的类型</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#cms垃圾回收期的工作原理" class="sidebar-link">CMS垃圾回收期的工作原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#cms都有哪些问题" class="sidebar-link">CMS都有哪些问题?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#zgc垃圾收集器原理" class="sidebar-link">ZGC垃圾收集器原理</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm四大引用作用" class="sidebar-link">JVM四大引用作用</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#逃逸分析" class="sidebar-link">逃逸分析</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#指令重排序" class="sidebar-link">指令重排序？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#你能保证gc执行吗" class="sidebar-link">你能保证GC执行吗</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#safepoint是什么" class="sidebar-link">safepoint是什么？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#swap会影响性能么" class="sidebar-link">SWAP会影响性能么?</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm-配置参数有哪些" class="sidebar-link">JVM 配置参数有哪些？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm-提供的常用工具" class="sidebar-link">JVM 提供的常用工具</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#invokedynamic指令是干什么的" class="sidebar-link">invokedynamic指令是干什么的？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#能够找到reference-chain的对象-就一定会存活么" class="sidebar-link">能够找到Reference Chain的对象，就一定会存活么？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#cpu过高解决方案" class="sidebar-link">CPU过高解决方案</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#cpu过高排查流程" class="sidebar-link">CPU过高排查流程</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#oom问题排查" class="sidebar-link">OOM问题排查</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#gc-overhead-limit-exceeded错误" class="sidebar-link">GC overhead limit exceeded错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#permgen-space错误" class="sidebar-link">Permgen space错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#metaspace错误" class="sidebar-link">Metaspace错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#unable-to-create-new-native-thread错误" class="sidebar-link">Unable to create new native thread错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#out-of-swap-space-错误" class="sidebar-link">Out of swap space 错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#kill-process-or-sacrifice-child错误" class="sidebar-link">Kill process or sacrifice child错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#requested-array-size-exceeds-vm-limit错误" class="sidebar-link">Requested array size exceeds VM limit错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#direct-buffer-memory错误" class="sidebar-link">Direct buffer memory错误</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#hashmap存在内存泄露问题" class="sidebar-link">HashMap存在内存泄露问题</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#hashmap-hashset的内存泄漏问题" class="sidebar-link">hashmap hashset的内存泄漏问题</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#如果发生内存泄漏怎么排查" class="sidebar-link">如果发生内存泄漏怎么排查</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#如何破坏双亲委派模型" class="sidebar-link">如何破坏双亲委派模型？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm为什么使用元空间替换了永久代" class="sidebar-link">JVM为什么使用元空间替换了永久代？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#happens-before的理解" class="sidebar-link">Happens-Before的理解</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#jvm分代年龄为什么是15次" class="sidebar-link">JVM分代年龄为什么是15次？</a></li><li class="sidebar-sub-header"><a href="/zhuangxiaoyan/interview/jvm.html#什么是双亲委派" class="sidebar-link">什么是双亲委派？</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/network.html" class="sidebar-link">网络面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>操作系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/os.html" class="sidebar-link">OS面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring.html" class="sidebar-link">spring面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Spring-Cloud框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/spring-cloud.html" class="sidebar-link">SpringCloud面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>设计模式</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/pattern.html" class="sidebar-link">设计模式面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Redis中间件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/redis.html" class="sidebar-link">Redis面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Mybatis框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mybatis.html" class="sidebar-link">Mybatis面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>MQ框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/mq.html" class="sidebar-link">MQ面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Nginx框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/nginx.html" class="sidebar-link">nginx面试问题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>微服务设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zhuangxiaoyan/interview/micro-idempotent.html" class="sidebar-link">幂等性原理与设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-auth.html" class="sidebar-link">认证授权设计</a></li><li><a href="/zhuangxiaoyan/interview/micro-encryption.html" class="sidebar-link">加密算法总结</a></li><li><a href="/zhuangxiaoyan/interview/micro-other.html" class="sidebar-link">综合场景面试问题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="jvm面试问题"><a href="#jvm面试问题" class="header-anchor">#</a> JVM面试问题</h1> <h2 id="jvm的内存模型"><a href="#jvm的内存模型" class="header-anchor">#</a> JVM的内存模型</h2> <img src="/zhuangxiaoyan/interview/jvm.png" alt="jvm"> <ul><li>线程独占：<strong>栈,本地方法栈,程序计数器</strong></li> <li>线程共享：<strong>堆,方法区</strong></li></ul> <ol><li><strong>栈</strong>：又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法 出口等信息.调用方法时执行入栈,方法返回式执行出栈。</li> <li><strong>堆</strong>：JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行和管理。</li> <li><strong>方法区</strong>：又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据1.7的永久代和1.8的元空间都是方法区的一种实现。</li> <li><strong>本地方法栈</strong>：与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈。</li> <li><strong>程序计数器</strong>：保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行 Native方法时,程序计数器为空。</li></ol> <h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="header-anchor">#</a> 堆和栈的区别</h2> <ul><li><strong>栈由操作系统自动分配释放 ，存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈</strong>。</li> <li><strong>堆由程序员分配释放，若程序员不释放，程序结束时由OS回收，分配方式倒是类似于链表</strong>。</li></ul> <ol><li>管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</li> <li>空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小64bits的Windows默认1M，64bits的Linux默认10M；</li> <li>生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</li> <li>分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</li> <li>分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</li> <li>栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。 堆（heap）：用于存储对象。</li></ol> <h2 id="jvm的异常与解决方法"><a href="#jvm的异常与解决方法" class="header-anchor">#</a> JVM的异常与解决方法</h2> <p>栈溢出原因就是方法执行时创建的栈帧超过了栈的深度。最有可能的就是方法递归调用产生这种结果。</p> <p><strong>堆内存不足:这种场景最为常见，报错信息：<code>java.lang.OutOfMemoryError: Java heap space</code></strong></p> <p><strong>原因:</strong></p> <ul><li>代码中可能存在大对象分配。</li> <li>可能存在内存泄露，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。</li></ul> <p><strong>解决方法</strong></p> <ul><li>检查是否存在大对象的分配，最有可能的是大数组分配。</li> <li>通过jmap命令，把堆内存dump下来，使用mat工具分析一下，检查是否存在内存泄露的问题。</li> <li>如果没有找到明显的内存泄露，使用-Xmx加大堆内存。</li> <li>还有一点容易被忽略，检查是否有大量的自定义的 Finalizable对象，也有可能是框架内部提供的，考虑其存在的必要性。</li></ul> <p><strong>永久代/元空间溢出 报错信息：<code>java.lang.OutOfMemoryError: PermGen space</code></strong></p> <p><strong>原因</strong></p> <ul><li>永久代是 HotSot 虚拟机对方法区的具体实现，存放了被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等。</li> <li>JDK8后，元空间替换了永久代，元空间使用的是本地内存，还有其它细节变化：字符串常量由永久代转移到堆中,和永久代相关的JVM参数已移除.</li> <li>在Java7之前，频繁的错误使用String.intern方法.</li> <li>生成了大量的代理类，导致方法区被撑爆，无法卸载.</li> <li>应用长时间运行，没有重启.</li></ul> <p><strong>解决方法</strong></p> <ul><li>检查是否永久代空间或者元空间设置的过小</li> <li>检查代码中是否存在大量的反射操作</li> <li>dump之后通过mat检查是否存在大量由于反射生成的代理类</li> <li>放大招，重启JVM</li></ul> <p><strong>GC overhead limit exceeded 报错信息：<code>java.lang.OutOfMemoryError：GC overhead limit exceeded</code></strong></p> <p><strong>原因</strong></p> <ol><li>这个是JDK6新加的错误类型，一般都是堆太小导致的。</li> <li>Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。</li></ol> <p><strong>解决方法</strong></p> <ol><li>检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。</li> <li>添加参数-XX:-UseGCOverheadLimit 禁用这个检查，其实这个参数解决不了内存问题，只是把错误的信息延后，最终出现 java.lang.OutOfMemoryError: Java heap space。</li> <li>dump内存，检查是否存在内存泄露，如果没有，加大内存。</li></ol> <p><strong>方法栈溢出 报错信息：<code>java.lang.OutOfMemoryError : unable to create new native Thread</code></strong></p> <p><strong>原因</strong></p> <ul><li>出现这种异常，基本上都是创建的了大量的线程导致的，以前碰到过一次，通过jstack出来一共8000多个线程。</li></ul> <p><strong>解决方法</strong></p> <ul><li>通过-Xss降低的每个线程栈大小的容量</li> <li>线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：
<ul><li>/proc/sys/kernel/pid_max</li> <li>/proc/sys/kernel/thread-max</li> <li>max_user_process（ulimit -u）</li> <li>/proc/sys/vm/max_map_count</li></ul></li></ul> <p><strong>分配超大数组  报错信息: <code>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code></strong></p> <ul><li>这种情况一般是由于不合理的数组分配请求导致的，在为数组分配内存之前，JVM 会执行一项检查。要分配的数组在该平台是否可以寻址(addressable)， 如果不能寻址(addressable)就会抛出这个错误。</li> <li>解决方法就是检查你的代码中是否有创建超大数组的地方。</li></ul> <p><strong>swap区溢出 报错信息: <code>java.lang.OutOfMemoryError: Out of swap space</code></strong></p> <p><strong>这种情况一般是操作系统导致的</strong></p> <ul><li>swap 分区大小分配不足；</li> <li>其他进程消耗了所有的内存。</li></ul> <p><strong>解决方案</strong></p> <ul><li>其它服务进程可以选择性的拆分出去</li> <li>加大swap分区大小，或者加大机器内存大小</li></ul> <p><strong>本地方法溢出 报错信息:<code>java.lang.OutOfMemoryError: stack_trace_with_native_method</code></strong></p> <p>本地方法在运行时出现了内存分配失败，和之前的方法栈溢出不同，方法栈溢出发生在JVM代码层面，而本地方法溢出发生在JNI代码或本地方法处。
这个异常出现的概率极低，就算出现，只能通过操作系统本地工具进行诊断，难度有点大，还是放弃为妙。</p> <p><strong>遇到过元空间溢出吗?</strong></p> <p>元空间（Metaspace）默认是没有上限的，不加限制比较危险。当应用中的Java类过多，比如Spring等一些使用动态代理的框架生成了很多类，
如果占用空间超出了我们的设定值，就会发生元空间溢出。所以，默认风险大，但如果你不给足它空间，它也会溢出。</p> <p><strong>遇到过堆外内存溢出吗?</strong></p> <p>使用了Unsafe类申请内存，或者使用了JNI对内存进行操作。这部分内存是不受JVM控制的，不加限制的使用，容易发生内存溢出。</p> <p><strong>JVM的永久代中会发生垃圾回收么</strong></p> <ul><li>Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等.</li> <li>而1.7以前的jdk采用的是永久代作为方法区的实现，在1.7及以前的jdk版本，永久代的空间不足也会导致fullGC，1.7以前，永久代空间如果设小了，就会触发整个堆的一次full GC（注意是触发堆的full GC），经过这样的一次定位就初步定位到了是由于永久代空间不足导致了堆的full GC。</li> <li>所以垃圾回收会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如 果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小 对避免Full GC是非常重要的原因。</li> <li>但是在1.8以后由于改成了元空间，它的垃圾回收就不是由java来控制了，元空间的默认情况下内存空间是使用的操作系统的内存空间，所以空间的容量是比较充裕的，发生OOMM的概率较小，但是也有可能发生。</li></ul> <h2 id="jvm中对象分配规则"><a href="#jvm中对象分配规则" class="header-anchor">#</a> JVM中对象分配规则</h2> <ol><li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li> <li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li> <li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到 阀值对象进入老年区。</li> <li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一 半，年龄大于或等于该年龄的对象可以直接进入老年代。</li> <li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如 果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设 置，如果true则只进行Monitor GC,如果false则进行Full GC。</li></ol> <p><strong>对象的优先分配在年轻代？ 不是。当新生代内存不够时，老年代分配担保。而大对象则是直接在老年代分配。</strong></p> <h2 id="对象内存布局"><a href="#对象内存布局" class="header-anchor">#</a> 对象内存布局</h2> <img src="/zhuangxiaoyan/interview/object-header.png" alt="object-header"> <p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p> <ol><li><strong>对象头占 12B</strong>，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如<strong>哈希码、GC 分代年龄、锁标志、偏向线程 ID</strong> 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。类型指针是对象指向它的类型元数据的指针，占 4B。JVM 通过该指针来确定对象是哪个类的实例。</li> <li><strong>实例数据是对象真正存储的有效信息</strong>，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。</li> <li><strong>对齐填充不是必然存在的</strong>，仅起占位符作用。虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。</li></ol> <h2 id="java对象创建过程"><a href="#java对象创建过程" class="header-anchor">#</a> Java对象创建过程</h2> <img src="/zhuangxiaoyan/interview/object-create.png" alt="object-create"> <ol><li><strong>检查类是否已经被加载</strong>：new关键字时创建对象时，首先会去运行时常量池中查找该引用所指向的类有没有被虚拟机加载，如果没有被加载，那么会进行类的加载过程。类的加载过程需要经历：<strong>加载、链接、初始化</strong>三个阶段。</li> <li><strong>为对象分配内存空间</strong>： 此时，对象所属类已经加载，现在需要在堆内存中为该对象分配一定的空间，该空间的大小在类加载完成时就已经确定下来了。为对象分配内存空间有两种方式：
<ul><li>第一种jvm将堆区抽象为两块区域，一块是已经被其他对象占用的区域，另一块是空白区域，中间通过一个指针进行标注，这时只需要将指针向空白区域移动相应大小空间，就完成了内存的分配，当然这种划分的方式要求虚拟机的对内存是地址连续的，且虚拟机带有内存压缩机制，可以在内存分配完成时压缩内存，形成连续地址空间，这种分配内存方式成为“指针碰撞”，但是很明显，这种方式也存在一个比较严重的问题，那就是多线程创建对象时，会导致指针划分不一致的问题，例如A线程刚刚将指针移动到新位置，但是B线程之前读取到的是指针之前的位置，这样划分内存时就出现不一致的问题，解决这种问题，虚拟机采用了循环CAS操作来保证内存的正确划分。</li> <li>第二种也是为了解决第一种分配方式的不足而创建的方式，多线程分配内存时，虚拟机为每个线程分配了不同的空间，这样每个线程在分配内存时只是在自己的空间中操作，从而避免了上述问题，不需要同步。当然，当线程自己的空间用完了才需要需申请空间，这时候需要进行同步锁定。为每个线程分配的空间称为“本地线程分配缓冲（TLAB）”,是否启用TLAB需要通过 -XX:+/-UseTLAB参数来设定。</li></ul></li> <li><strong>为对象的字段赋默认值</strong>：分配完内存后，需要对对象的字段进行零值初始化（赋默认值），对象头除外。 值初始化意思就是对对象的字段赋0值，或者null值，这也就解释了为什么这些字段在不需要进程初始化时候就能直接使用。</li> <li><strong>设置对象头</strong>：对这个将要创建出来的对象，进行信息标记，包括是否为新生代/老年代，对象的哈希码，元数据信息，这些标记存放在对象头信息中。</li> <li><strong>执行实例的初始化方法init</strong>：linit方法包含成员变量、构造代码块的初始化，按照声明的顺序执行。</li> <li><strong>执行构造方法</strong>：执行对象的构造方法。至此，对象创建成功。</li></ol> <h2 id="jvm堆中的新生代"><a href="#jvm堆中的新生代" class="header-anchor">#</a> jvm堆中的新生代</h2> <p>新生代用来存放新生的对象，新生代中的对象朝生夕死，所以会频繁的触发 minor （脉了）GC 进行垃圾回收。新生代分为 eden 区、survivor from 区和 survivor to 区。
eden区是java新对象的出生地，如果新创建的对象占用内存很大的话就会直接分配到老年代。当eden区的内存不足时就会触发 minor gc 对新生代进行一次垃圾回收。
survivor from 区存放的是上一次minor gc 的幸存者，它将作为这一次gc的被扫描者。survivor to 区会保留这一次gc的幸存者。</p> <p>新生代 minor gc 的流程是：<strong>它采用的复制算法</strong>，首先eden区和survivor from区中存活的对象复制到survivor to区域，
并将它们的年龄加一。然后清空eden区和survivor from区中的对象，接着将survivor from和survivor to互换，
也就是原先的survivor to成为下一次gc时的survivor from。（这样要注意的是，如果有对象的年龄达到了老年代的标准，
就放进老年代；如果survivor to区域的空间不够的话，就会通过分配担保机制，将多出来的对象提前转到老年代，
但老年代要进行担保的前提是自己本身还有容纳这些对象的剩余空间，由于无法提前知道会有多少对象存活下来，
所以这里是取之前每次晋升到老年代的对象的平均大小作为经验值，与老年代的剩余空间做比较）</p> <h2 id="jvm堆中的老生代"><a href="#jvm堆中的老生代" class="header-anchor">#</a> jvm堆中的老生代</h2> <p>老年代主要存放生命周期较长的内存对象，所以不会频繁的进行垃圾回收。<strong>老年代采用的是标记清除算法</strong>，也就是首先扫描一次老年代，标记出存活对象，然后回收没有标记的对象。</p> <p>java8之前，jvm堆中还有一块称作永久代的区域，主要存放class和元数据的信息，class被加载的时候就会被放入永久代，gc不会在主程序运行期间对永久代进行清理，
这样会导致一个问题，就是永久代区域会随着加载的class的增多而胀满，最终抛出OOM异常。</p> <p>java8移除了永久代，取而代之的是一个叫做元数据区的概念，也叫做元空间。元空间和永久代是类似的，但它们最大的区别是元空间并不在虚拟机中，
而是使用的本地内存，因此默认情况下，元空间的大小仅受本地内存的限制。也就是类的元数据放入本地内存中，字符串池和类的静态变量放入java堆中，
这样可以加载多少类的元数据就由系统实际可用空间来控制了。</p> <h2 id="永久代和元空间"><a href="#永久代和元空间" class="header-anchor">#</a> 永久代和元空间</h2> <p>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，
<strong>元空间与永久代之间最大的区别在于:元空间并不在虚拟机中，而是使用本地内存。因此， 默认情况下，元空间的大小仅受本地内存限制。</strong>
类的元数据放入nativememory, 字符串池和类的静态变量放入java堆中， 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。</p> <ol><li>永久代和元空间的作用都是存储类的元数据，<strong>用来存储class相关信息，包括class对象的Method，Field等</strong>。</li> <li>永久代和元空间的区别本质只有一个，就是永久代使用的是JVM内存存储，元空间使用的是本地内存存储。</li></ol> <h2 id="什么要废除永久代"><a href="#什么要废除永久代" class="header-anchor">#</a> 什么要废除永久代</h2> <ol><li>由于<strong>永久代内存经常不够用或者发生内存泄露</strong>，爆出异常java.lang.OutOfMemoryError: PermGen 。</li> <li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li> <li><strong>永久代会位GC带来不必要的复杂度，而且回收效率偏低</strong>。</li></ol> <h2 id="什么情况会造成元空间溢出"><a href="#什么情况会造成元空间溢出" class="header-anchor">#</a> 什么情况会造成元空间溢出？</h2> <ol><li>JDK8后，元空间替换了永久代，元空间使用的是本地内存，还有其它细节变化：字符串常量由永久代转移到堆中,和永久代相关的JVM参数已移除.</li> <li>在Java7之前，频繁的错误使用String.intern方法.</li> <li>生成了大量的代理类，导致方法区被撑爆，无法卸载.</li> <li>应用长时间运行，没有重启.</li></ol> <h2 id="永久代-元空间溢出的解决方法"><a href="#永久代-元空间溢出的解决方法" class="header-anchor">#</a> 永久代/元空间溢出的解决方法</h2> <ol><li>检查是否永久代空间或者元空间设置的过小</li> <li>检查代码中是否存在大量的反射操作</li> <li>dump之后通过mat检查是否存在大量由于反射生成的代理类</li> <li>放大招，重启JVM</li></ol> <h2 id="对象是怎么从年轻代进入老年代的"><a href="#对象是怎么从年轻代进入老年代的" class="header-anchor">#</a> 对象是怎么从年轻代进入老年代的？</h2> <ol><li><strong>占用内存较大的对象，直接进入老年代</strong>，这个“大”由参数-XX:PretenureSizeThreshold来决定，超过这个参数设置的值就直接进入老年代，例如很长的字符串、很大的数组。</li> <li><strong>正常创建一个对象，对象内存布局</strong>，包含三部分信息（对象头、实例数据、对齐数据），对象头中存储的就是两部分信息，一部分是对象的运行时数据（GC年龄、锁信息等），
一部分是类型指针，GC年龄在对象初始化时为1，每经过一次minorGC年龄增1，达到系统设置XX:MaxTenuringThreshold年龄值之后，进入老年代。
当一个对象从Eden区到了Survivor区**，当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，
年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄</li></ol> <h2 id="jvm中class文件加载原理"><a href="#jvm中class文件加载原理" class="header-anchor">#</a> JVM中class文件加载原理</h2> <p><strong>类加载有几个过程：加载、验证、准备、解析、初始化。</strong></p> <p>当 Java程序需要使用某个类时，JVM会确保这个类已经被<strong>加载、连接（验证、准备和解析）和初始化</strong>。
类的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，
然后 产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。
当类被加载后就进入连接阶段，这一阶段 包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。
最后 JVM 对类进行初始化，包括：</p> <ol><li>如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；</li> <li>如果类中存在初始化语句，就依次执行这些初始化语句。</li></ol> <h2 id="jvm类加载器类型"><a href="#jvm类加载器类型" class="header-anchor">#</a> JVM类加载器类型</h2> <img src="/zhuangxiaoyan/interview/ClassLoader.png" alt="ClassLoader"> <ol><li>启动类加载器（Bootstrp ClassLoader），加载 /lib/rt.jar、-Xbootclasspath。</li> <li>扩展类加载器（Extension ClassLoader）sun.misc.Launcher$ExtClassLoader，加载 /lib/ext、java.ext.dirs。</li> <li>应用程序类加载器（Application ClassLoader，sun.misc.Launcher$AppClassLoader），加载 CLASSPTH、-classpath、-cp、Manifest。</li> <li>自定义类加载器（user ClassLoader）。</li></ol> <h2 id="jvm类加载为什么要使用双亲委派模式"><a href="#jvm类加载为什么要使用双亲委派模式" class="header-anchor">#</a> jVM类加载为什么要使用双亲委派模式</h2> <p>**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。**假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。
现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。然而幸运的是，双亲委托模型不会让他成功。
因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它。</p> <h2 id="java的类加载是否一定遵循双亲委托模型"><a href="#java的类加载是否一定遵循双亲委托模型" class="header-anchor">#</a> Java的类加载是否一定遵循双亲委托模型？</h2> <ol><li>在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。</li> <li>SPI就是打破了双亲委托机制的(SPI：服务提供发现)。</li></ol> <h2 id="判断对象是否为垃圾"><a href="#判断对象是否为垃圾" class="header-anchor">#</a> 判断对象是否为垃圾</h2> <p><strong>引用计数器</strong>: 也就是为每一个对象添加一个引用计数器，用来统计指向当前对象的引用次数，如果当前对象存在应用的更新，那么就对这个引用计数器进行增加，
一旦这个引用计数器变成0，就意味着它可以被回收了。这种方法需要额外的空间来存储引用计数器，但是它的实现很简单，而且效率也比较高。
不过主流的JVM都没有采用这种方式，因为引用计数器在处理一些复杂的循环引用或者相互依赖的情况时，
可能会出现一些不再使用但是又无法回收的内存，造成内存泄露的问题。</p> <p><strong>可达性分析</strong>，<strong>可达性分析是目前主流JVM使用的算法</strong>。它的主要思想是，首先确定一系列肯定不能回收的对象作为GC root，比如虚拟机栈里面的引用对象、
本地方法栈引用的对象等，然后以GC ROOT作为起始节点，从这些节点开始向下搜索，去寻找它的直接和间接引用的对象，当遍历完之后如果发现有一些对象不可到达，
那么就认为这些对象已经没有用了，需要被回收。在垃圾回收的时候，JVM会首先找到所有的GC root，这个过程会暂停所有用户线程，
也就是stop the world，然后再从GC Roots这些根节点向下搜索，可达的对象保留，不可达的就会回收掉。</p> <h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="header-anchor">#</a> 垃圾回收算法</h2> <p><strong>标记清除算法（ Mark-Sweep）</strong>：最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，
清除阶段 回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</p> <p><strong>复制算法（copying）</strong>：为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。
每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</p> <p><strong>标记整理算法(Mark-Compact)</strong>：结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，
标记后不是清理对 象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</p> <p><strong>分代收集算法</strong>：<strong>分代收集法是目前大部分JVM所采用的方法</strong>，其核心思想是根据对象存活的不同生命周期将内存划分为 不同的域，
一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。
老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次 垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p> <img src="/zhuangxiaoyan/interview/GC.png" alt="GC"> <h2 id="新生代的算法实现"><a href="#新生代的算法实现" class="header-anchor">#</a> 新生代的算法实现</h2> <p><strong>新生代主要使用复制算法</strong>：目前大部分JVM的GC对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，
但通常并不是按照1:1来划分新生代。一般将新生代划分为一块较大 的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，
每次使用Eden 空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另一块Survivor空间中。</p> <h2 id="老年代的算法实现"><a href="#老年代的算法实现" class="header-anchor">#</a> 老年代的算法实现</h2> <p><strong>老年代与标记复制算法</strong>：而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。</p> <ol><li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量， 方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li> <li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存 放对象的那一块)，少数情况会直接分配到老生代。</li> <li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。</li> <li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li> <li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li> <li>当对象在 Survivor 区躲过一次GC 后，其年龄就会+1。 默认情况下年龄到达 15 的对象会被移到 老生代中。</li></ol> <h2 id="minorgc-majorgc、fullgc都什么时候发生"><a href="#minorgc-majorgc、fullgc都什么时候发生" class="header-anchor">#</a> MinorGC，MajorGC、FullGC都什么时候发生？</h2> <ol><li>Minor GC：发生在年轻代的 GC。当Eden区满时，触发Minor GC。</li> <li>Major GC：发生在老年代的 GC。</li> <li>Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。</li></ol> <h2 id="fullgc的发生条件"><a href="#fullgc的发生条件" class="header-anchor">#</a> FullGC的发生条件</h2> <ol><li><strong>System.gc()方法的调用</strong>。此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI（Java远程方法调用）调用System.gc。</li> <li><strong>老年代空间不足</strong>。 老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</li> <li><strong>Permanet Generation空间满了</strong>。Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：java.lang.OutOfMemoryError: PermGen space 。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</li> <li><strong>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</strong></li> <li><strong>由Eden区、From Space区向To Space区复制时</strong>，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代可用内存不足(老年代可用内存小于该对象)</li></ol> <h2 id="垃圾分代收集的过程"><a href="#垃圾分代收集的过程" class="header-anchor">#</a> 垃圾分代收集的过程？</h2> <img src="/zhuangxiaoyan/interview/headp.png" alt="headp"> <p>堆内存分为新生代和老年代，新生代默认占总空间的1/3，老年代默认占2/3。新生代使用复制算法，有3个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。</p> <p>当新生代中的Eden区内存不足时，就会触发MinorGC，过程如下：</p> <ol><li>在Eden区执行了第一次 GC 之后，存活的对象会被移动到其中一个Survivor 分区；</li> <li>Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理，存活的对象会被复制到 to 区；</li> <li>移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代</li> <li>Survivor 区相同年龄所有对象大小的总和 (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 -XX:TargetSurvivorRatio 指定，默认为 50%</li> <li>Survivor 区内存不足会发生担保分配</li> <li>超过指定大小的对象可以直接进入老年代</li></ol> <p>Major GC，指的是老年代的垃圾清理，但并未找到明确说明何时在进行Major GC</p> <p>FullGC，整个堆的垃圾收集，触发条件：</p> <ol><li>每次晋升到老年代的对象平均大小&gt;老年代剩余空间。</li> <li>MinorGC后存活的对象超过了老年代剩余空间。</li> <li>元空间不足。</li> <li>System.gc() 可能会引起。</li> <li>CMS GC异常，promotion failed:MinorGC时，survivor空间放不下，对象只能放入老年代，而老年代也放不下造成；concurrent mode failure:GC时，同时有对象要放入老年代，而老年代空间不足造成</li> <li>堆内存分配很大的对象。</li></ol> <h2 id="垃圾回收器的类型"><a href="#垃圾回收器的类型" class="header-anchor">#</a> 垃圾回收器的类型</h2> <p>GC算法（引用计数/复制/标清/标整）是内存回收的方法论，垃圾收集器就是算法落地实现。因为目前为止还没有完美的收集器出现，
更加没有万能的收集器，只是针对巨日应用最合适的收集器，进行分代收集。主要的垃圾收集器：</p> <ol><li><strong>串行垃圾回收器（Serial）</strong>: 它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器环境</li> <li><strong>并行垃圾回收器（Parallel）</strong>: 多个垃圾收集线程并行工作，此时用户线程是暂停的,适用于科学计算/大数据处理首台处理等弱交互场景。</li> <li><strong>并发垃圾回收器（CMS）</strong>: 用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程。互联网公司多用它，适用对响应时间有要求的场景（强交互的环境）</li> <li><strong>G1垃圾回收器</strong>: 将堆内存分割成不同的区域，然后并发的对其进行垃圾回收</li></ol> <h2 id="cms垃圾回收期的工作原理"><a href="#cms垃圾回收期的工作原理" class="header-anchor">#</a> CMS垃圾回收期的工作原理</h2> <ol><li>初始标记</li> <li>并发标记</li> <li>并发预清理</li> <li>并发可取消的预清理</li> <li>重新标记</li> <li>并发清理</li></ol> <h2 id="cms都有哪些问题"><a href="#cms都有哪些问题" class="header-anchor">#</a> CMS都有哪些问题?</h2> <ol><li>内存碎片问题。Full GC的整理阶段，会造成较长时间的停顿。</li> <li>需要预留空间，用来分配收集阶段产生的“浮动垃圾“。</li> <li>使用更多的CPU资源，在应用运行的同时进行堆扫描。</li> <li>停顿时间是不可预期的。</li></ol> <h2 id="zgc垃圾收集器原理"><a href="#zgc垃圾收集器原理" class="header-anchor">#</a> ZGC垃圾收集器原理</h2> <p>JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。
基于Region内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理，以低延迟为首要目标。ZGC的 Region 具有动态性，
是动态创建和销毁的，并且容量大小也是动态变化的。</p> <h2 id="jvm四大引用作用"><a href="#jvm四大引用作用" class="header-anchor">#</a> JVM四大引用作用</h2> <ol><li><strong>JAVA强引用</strong>：在Java中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。<strong>当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一</strong>。<strong>我们平时申明变量使用的就是强引用</strong>，普通系统99%以上都是强引用，比如，<code>String s=＂Hello World＂</code></li> <li><strong>JAVA软引用</strong>： 软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中 。<strong>软引用的主要场景是:内存中不重要的数据缓存</strong> <code>String str = new String(&quot;xxx&quot;);</code> <code>SoftReference&lt;String&gt; softStr = new SoftReference&lt;String&gt;(str);</code> <code>str = null;</code> <code>softStr.get();</code></li> <li><strong>JAVA弱引用</strong>：弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。Hashmap的使用就是一种的弱引用，</li> <li><strong>JAVA虚引用</strong>：虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。<strong>虚引用来做finalize不一定能做到的事</strong></li></ol> <h2 id="逃逸分析"><a href="#逃逸分析" class="header-anchor">#</a> 逃逸分析</h2> <p><strong>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化</strong>。
完成这个任务的编译器，就称为即时编译器（Just In Time Compiler），简称 JIT 编译器。</p> <h2 id="指令重排序"><a href="#指令重排序" class="header-anchor">#</a> 指令重排序？</h2> <p>指令重排：为了提高性能，编译器和和处理器通常会对指令进行指令重排序。</p> <img src="/zhuangxiaoyan/interview/jvm001.png" alt="jvm001"> <p>图中的三个重排位置可以调换的，根据系统优化需要进行重排。遵循的原则是单线程重排后的执行结果要与顺序执行结果相同。
内存屏障指令：volatile在指令之间插入内存屏障，保证按照特定顺序执行和某些变量的可见性。volatile就是通过内存屏障通知cpu和编译器不做指令重排优化来维持有序性。</p> <h2 id="你能保证gc执行吗"><a href="#你能保证gc执行吗" class="header-anchor">#</a> 你能保证GC执行吗</h2> <p>不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC的执行。</p> <h2 id="safepoint是什么"><a href="#safepoint是什么" class="header-anchor">#</a> safepoint是什么？</h2> <p>STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，
这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。 如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。</p> <h2 id="swap会影响性能么"><a href="#swap会影响性能么" class="header-anchor">#</a> SWAP会影响性能么?</h2> <p>当操作系统内存不足的时候，会将部分数据写入到SWAP交换分中，但是SWAP的性能是比较低的。如果应用的访问量较大，需要频繁申请和销毁内存，就容易发生卡顿。一般高并发场景下，会禁用SWAP。</p> <h2 id="jvm-配置参数有哪些"><a href="#jvm-配置参数有哪些" class="header-anchor">#</a> JVM 配置参数有哪些？</h2> <p><strong>日志</strong></p> <ol><li>-XX:+PrintFlagsFinal，打印JVM所有参数的值</li> <li>-XX:+PrintGC，打印GC信息</li> <li>-XX:+PrintGCDetails，打印GC详细信息</li> <li>-XX:+PrintGCTimeStamps，打印GC的时间戳</li> <li>-Xloggc:filename，设置GC log文件的位置</li> <li>-XX:+PrintTenuringDistribution，查看熬过收集后剩余对象的年龄分布信息</li></ol> <p><strong>内存设置</strong></p> <ol><li>-Xms，设置堆的初始化内存大小</li> <li>-Xmx，设置堆的最大内存</li> <li>-Xmn，设置新生代内存大小</li> <li>-Xss，设置线程栈大小</li> <li>-XX:NewRatio，新生代与老年代比值</li> <li>-XX:SurvivorRatio，新生代中Eden区与两个Survivor区的比值，默认为8，即Eden:Survivor:Survivor=8:1:1</li> <li>-XX:MaxTenuringThreshold，从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15</li> <li>-XX:MetaspaceSize，设置元空间的大小，第一次超过将触发 GC</li> <li>-XX:MaxMetaspaceSize，元空间最大值</li> <li>-XX:MaxDirectMemorySize，用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存</li> <li>-XX:ReservedCodeCacheSize，用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可</li></ol> <p><strong>设置垃圾收集相关</strong></p> <ol><li>-XX:+UseSerialGC，设置串行收集器</li> <li>-XX:+UseParallelGC，设置并行收集器</li> <li>-XX:+UseConcMarkSweepGC，使用CMS收集器</li> <li>-XX:ParallelGCThreads，设置Parallel GC的线程数</li> <li>-XX:MaxGCPauseMillis，GC最大暂停时间 ms</li> <li>-XX:+UseG1GC，使用G1垃圾收集器</li></ol> <p><strong>CMS 垃圾回收器相关</strong></p> <ol><li>-XX:+UseCMSInitiatingOccupancyOnly。</li> <li>-XX:CMSInitiatingOccupancyFraction，与前者配合使用，指定MajorGC的发生时机。</li> <li>-XX:+ExplicitGCInvokesConcurrent，代码调用 System.gc() 开始并行 FullGC，建议加上这个参数。</li> <li>-XX:+CMSScavengeBeforeRemark，表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上。</li> <li>-XX:+ParallelRefProcEnabled，可以用来并行处理 Reference，以加快处理速度，缩短耗时。</li></ol> <p><strong>G1 垃圾回收器相关</strong></p> <ol><li>-XX:MaxGCPauseMillis，用于设置目标停顿时间，G1 会尽力达成。</li> <li>-XX:G1HeapRegionSize，用于设置小堆区大小，建议保持默认。</li> <li>-XX:InitiatingHeapOccupancyPercent，表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动。</li> <li>-XX:ConcGCThreads，表示并发垃圾收集器使用的线程数量，默认值随JVM运行的平台不同而变动，不建议修改。</li></ol> <h2 id="jvm-提供的常用工具"><a href="#jvm-提供的常用工具" class="header-anchor">#</a> JVM 提供的常用工具</h2> <ol><li><strong>jps</strong>：用来显示本地的 Java 进程，可以查看本地运行着几个 Java 程序，并显示他们的进程号。 命令格式：jps</li> <li><strong>jinfo</strong>：运行环境参数：Java System 属性和 JVM 命令行参数，Java class path 等信息。 命令格式：jinfo 进程 pid</li> <li><strong>jstat</strong>：监视虚拟机各种运行状态信息的命令行工具。 命令格式：jstat -gc 123 250 20</li> <li><strong>jstack</strong>：可以观察到 JVM 中当前所有线程的运行情况和线程当前状态。 命令格式：jstack 进程 pid</li> <li><strong>jmap</strong>：观察运行中的 JVM 物理内存的占用情况（如：产生哪些对象，及其数量）。 命令格式：jmap [option] pid</li></ol> <h2 id="invokedynamic指令是干什么的"><a href="#invokedynamic指令是干什么的" class="header-anchor">#</a> invokedynamic指令是干什么的？</h2> <p>invokedynamic是Java7之后新加入的字节码指令，使用它可以实现一些动态类型语言的功能。我们使用的Lambda表达式，在字节码上就是invokedynamic指令实现的。
它的功能有点类似反射，但它是使用方法句柄实现的，执行效率更高。</p> <h2 id="能够找到reference-chain的对象-就一定会存活么"><a href="#能够找到reference-chain的对象-就一定会存活么" class="header-anchor">#</a> 能够找到Reference Chain的对象，就一定会存活么？</h2> <p>JVM判断对象是否是垃圾采用的是可达性分析算法，通过 GC Roots 来判定对象存活，从GC Roots向下追溯、搜索，会产生一个叫做 Reference Chain 的链条，
但是能够找到 Reference Chain 的对象却不一定会存活，还得考虑到对象的引用类型，比如如果对象是软引用类型，那么在堆内存不足时，
该对象就会在GC时被回收，而如果对象是弱引用类型，那么只要发生了GC，该对象就会被回收。 因此能够找到 Reference Chain 的对象，不一定会存活，
但是找不到 Reference Chain 的对象，就一定会被回收。</p> <h2 id="cpu过高解决方案"><a href="#cpu过高解决方案" class="header-anchor">#</a> CPU过高解决方案</h2> <ol><li>CAS:限制CAS的次数。</li> <li>程序破除死循环。</li> <li>系统修改频繁的进行Full GC。</li> <li>云服务器被黑客攻击，端口不能够被外网访问，建议Redis部署在内网，不要公开在外网。</li> <li>服务器被DDOS攻击:限流、ip黑名单、图形验证码。</li></ol> <h2 id="cpu过高排查流程"><a href="#cpu过高排查流程" class="header-anchor">#</a> CPU过高排查流程</h2> <ol><li>先用top命令找出cpu占比最高的。</li> <li>ps -ef或者jps进一步定位，得知是一个怎样的后台程序的问题。</li> <li>ps -mp 进程 -o THREAD,tid,time 定位到具体的线程或者代码。</li> <li>将需要的线程id转化成16进制格式（英文小写格式）。</li> <li>jstack 进程id | grep tid（十六进制线程id英文小写） -A60。</li> <li>利用的Arthas工具排查。</li></ol> <h2 id="oom问题排查"><a href="#oom问题排查" class="header-anchor">#</a> OOM问题排查</h2> <p>oom就是我们常说的内存溢出，它是指需要的内存空间大于系统分配的内存空间，oom后果就是项目程序crash;</p> <ol><li>请求创建一个超大对象，通常是一个大数组。（所以尽量根据自己的实际需要去初始化数组大小）</li> <li>超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。当流程突然很高是，由于提前没有对堆的内存空间做合理的准备，所以短时间内线程会创建大量的对象，这些对象可能会短时间内迅速的占满堆内存。</li> <li>用终结器（Finalizer），该对象没有立即被 GC。</li> <li>内存泄漏，大量的对象引用没有释放，GC没有办法对这些内存空间进行回收导致了内存泄漏的问题。</li></ol> <h2 id="gc-overhead-limit-exceeded错误"><a href="#gc-overhead-limit-exceeded错误" class="header-anchor">#</a> GC overhead limit exceeded错误</h2> <p>当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，
就会抛出 <code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>错误。简单地说，就是应用程序已经基本耗尽了所有可用内存，
GC 也无法回收。 此类问题的原因与解决方案跟 Java heap space非常类似</p> <h2 id="permgen-space错误"><a href="#permgen-space错误" class="header-anchor">#</a> Permgen space错误</h2> <p>该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。 永久代存储对象主要包括以下几类：</p> <ol><li>加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码；</li> <li>常量池；</li> <li>对象数组/类型数组所关联的 class；</li> <li>JIT 编译器优化后的 class 信息。 PermGen 的使用量与加载到内存的 class 的数量/大小正相关。</li></ol> <p>根据 Permgen space 报错的时机，可以采用不同的解决方案，如下所示：</p> <ol><li>程序启动报错，修改 -XX:MaxPermSize 启动参数，调大永久代空间。</li> <li>应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。</li> <li>运行时报错，应用程序可能会动态创建大量class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，
可以设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC 这两个参数允许 JVM 卸载 class。
如果上述方法无法解决，可以通过 jmap 命令dump内存对象 jmap-dump:format=b,file=dump.hprof ，然后利用MAT功能逐一分析开销最大的classloader 和重复class。</li></ol> <h2 id="metaspace错误"><a href="#metaspace错误" class="header-anchor">#</a> Metaspace错误</h2> <p>JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。
此类问题的原因与解决方法跟 Permgenspace 非常类似，可以参考上文。需要特别注意的是调整 Metaspace 空间大小的启动参数为 -XX:MaxMetaspaceSize。</p> <h2 id="unable-to-create-new-native-thread错误"><a href="#unable-to-create-new-native-thread错误" class="header-anchor">#</a> Unable to create new native thread错误</h2> <p>每个 Java 线程都需要占用一定的内存空间，当 JVM 向底层操作系统请求创建一个新的 native 线程时，如果没有足够的资源分配就会报此类错误。
JVM 向 OS 请求创建 native 线程失败，就会抛出 Unableto createnewnativethread，常见的原因包括以下几类：</p> <ol><li>线程数超过操作系统最大线程数 ulimit 限制；</li> <li>线程数超过 kernel.pid_max（只能重启）；</li> <li>native 内存不足；</li></ol> <p><strong>该问题发生的常见过程主要包括以下几步：</strong></p> <ol><li>JVM 内部的应用程序请求创建一个新的 Java 线程；</li> <li>JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程；</li> <li>操作系统尝试创建一个新的 native 线程，并为其分配内存；</li> <li>如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配；</li> <li>JVM 将抛出 java.lang.OutOfMemoryError:Unableto createnewnativethread错误。</li></ol> <p><strong>解决方案</strong></p> <ol><li>升级配置，为机器提供更多的内存；</li> <li>降低 Java Heap Space 大小；</li> <li>修复应用程序的线程泄漏问题；</li> <li>限制线程池大小；</li> <li>使用 -Xss 参数减少线程栈的大小；</li> <li>调高 OS 层面的线程最大数：执行 ulimia-a 查看最大线程数限制，使用 ulimit-u xxx 调整最大线程数限制。</li></ol> <h2 id="out-of-swap-space-错误"><a href="#out-of-swap-space-错误" class="header-anchor">#</a> Out of swap space 错误</h2> <p>该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。
当运行时程序请求的虚拟内存溢出时就会报Outof swap space错误。该错误出现的常见原因包括以下几类：</p> <ol><li>地址空间不足；</li> <li>物理内存已耗光；</li> <li>应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放。</li> <li>执行 jmap-histo:live 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。</li></ol> <p><strong>根据错误原因可以采取如下解决方案：</strong></p> <ol><li>升级地址空间为 64 bit；</li> <li>使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。</li> <li>Direct ByteBuffer 问题可以通过启动参数 -XX:MaxDirectMemorySize 调低阈值。</li> <li>升级服务器配置/隔离部署，避免争用。</li></ol> <h2 id="kill-process-or-sacrifice-child错误"><a href="#kill-process-or-sacrifice-child错误" class="header-anchor">#</a> Kill process or sacrifice child错误</h2> <p>不同于其他的 OOM 错误， Killprocessorsacrifice child 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。
默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。
然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。
此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。</p> <p><strong>解决方案</strong></p> <ol><li>升级服务器配置/隔离部署，避免争用。</li> <li>OOM Killer 调优。</li></ol> <h2 id="requested-array-size-exceeds-vm-limit错误"><a href="#requested-array-size-exceeds-vm-limit错误" class="header-anchor">#</a> Requested array size exceeds VM limit错误</h2> <p>JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。 JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，
通常为Integer.MAX_VALUE-2。 此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。</p> <h2 id="direct-buffer-memory错误"><a href="#direct-buffer-memory错误" class="header-anchor">#</a> Direct buffer memory错误</h2> <p>Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 Directbuffer memory 错误。</p> <p><strong>解决方案</strong></p> <ol><li>Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。</li> <li>检查是否直接或间接使用了 NIO，如 netty，jetty 等。</li> <li>通过启动参数 -XX:MaxDirectMemorySize 调整 Direct ByteBuffer 的上限值。</li> <li>检查 JVM 参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc() 失效。</li> <li>检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 sun.misc.Cleaner 的 clean() 方法来主动释放被 Direct ByteBuffer 持有的内存空间。</li> <li>内存容量确实不足，升级配置。</li></ol> <h2 id="hashmap存在内存泄露问题"><a href="#hashmap存在内存泄露问题" class="header-anchor">#</a> HashMap存在内存泄露问题</h2> <p>VM的垃圾回收实现原理,这个功能是java内存对象管理者的其中一个线程,用于释放内存中不在被使用的对像,其实现过程是依次遍历对象的索引将没有被其他对象应用的对象释放掉.
也就是java的垃圾回收只能释放那些没有被引用的对象空间,有很多程序在编写的时候运行很正常,但部署到服务器不久后就有内存溢出.</p> <p>那么集合在程序中造成内存溢出有两种原因:</p> <ol><li>集合装载的数据量过大,超出了JVM执行的内存范围,这个时候就有内存溢出.通常解决办法是分段读取数据量,减少内存在短时间内的开销,或者加大设 置JVM内存(默认是64M).</li> <li>集合在程序中被大循环调用,不断在内存中创建无法被垃圾回收机制回收的集合对象,当程序运行到一定时期时集合对象就会沾满内存,造成内存溢出.</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
    <span class="token comment">//定义一个静态变量</span>
    <span class="token keyword">static</span> <span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ages<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//无线循环调用test()方法</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//定义一个被循环调用的方法</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//i值一直在变</span>
        <span class="token comment">//定义一个HashMap集合</span>
        <span class="token class-name">HashMap</span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
         *在此hashMap集合并没有跟随该方法的运行结束而被释放.因为集合装载有一个静态常量
         *也就是集合中的元素被其他对象引用,所以垃圾回收机制不能回收hashMap对象
         *而在方法每次执行时都创建一个新的集合去装载一个新的静态元素&quot;i&quot;.
         *所以集合会被无限的循环创建对象存在内存中知道内存溢出
         *
         */</span>
        hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解决方案:</p> <ol><li>不要往集合中存入静态元素或者其他生命周期比集合生命周期还要长的元素.以至于使得GC能够回收释放.</li> <li>如果在大型的程序中,不能确确保集合要存入其他静态变量或者使集合不能在方法运行结束后跟着释放的元素,那么在集合被使用完成后调用clear()方法移除集合中所有元素,以便之后垃圾回收机制能回收释放.</li> <li>如果在程序中集合要被不断循环创建使用,那么就将该集合写成成员静态身份.防止在循环中不断创建出新的集合实例,同时也减少了程序在循环中不再去创建新集合实例时而消耗的资源.</li></ol> <h2 id="hashmap-hashset的内存泄漏问题"><a href="#hashmap-hashset的内存泄漏问题" class="header-anchor">#</a> hashmap hashset的内存泄漏问题</h2> <ul><li>HashMap 和 HashSet 内存泄漏的可能性是存在的，但是只有在使用不当的情况下才会发生。</li> <li>HashMap 和 HashSet 都是基于哈希表实现的，哈希表中的每个元素都有一个键和一个值，当键和值都不再被使用时，它们就会被垃圾回收器回收，从而避免内存泄漏。</li> <li>但是，如果在使用 HashMap 或 HashSet 时，存储的键和值都是引用类型，而且这些引用类型的对象还被其他地方引用，那么就可能会发生内存泄漏。这是因为垃圾回收器无法回收被其他地方引用的对象，从而导致内存泄漏。</li> <li>因此，为了避免 HashMap 和 HashSet 内存泄漏的可能性，应该尽量避免使用引用类型的键和值，或者在不再使用时及时将其置为 null，以便垃圾回收器可以回收它们。</li></ul> <h2 id="如果发生内存泄漏怎么排查"><a href="#如果发生内存泄漏怎么排查" class="header-anchor">#</a> 如果发生内存泄漏怎么排查</h2> <p>这个问题分为两个部分：1.什么是内存泄露以及会带来什么影响，2.内存泄露的排查和解决方法。</p> <p><strong>内存泄漏指</strong>的是在程序运行过程中，因为某些原因导致不需要使用的对象，仍然占用JVM的内存空间并且这块内存还无法被回收。
最终导致程序占用的内存越来越大从而出现OOM错误或者影响程序性能。一般情况下，除了OOM这种错误以外，</p> <p><strong>内存泄露会有一些比较明显的现象</strong>，比如频繁的Full GC； 内存占用量过大一直无法释放等。</p> <p><strong>内存泄露的排查</strong>，我一般会根据现象去定位问题。所以第一步，会先去定位是否是内存泄露，比如老年代逐步增长、fullGC卡顿、年轻代的内存一直在高位无法释放、频繁full gc等。</p> <p>这些现象基本上都是内存出现异常。要了解gc的情况，可以使用jstat命令，查看虚拟机中各个内存区域的使用情况和gc情况。
然后使用dump工具，把当前内存dump下来，然后使用MAT工具来分析。如果dump的文件比较大，可以使用轻量级的在线分析工具jmap。
MAT工具会自动分析dump文件的内容，给出一个分析结果并定位到有问题的类，然后去对这部分代码进行优化即可</p> <p><strong>一般可能是循环引用、内存对象泄露没有被销毁、动态分配内存以后未释放、长期持有对象引用、资源未关闭等。</strong></p> <h2 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="header-anchor">#</a> 如何破坏双亲委派模型？</h2> <p>我们自己写的java源文件到最终运行，必须要经过编译和类加载两个阶段。编译的过程就是把.java文件编译成.class文件。
类加载的过程，就是把class文件装载到JVM内存中，装载完成以后就会得到一个Class对象，我们就可以使用new关键字来实例化这个对象。</p> <p><img src="/zhuangxiaoyan/assets/img/jvm002.e0706d65.png" alt="img.png"></p> <p>而类的加载过程，需要涉及到类加载器。JVM在运行的时候，会产生3个类加载器，这三个类加载器组成了一个层级关系。每个类加载器分别去加载不同作用范围的jar包，比如:</p> <ol><li>Bootstrap ClassLoader，主要是负责Java核心类库的加载，也就是 %{JDK_HOME}\lib下的rt.jar、resources.jar等</li> <li>Extension ClassLoader，主要负责%{JDK_HOME}\lib\ext目录下的jar包和class文件</li> <li>Application ClassLoader，主要负责当前应用里面的classpath下的所有jar包和类文件</li> <li>除了系统自己提供的类加载器以外，还可以通过ClassLoader类实现自定义加载器，去满足一些特殊场景的需求。</li></ol> <p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEpCAIAAAAyGOMmAAAjuElEQVR4Xu2d36tcV/nG+xfktgpaShVR7wTBO8HeeNl7oS1eCQMKTS9aWm1ILowtWBMEqVDKSUSC0t4Ee2jTJKJ2CoUUNVo7KKdqWicX55R8NQfa0ov1ffd+Z97zznr2rDNrr0lm751n8eEwWXvtd/161zPvXnvPzl3hv9fD/00JIaT73IVZhBDSTShYhJDeQMEihPQGChYhpDdQsAghvYGCRQjpDRQsQkhvoGARQnoDBauMo0fC6C5CVkK8BV2I5EDBKgOdkpAE6EIkB45gGeiRhCRAFyI5cATLQI8kJAG6EMmBI1gGeiQhCdCFSA4cwTLQIzvO+PkwfTvOXMbp+8PuTtg+sZC59WD48H9hcrH6LIekgBQb1ZYlX44mzl2GWJPT7bNy4/2ZZUHabEnypRb5a2n1Hm0cdCGSA0ewDPTIjiMSIEvd1CHKt/TJx5XWNIqOiMXlU1UBMWKCJZ8lXTmXJ1hyVOz4JG3YGc/UUGyaZokkaZu1RqlFcrSuLAneOOhCJAeOYBnokR1E1WRZ8mFRxKGi4yOsQ88VGbKkgugPmYbKBxUsDyMsUsMRLAM9soM0SoCiK79RsLxGaNIrtUOTVueTypOpkmrZm2cXRGdZ0iCrMcLSGJAR1p0ER7AM9MgO0k6wRotRkqqVPyoyIZdv+3uVHqFk2LkqN1JFJFgWYUVh2qECZG3WyNFCs16ALkRy4AiWgR7ZQVa5JMQyKgooWFv1pnuolUIO3dytPthWlMnHKoKF8ZrYuXo+XHtr1mwNr7BtmPwOfZdBFyI5cATLQI/sIIkIK13Sx18iOnJI/vo9ryg42q430dXCKoI1qnVQL+7Mjl7uea30aANUIvsVWynoQiQHjmAZ6JEdRIMjDGc0WWyiyvLiIwe3Eb2O6C7SFDa2MFkgpmKXECwL1izJP6UBUl6CLLsw9JV6kfL56avI7oAuRHLgCJaBHtlBVGvsms6j4YxKkiiIXI7pB70o86eoEX/u6fpJiP29BrMjd0FnyoWCZYWjSE3DKIvjNMeSWvMb9n1RqxGXWykcwTLQI7uGqUNasHwcFOpI5+Xj1f6UyQoKluSoUkzrq8XIsmWuKFi6C6b1yl8VOxMyq11z7LJxtMImfadAFyI5cATLQI/sGhbppC8JTTJUZbSwyVAkMRrveJmIyo/dU+8mOr4B9qCDJQvHdItKFUoDQ6vRSjLCulPhCJaBHtk1LDZJR1hRvoUtJmQiEC89OpOJZQKhAiRxmd46HM/v7pkIJiIsyXnxkYOY7nR9vWnPlzLCIjUcwTLQIwlJgC5EcuAIloEeSUgCdCGSA0ewDPRIQhKgC5EcOIJloEcSkgBdiOTAESwDPZKQBOhCJAeOYBnoke3Q2/mW9B4/Fus+dmcwzG8m6v0+vcfXGnvcAQ+1Y7v+FaR/NvX2gC5EcuAIloEe2Q6/IHWFt75VL0tRTPmHBnILtGa6+IS6PsdAwfKgC5EcOIJloEe2I1qQk/onwVhsFQ7Vo0MLtEPaHP2eRqFgedCFSA4cwTLQI9vhF2S0OP3VolcEFQJN9oClvyLzz47buVEBfRb06vnqqBbw1dmDpiqg9mA6XrFqY/DBVDvktVhTFIthjT5nmWDhFWiiFt+1nfGBYPmRNCPa5Wn9hD3W2xp0IZIDR7AM9Mh2+LXkl43m+2WsKzC6bBzXr1tRzfIBlNcROevKueYCflXvvD777G3q+lc7jVescor/4aHHC9b2/PfV3sjY/Y5H3wqPOY2C5VvoDTbW4kfS99qX8cOlXV6jVCnoQiQHjmAZ6JHtiBakrB+NYiaL/3mMLX6/pO0UXWmoR5G4YAETRI/XoKgZWPuKguXREEatRa94xxwULGz5dtNVnq/Fd8EKR32x8lGX1wW6EMmBI1gGemQ7ogVp69/Wj2KrNFp+I/fuBK9HZjm46zgULC8E08U3XumhqBkoDWin8dD24n+TY03ScMaqw5xlguVzrF+NtSzrwthdVCbKrwt0IZIDR7AM9Mh2RAvS1l5hhGXoiaho0bL3Zn2TotWLcqllMNNXoR8sJsLyYwisLGeZYJm10VyDXj3ZXEtUnfUUR9JOpGB1D45gGeiR7YgW5HR+Saj5uPy8AI0WhcbrkeTsvH5wbpZgTdwmjv8cNcnQfC8Kk8XHGrzE+MJXzx+0VuNKzEHBGjXtYYnxZbVs12GX74L2FEfYukzB6h4cwTLQI9uhyya6KsFDPl9XpiZTGUUv6yyywDJWQO8SeiGwS8Jrbx1ohK5eO4RqhadbMa+JqhqhbozY1xb6DnqhWZajSQ2O3QWdtaqxFl/4k/q/urCrWqxuRMHqKBzBMtAjB8ktWr13IOhCJAeOYBnokYOEgrUu0IVIDhzBMtAjBwkFa12gC5EcOIJloEcSkgBdiOTAESwDPZKQBOhCJAeOYBnokYQkQBciOXAEy0CPJCQBuhDJgSNYxtEjsUcSsgzxFnQhkgMFi5RxfRKeeyD8/IFw/Z34ECHrhoJFCth5Ixz7fPXzvVdOhqfuq/6JZQhZHxQs0pY3XgjHvxAmr81+1PLOa5V4/f65uBgh64OCRVrx0qPhxJfC7rsztdK0uxOOfzH86rtxYULWBAWLZDJ9O/z0m+HMQ/GvkTXpT6xPfSO89+f4REKKoWCRHP7xh/CDe8OFp2OditIrJ8MTnwl//218OiFlULDIyvzuZ+HY58LkUixPjWlyMTx5T7j0bGyEkAIoWGQFbrwffv29cOLLYe+fsTAl0u5Otc/1i2/H1ghpCwWLHMZ//hKe/Xo4+3D46GYsSYcmOeXMQ+GZr4X3/hSbJSQfChZJIheAT3w2XHgmVqKs9OqPwmN3h79diI0TkgkFiyzn4o/D9++t9s7Lkwjf45+qDGIthKwMBYs08cG/wy+/k71plU5771YGX/hWXBchK0PBIsC1P4anvxrOPBw+3o9FpzB9tF9taf3wK9zSIu2gYJFF/rodHv906aZVOonxx+6uKsLaCUlCwSKLPHVf/FIU5NJPYg2KkhTAsyKevCeumpDDoGCRTF56NPzmWKxQUZICUgzPJaQMChbJhIJFNgcFi2RCwSKbg4JFMqFgkc1BwSKZULDI5qBgkUwoWGRzULBIJhQssjkoWCQTChbZHBQskgkFi2wOChbJhIJFNgcFi2RCwSKbg4JFMqFgkc1BwSKZULDI5qBgkUwoWGRzULBIJhQssjkoWCQTChbZHBQsksn2ifhVfI1IMTyXkDIoWISQ3kDBIoT0BgpWGUePxJdChCxDvAVdiORAwSoDnZKQBOhCJAeOYBnokYQkQBciOXAEy0CPJCQBuhDJgSNYBnokIQnQhUgOHMEy0CM7yNaD4cb71V+fc3M3fqJqcjF+/tMnsXD6/tm5H/6vKjyqH7ba3Znlj5+v8q0WyZRDKz60JdbkdPusWI3C9O2FlmiPLMlRtNlN0IVIDhzBMtAjOwgK1qjWF68Io7lS4OlqQUTBBOvyqfDJx5UFEyz5LOnKuTzBkqNixydp0s541gzfQqldFU1r1PZoXZJPwbpj4AiWgR7ZKWS1+0hEPstqx6S6sGKE5fERFlYdCZa3LzoVHbIISz6gbjLCIjUcwTLQIzuIj7AsVEEswvLlI/lIi5omPcUnlSdTJdWyN88uiM6ypELZGGHJZw3uKFh3DBzBMtAjO8jqgnXtrWofqjH5/SlFTMnl2/5epUcoGRZhqdzIuZFgWYQVhWmHCpB1R69Dl3Wnm6ALkRw4gmWgR3YQXeEiRiIEacE6NMLSoypq43oP6+Zu9cG2osz4KoKF8ZrYuXq+aqpWreGVClM6NV6xdhB0IZIDR7AM9MiucXq+jaW6UyhYcroPtaLgSDfRtfwqgqWV6sWd2dHLPfnbuGevDVCJXNaRLoMuRHLgCJaBHtkpVBo0VFGVkeAFVUDBeCdKKi6Hpkj1EoJlwZol+eeLj1TlNR7UhvlKvUj5/PRVZHdAFyI5cATLQI/sIF47GsMWRYMvDXBUZfz1nUVVhsZu+3vxNaNiF3RWOwqWFY4itSiO0xxLak3Dxn6p1YjLrRSOYBnokR3EJMNEBMv4qEcFS/XIlAJVaVrviOmHxqNRqJUWLN0FE516+Xj1V9tpQmbqqTnaSFW08WGb9J0CXYjkwBEsAz2yg6hkyKWW/F227+MDIln/l09VqiHqIJ9R41TFvEzo5aTJ1tg99W6i4y857UEHS1a7blGpQo3nO2iMsEgNR7AM9MiuoaIgy/vKudTC9iGMqEm0s67hzwf/msnEMjta183d2a3D8fzunopOOsKSHJFU+8GQxnf2fCkjLFLDESwDPZKQBOhCJAeOYBnokYQkQBciOXAEy0CPJCQBuhDJgSNYBnokIQnQhUgOHMEy0CMJSYAuRHLgCJaBHtkaf48/LL8Tt3am88epytFbe5rsBl/i4a8VUbP4qFdrtpreX3h7QBciOXAEy0CPbM1k8R2bCVYvuQrrEix9+sFkxR5ApWB50IVIDhzBMtAjW7O6DK1e8rahD3w2agoFy4MuRHLgCJaBHtkalKFIBab1Q+cf/OvgslEPaTGfo9am9Y9jonwrbI+G+gjLHvUM7ppU9eLKudnlXvSyUDsx+vWfP2T9amyqVYrN0JxlguWtNT7pGhZfd6Ptl3TtrQXBslEyI6poV89XdgrVNgJdiOTAESwDPbI1tmw02YPd+hMZrwhe2ryo6Wc9Ua1p/rh+Gct2/aYXW/lSWDRo5ATLio3my9vrhX/oHNew6qPPMbxg7bw+64LVZR2UzMunmnMaBStSc/mg4yOFd8az6nymdWdUd8G6Y2X0szZVjWM3y0EXIjlwBMtAj2yNlyGPrK7dneqQBQu+ZHSWRlVRvi5XOT1at3bKtN5sikRhu345n612O2T53siKgmVoCKPyFL3ZCnOwbSPouPXRl7GmRm222r3E+/JR/hpBFyI5cATLQI9szTLB0sXj5SASrChpSa8gfjGrteBe0ekFKxIOjXSiQ42C1ahKeGi6+DottTle/Mkh5iwTLD8mVkY/WNJIKmpeJFg+aXkr4GtcC+hCJAeOYBnoka1ZJlia77/wI8FadlajYPkcLbBihJUWrERIYmIxdle1WB4DK8vBto2g49ZIn2+a66v2+dgMhYLVVTiCZaBHtqZRemyl+SUXrUm/zu2Foo2CJafvvH5QnRcsrSvaw1KNWEWw1GBwm9xb8FhD1AUtrPhaMKdRsFRrLNPGxA/OdL5X5QurtcYtOcnR18lTsLoKR7AM9MjW6Bq2JKvozbPVuvLLTJeWLr8wv2JSzdJketEoWL4W0w4TrJG7FgvuAm1FwdJD1hKzb4KldWnS/57HxEiTNiOdo0nbZuMQ3BWuL7wznkVSUduunl/QI2uVGaFgdRWOYBnokYQkQBciOXAEy0CPJCQBuhDJgSNYBnokIQnQhUgOHMEy0CMJSYAuRHLgCJaBHklIAnQhkgNHsAz0SEISoAuRHDiCZaBHEpIAXYjkwBEs4+iR2CMJWYZ4C7oQyYGCRQjpDRQsQkhvoGARQnoDBYsQ0hsoWKSM65Pw3APh5w+E6+/EhwhZNxQsUsDOG+HY58OrJ8MrJ8NT91X/xDKErA8KFmnLGy+E418Ik9dm72Z557VKvH7/XFyMkPVBwSKteOnRcOJLYffdmVpp2t0Jx78YfvXduDAha4KCRTKZvh1++s1w5qGDl+f5pO/tO/WN8N6f4xMJKYaCRXL4xx/CD+4NF56OdSpKr5wMT3wm/P238emElEHBIivzu5+FY58Lk0uxPDWmycXw5D3h0rOxEUIKoGCRFbjxfvj198KJL4e9f8bClEi7O9U+1y++HVsjpC0ULHIY//lLePbr4ezD4aObsSQdmuSUMw+FZ74W3vtTbJaQfChYJIlcAD7x2XDhmViJstKrPwqP3R3+diE2TkgmFCyynIs/Dt+/t9o7L08ifI9/qjKItRCyMhQs0sQH/w6//E72plU67b1bGXzhW3FdhKwMBYsA1/4Ynv5qOPNw+Hg/Fp3C9NF+taX1w69wS4u0g4JFFvnrdnj806WbVukkxh+7u6oIayckCQWLLPLUffGLfZFLP4k1KEpSAM+KePKeuGpCDoOCRTJ56dHwm2OxQkVJCkgxPJeQMihYJBMKFtkcFCySCQWLbA4KFsmEgkU2BwWLZELBIpuDgkUyoWCRzUHBIplQsMjmoGCRTChYZHNQsEgmFCyyOShYJBMKFtkcFCySCQWLbA4KFsmEgkU2BwWLZELBIpuDgkUyoWCRzUHBIplQsMjmoGCRTChYZHNQsEgm2yfiV/E1IsXwXELKoGARQnoDBYsQ0hsoWISQ3kDBIoT0BgpWGUePxJvNhCxDvAVdiORAwSoDnZKQBOhCJAeOYBnokYQkQBciOXAEy0CPJCQBuhDJgSNYBnpkx9l6MNx4v/qLh8htAF2I5MARLAM9svtMLobp23GmMH4+/oWNTx/+byZz8lc+i5FR/Tj77k44ff/sdCsjSKYcWvGxeLEmp9tnRYRVLQvSYEsquPLXUmN3ugm6EMmBI1gGemQHkcWfTqo+Ihm28iO58XGZ/L18KnzycVXeBEvF7sq5PMGSo2LHJ6llZ3zQHtMsaZgqmtYotUiO1uWb3X3QhUgOHMEy0CM7iAYsmB+xomB5fIQVgYLldVN0KjpkEZZ8wNYywiI1HMEy0CM7SCRYFq3oZzu0yiXhocGaJFUcn1SeTJVUy948uyA6y5IGWY0RlnzW4I6CdcfAESwDPbKDqGDZmtfPo1o4RA58aJMVYUlhuXzb36v0CCXDLKjcqNh5wTLjUZh2qABZY1Rhrf29AF2I5MARLAM9soOoYJlOjed7Q6IUN3cPZGhFwdqqN91VKdSCfLCtKJOPVQQL4zWxc/V8uPbWQjtVmNLJdrs6DroQyYEjWAZ6ZAdRtbJAxnQqimXSuqCXhFLe3wqMgqPtehNdrzFXESxtm17cmR2tRf5GW2CKNkAlsl+xlYIuRHLgCJaBHtlBVClMJkQLRLDkg10kWjHVmtHyCGvqNr+XJTVipyQEy4I1S/LPFx+pykuQZWLqK/UN9vleebsMuhDJgSNYBnpkB5HFr9KjCnW63rqSK69oW8oEZbRcsLxZtbO/dyBzHrugs3NRsKxwFKlFcZzmWFJrN3iX8E6EI1gGemTX8Fpj21gj2NuORGQVwZLT1cLU3Wr0R6NQKy1YugsmOvXy8eqvip0JmUqtltzlc1h3LhzBMtAju4YXKY9JgBLFOGnB0njHm53U2+cmW2P31LtZ1jKa7EEHSxaO6RaVNm88fyaLERap4QiWgR7ZKUx3vDRg0mjI6xeeKGX0GlA/Y12juWzd3J3dOhzPd/FVdNIRluS8+Mhsc03LSF32fCkjLFLDESwDPZKQBOhCJAeOYBnokYQkQBciOXAEy0CPJCQBuhDJgSNYBnokIQnQhUgOHMEy0CMJSYAuRHLgCJaBHpmF3gvTO/p4dHXs2YXtE9VjAf4GXC7lFjzb7o1X2k3tsr8j2QJ7+gEPtWN78WeVtw50IZIDR7AM9MgsZJ3s761BIAoFa+Je79nOQiNi1r/3Sh+qomCRAjiCZaBHZjGZv0Sh8EkiE6x2eMFaF+P698kofBQsUgBHsAz0yNXZmv8Iebz4NnTN10xN9rylLPUr5w4e8tYHMkfLIyx7dNMHUNGrYPxD5JP6pQ7egj04qkfNrLZEU6NWLlPhSLDMvh8By/Qd9DnLBMv6G5oexA+LtagRTTvjA8Gy52O9Ee2yFAuuVS1AFyI5cATLQI9cHV0DuK2jC8mWloUq0cPfKj16VqNgTdwVmfy9fKqyIEtOlUuOWhU+woosWBltla5V1QWrEd/0kgij/CE59+r5g0w1OHbyrS+Jx5xGwbKBigw21uK7o/lahS+jn32XS6RKQRciOXAEy0CPXJ2p+82wl4xoNdqy8evHLOjSQsFKSIay7S6CGgULRcEU1ivIqOnHz4nalx2yLnjdUTAH24aD4zto+Fqsy75w1DVf3ue3Bl2I5MARLAM9ckV0yflka3JrfqlohVURcKnbckLBQiOjxYsdX+MywYos2KKNVjsK1rLMEURYdn0a3HXrZH4FZ52NcpYJls+xjjTWYiNmhU2womQa7bvcGnQhkgNHsAz0yBXxGjFaDBAipbCliGvSRKFRsKIlHVVqJZflowVbtKsIlqlblB91x06MBkQtLAu1sG2RtdFcg1492VxLVJ21dlmzKVjdgCNYBnrkKuDqGtVrSZeKrkZbHpavZ9ly8usZBcufqPmXTy2sUimfjrAiC14jVhGsqLV61sTFiX4QfJevnp/VbsKNOShYaj/aw7LqsJZtt/Wm+X7wvcA1drk16EIkB45gGeiRq+BFwWfqEtJlKatUL2Rszevak/wP62tJH300Cpbm++sataBpZ3xQUldpOOwuoQnEKoKFp2sLTbBG7pJQarz21symNSYs3hNclqPJZMWSNamxFl/4k/p/vrANL6xOC1OwOgBHsAz0yHIsjojy/VInPQVdiOTAESwDPbIcCtaAQRciOXAEy0CPLIeCNWDQhUgOHMEy0CMJSYAuRHLgCJaBHklIAnQhkgNHsAz0SEISoAuRHDiCZaBHEpIAXYjkwBEs4+iR2CMJWYZ4C7oQyYGCRQjpDRQsQkhvoGARQnoDBYsQ0hsoWEPn+iQ890D4+QPh+jvxoX4xmI6QAihYg2bnjXDs89U7oV45GZ66r/onlukFg+kIKYOCNVzeeCEc/0KYvDZ7U8o7r1Vr/vfPxcW6z2A6QoqhYA2Ulx4NJ74Udt+dLXJNuzvh+BfDr74bF+4yg+kIWQcUrMExfTv89JvhzEPxK+406esAT30jvPfn+MSuMZiOkPVBwRoW//hD+MG94cLT8fKO0isnwxOfCX//bXx6dxhMR8haoWANiN/9LBz7XJhcild1Y5pcDE/eEy49GxvpAoPpCFk3FKxBcOP98OvvhRNfDnv/jNdzIu3uVNtDv/h2bG2DDKYj5NZAweo///lLePbr4ezD4aOb8Uo+NMkpZx4Kz3wtvPen2OztZzAdIbcMClbPkeumJz4bLjwTL+Cs9OqPwmN3h79diI3fTgbTEXIroWD1mYs/Dt+/t9pyLk+iF49/qjKItdwGBtMRcouhYPWTD/4dfvmd7L2edNp7tzL4wrfium4pg+kIuS1QsHrItT+Gp78azjwcPt6P12ph+mi/2gn64Vdu007QYDpCbhcUrL7x1+3w+KdL93rSSYw/dndVEda+RgbTEXIboWD1jafui1+8i1z6Sbx0oyQF8KyIJ++Jq14vg+kIuY1QsAbHS4+G3xyLF3aUpIAUw3M7xWA6QtYHBWtwDGadD6YjZH1QsAbHYNb5YDpC1gcFa3AMZp0PpiNkfVCwBsdg1vlgOkLWBwVrcAxmnQ+mI2R9ULAGx2DW+WA6QtYHBWtwDGadD6YjZH1QsAbHYNb5YDpC1gcFa3AMZp0PpiNkfVCwBsdg1vlgOkLWBwVrcAxmnQ+mI2R9ULAGx2DW+WA6QtYHBWtwDGadD6YjZH1QsAbHYNb5YDpC1gcFa3AMZp0PpiNkfVCwBsf2ifgNdo1IMTy3UwymI2R9ULAIIb2BgkUI6Q0ULEJIb6BgEUJ6AwWLENIbKFiEkN5AwSKE9IYCwTp6JH4ihnQEmRqcr6FCP+wst8APCwQL20e6A87XUMG+k+6A81VGgUVsHOkOOF9DBftOugPOVxkFFrFxpDvgfA0V7DvpDjhfZRRYxMaR7oDzNVSw76Q74HyVUWARG1fI6fvD7s5KP3mdXAzTt+PMCLF24/0wfj7OV7YeDB/+r7Izqn89K/VKefks5SVfjpqRFZs0qltl1clnRdqglgVpsyXJl1rkr6VDe5QFztdQwb4Xsvqk0w8PBeerjAKL2LhC/ISl0WludAIdfZ3pZZ/1n5dPhU8+roxYvfJZ0pVzeY4iR8WOT1LRznjmhWLTfEVcQdusNUotkqN1SX63HaW7YN8LoR+i8dbgfJVRYBEb1w4Z0ETSkVXPSCSZKp3O6AvNJkCOXnsrrlpJOCg6im+tVWqHfL3qKJ4+f7N1F+x7O+iHmrrthwUWsXHt0JAV8/WQOYqMY+NcjmA6J02Buq8l7ZqadKZ9UrewJmmlb55dmOxlSb/cGr/Z5LN+qWKbS8D5GirY93bQD/vghwUWsXHtWMVRsoiibs25ubvwLWTI9EjYvL9X+QFOlbmgTrPYiRzFbEZfj4dOvDVyXMf/LbqZBudrqGDf20E/7IMfFljExrUj/T2jI5guo8l7W+R8OG1b89h+XO8diBvJB9sCsGlbxVGwbWLn6vlZ5D+e7x2oQ6ST7TKUg/M1VLDv7cB59Il+2A6crzIKLGLj2hFNanTI5izCwtpG/FcZfq3Juf4WTPSltF1vXmqTVnGU0Tz493a25huZ/tsvaoC6ZqIXJeB8DRXsezvoh9HRtYDzVUaBRWxcO/CbwSc/jmO3g5h2FC1sG4qRI07dpuOypKfo6fI34ShbsBEr/3zxkaq8fLlN59+ovlLfcp9vhcvB+Roq2Pd20A8tddgPCyxi49qx+jebd45oshuDWHXB9Oifru/m7O81t0G9TcqYx6CjWOHoG3K6+P2pOb7BatNSup254HwNFex7O+iHmtLtzAXnq4wCi9i4dqzoKBoh+y+K9DebeonuYmIwbIgdtSl/sRmWuaKj6O6D+MfLx6u/6mTmQNZmzdnq0/Mv3QX73g764agHflhgERvXDp3RZclm5Ub9FJz81dFPOIoatHHXc82UMa2/Z/z06InmLmP3tLFNtm+tuqDPsa9B3RrQRo7nVxBao5Xs1Tdbd8G+t4N+qKnbflhgERvXjskK32xT97WzzLGm9XdUWLxN49GjH/xrNj3LJkbt39yd3bIRNKlZa1LjN5vkvPjIwd6q+qh9tZpz9/Cbrbtg39tBPxz1wA8LLGLjSHfA+Roq2HfSHXC+yiiwiI0j3QHna6hg30l3wPkqo8AiNo50B5yvoYJ9J90B56uMAovYONIdcL6GCvaddAecrzIKLGLjSHfA+Roq2HfSHXC+yiiwiI1L4+/OKtv1j6d8Tjnb7q1AenN3VN9SKbz3YXeI8VA7bkXfPThfQwX7noZ+6LkVfffgfJVRYBEbl+Y2OIo4hH88bzx/8ISOMmCw72noh5619z0C56uMAovYuDS32lHG9W84zUs8dJQBg31PQz/0rLfvCM5XGQUWsXFp0o6iMxHq3xNYGXs2zzK36p+8Xz1f+YRF2oo+sIf1qh07hDZ9pn4TYs4yRxnPH+cLTQ8rh8VarI+SdsYHfbdnoL2Rcf3zMSkWlj+CmADna6hg39PQD/vshwUWsXFpEo6iI2VTcuVc9UH+aeUn87fo61hHLjKajzVOpGKOIjWKk1l5zfQN0xdpY06jo/jvUm+wsRa1oH3UfK3Cl/HjoC7YwkUUnK+hgn1PQz/ssx8WWMTGpTnUUfw3QzQxVrJxwkYrO0pjpp9vBXOwXj+pSmN07Wvx/m2Fo2Hx5aPhygLna6hg39PgwNIP++OHBRaxcWmw535kdSbC4u82fdKZ24K3oBnTpp+5K/6bze7dhMXbN5rMFaKcZY7ic8S4lJG/jbVEzuodJUpaPnKsXHC+hgr2PQ39sM9+WGARG5fGxtFycCx09Kf1TzEbv8ESjoKOaOgkRd9Fk3l47y0s+4rD9kTWRvO5f/Vkcy1RddbaZc3GwckC52uoYN/T0A/77IcFFrFxaXRkrfM69Dqg8nnn9Vkx+waQv1Z4e/6fIyUcRe37QR8v3k72U6u1q325zleDZhxz0FHUfrR3IMaX1bJdf92pBc3Xpvpx0KZqmY45SnfBvqehH/bZDwssYuMORQfRko3OyIW+fqan8xf3ePda5iiRneDudJjz6WxpLeJ5alanSpOf4GU5mmw6LVl3GmvxhT+p/3cAvAzxRjrmKN0F+34o9ENNPfTDAovYONIdcL6GCvaddAecrzIKLGLjSHfA+Roq2HfSHXC+yiiwiI0j3QHna6hg30l3wPkqo8AiNo50B5yvoYJ9J90B56uMAovYONIdcL6GCvaddAecrzIKLGLjSHfA+Roq2HfSHXC+yiiwiI0j3QHna6hg30l3wPkqo8Di0SNx40hHkKnB+Roq9MPOcgv8sECwCCHk9kLBIoT0BgoWIaQ3ULAIIb2BgkUI6Q0ULEJIb6BgEUJ6AwWLENIbKFiEkN5wV/jvdcwlhJAOctfsjahMTExMnU//Dy3iTDh9/NjeAAAAAElFTkSuQmCC" alt="img.png"></p> <p>而双亲模型，就是按照类加载器的层级关系，逐层进行委派。比如当需要加载一个class文件的时候，
首先会把这个class的查询和加载委派给父加载器去执行，如果父加载器都无法加载，再尝试自己来加载这个class。</p> <p><img src="/zhuangxiaoyan/assets/img/jvm004.625989ca.png" alt="img.png"></p> <p>不过，双亲委派并不是一个强制性的约束模型，我们可以通过一些方式去打破双亲委派模型。这个打破的意思，
就是类加载器可以加载不属于当前作用范围的类，实际上，JVM本身就存在双亲委派被破坏的情况。</p> <ul><li><p>第一种情况，双亲委派是在JDK1.2版本发布的，而类加载器和抽象类ClassLoader在JDK1.0就已经存在了，用户可以通过重写ClassLoader里面的loadClass()方法实现自定义类加载，
JDK1.2为了向前兼容，所以在设计的时候需要兼容loadClass()重写的实现，导致双亲委派被破坏的情况。同时，为了避免后续再出现这样的问题，
不在提倡重写loadClass()方法，而是使用JDK1.2中ClassLoader中提供了findClass方法来实现符合双亲委派规则的类加载逻辑。</p></li> <li><p>第二种情况，在这个类加载模型中，有可能存在顶层类加载器加载的类，需要调用用户类加载器实现的代码的情况。
比如java.jdbc.Driver接口，它只是一个数据库驱动接口，这个接口是由启动类加载器加载的。但是java.jdbc.Driver接口的实现是由各大数据库厂商来完成的，既然是自己实现的代码，就应该由应用类加载器来加载。
于是就出现了启动类加载器加载的类要调用应用类加载器加载的实现。为了解决这个问题，在JVM中引入了线程上下文类加载器，它可以把原本需要启动类加载器加载的类，由应用类加载器进行加载。
除此之外，像Tomcat容器，也存在破坏双亲委派的情况，来实现不同应用之间的资源隔离。</p></li></ul> <h2 id="jvm为什么使用元空间替换了永久代"><a href="#jvm为什么使用元空间替换了永久代" class="header-anchor">#</a> JVM为什么使用元空间替换了永久代？</h2> <ul><li>在1.7版本里面，永久代内存是有上限的，虽然我们可以通过参数来设置，但是JVM加载的class总数、大小是很难确定的。所以很容易出现OOM问题。
但是元空间是存储在本地内存里面，内存上限比较大，可以很好的避免这个问题。</li> <li>永久代的对象是通过FullGC进行垃圾收集，也就是和老年代同时实现垃圾收集。替换成元空间以后，简化了Full GC。可以在不进行暂停的情况下并发地释放类数据，同时也提升了GC的性能</li> <li>Oracle要合并Hotspot和JRockit的代码，而JRockit没有永久代。</li></ul> <h2 id="happens-before的理解"><a href="#happens-before的理解" class="header-anchor">#</a> Happens-Before的理解</h2> <ul><li>首先，Happens-Before是一种可见性模型，也就是说，在多线程环境下。原本因为指令重排序的存在会导致数据的可见性问题，也就是A线程修改某个共享变量对B线程不可见。
因此，JMM通过Happens-Before关系向开发人员提供跨越线程的内存可见性保证。如果一个操作的执行结果对另外一个操作可见，那么这两个操作之间必然存在Happens-Before管理。</li> <li>Happens-Before关系只是描述结果的可见性，并不表示指令执行的先后顺序，也就是说只要不对结果产生影响，仍然允许指令的重排序。</li> <li>最后，在JMM中存在很多的Happens-Before规则。
<ul><li>程序顺序规则，一个线程中的每个操作，happens-before这个线程中的任意后续操作，可以简单认为是as-if-serial也就是不管怎么重排序，单线程的程序的执行结果不能改变</li> <li>传递性规则，也就是A Happens-Before B，B Happens-Before C。</li> <li>就可以推导出A Happens-Before C。</li> <li>volatile变量规则，对一个volatile修饰的变量的写一定happens-before于任意后续对这个volatile变量的读操作</li> <li>监视器锁规则，一个线程对于一个锁的释放锁操作，一定happens-before与后续线程对这个锁的加锁操作在这个场景中，如果线程A获得了锁并且把x修改成了12，那么后续的线程获得锁之后得到的x的值一定是12。</li> <li>线程启动规则，如果线程A执行操作ThreadB.start(),那么线程A的ThreadB.start()之前的操作happens-before线程B中的任意操作。</li> <li>join规则，如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功的返回。</li></ul></li></ul> <h2 id="jvm分代年龄为什么是15次"><a href="#jvm分代年龄为什么是15次" class="header-anchor">#</a> JVM分代年龄为什么是15次？</h2> <p>其次呢，一个对象的GC年龄，是存储在对象头里面的，一个Java对象在JVM内存中的布局由三个部分组成，分别是对象头、实例数据、对齐填充。而对象头里面有4个bit位来存储GC年龄。</p> <p><img src="/zhuangxiaoyan/assets/img/jvm005.896592ec.png" alt="img.png"></p> <p>而4个bit位能够存储的最大数值是15，所以从这个角度来说，JVM分代年龄之所以设置成15次是因为它最大能够存储的数值就是15。
虽然JVM提供了参数来设置分代年龄的大小，但是这个大小不能超过15。而从设计角度来看，当一个对象触发了最大值15次gc，还没有办法被回收，就只能移动到old generation了。
另外，设计者还引入了动态对象年龄判断的方式来决定把对象转移到old generation，也就是说不管这个对象的gc年龄是否达到了15次，只要满足动态年龄判断的依据，也同样会转移到old generation。以上就是我对这个问题的理解。</p> <h2 id="什么是双亲委派"><a href="#什么是双亲委派" class="header-anchor">#</a> 什么是双亲委派？</h2> <p>首先，我简单说一下类的加载机制：就是我们自己写的java源文件到最终运行，必须要经过编译和类加载两个阶段。</p> <ol><li>编译的过程就是把.java文件编译成.class文件。</li></ol> <p><img src="/zhuangxiaoyan/assets/img/class-loader01.e0706d65.png" alt="img.png"></p> <ol start="2"><li>类加载的过程，就是把class文件装载到JVM内存中，装载完成以后就会得到一个Class对象，我们就可以使用new关键字来实例化这个对象。</li></ol> <p><img src="data:image/png;base64,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" alt="img.png"></p> <p>而类的加载过程，需要涉及到类加载器。</p> <p>JVM在运行的时候，会产生3个类加载器，这三个类加载器组成了一个层级关系，每个类加载器分别去加载不同作用范围的jar包，比如</p> <ul><li>Bootstrap ClassLoader，主要是负责Java核心类库的加载，也就是 %{JDK_HOME}\lib下的rt.jar、resources.jar等</li> <li>Extension ClassLoader，主要负责%{JDK_HOME}\lib\ext目录下的jar包和class文件</li> <li>Application ClassLoader，主要负责当前应用里面的classpath下的所有jar包和类文件</li> <li>除了系统自己提供的类加载器以外，还可以通过ClassLoader类实现自定义加载器，去满足一些特殊场景的需求。</li></ul> <p>所谓的父委托模型，就是按照类加载器的层级关系，逐层进行委派。</p> <p><img src="/zhuangxiaoyan/assets/img/class-loader03.625989ca.png" alt="img.png"></p> <p>比如当需要加载一个class文件的时候，首先会把这个class的查询和加载委派给父加载器去执行，如果父加载器都无法加载，再尝试自己来加载这个class。</p> <p>这样设计的好处，我认为有几个。</p> <ul><li>安全性，因为这种层级关系实际上代表的是一种优先级，也就是所有的类的加载，优先给Bootstrap ClassLoader。那对于核心类库中的类，就没办法去破坏，比如自己写一个java.lang.String，最终还是会交给启动类加载器。再加上每个类加载器的作用范围，那么自己写的java.lang.String就没办法去覆盖类库中类。</li> <li>我认为这种层级关系的设计，可以避免重复加载导致程序混乱的问题，因为如果父加载器已经加载过了，那么子类就没必要去加载了。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/zhuangxiaoyan/interview/jdk.html" class="prev">
        JDK面试问题
      </a></span> <span class="next"><a href="/zhuangxiaoyan/interview/network.html">
        网络面试问题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/zhuangxiaoyan/assets/js/app.868ae4fe.js" defer></script><script src="/zhuangxiaoyan/assets/js/2.e0e92cc0.js" defer></script><script src="/zhuangxiaoyan/assets/js/13.875c4422.js" defer></script>
  </body>
</html>
